/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_fine-uploader_fine-uploader_fine-uploader_js"],{

/***/ "./node_modules/fine-uploader/fine-uploader/fine-uploader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/fine-uploader/fine-uploader/fine-uploader.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;// Fine Uploader 5.16.2 - MIT licensed. http://fineuploader.com\n(function(global) {\n    var qq = function(element) {\n        \"use strict\";\n        return {\n            hide: function() {\n                element.style.display = \"none\";\n                return this;\n            },\n            attach: function(type, fn) {\n                if (element.addEventListener) {\n                    element.addEventListener(type, fn, false);\n                } else if (element.attachEvent) {\n                    element.attachEvent(\"on\" + type, fn);\n                }\n                return function() {\n                    qq(element).detach(type, fn);\n                };\n            },\n            detach: function(type, fn) {\n                if (element.removeEventListener) {\n                    element.removeEventListener(type, fn, false);\n                } else if (element.attachEvent) {\n                    element.detachEvent(\"on\" + type, fn);\n                }\n                return this;\n            },\n            contains: function(descendant) {\n                if (!descendant) {\n                    return false;\n                }\n                if (element === descendant) {\n                    return true;\n                }\n                if (element.contains) {\n                    return element.contains(descendant);\n                } else {\n                    return !!(descendant.compareDocumentPosition(element) & 8);\n                }\n            },\n            insertBefore: function(elementB) {\n                elementB.parentNode.insertBefore(element, elementB);\n                return this;\n            },\n            remove: function() {\n                element.parentNode.removeChild(element);\n                return this;\n            },\n            css: function(styles) {\n                if (element.style == null) {\n                    throw new qq.Error(\"Can't apply style to node as it is not on the HTMLElement prototype chain!\");\n                }\n                if (styles.opacity != null) {\n                    if (typeof element.style.opacity !== \"string\" && typeof element.filters !== \"undefined\") {\n                        styles.filter = \"alpha(opacity=\" + Math.round(100 * styles.opacity) + \")\";\n                    }\n                }\n                qq.extend(element.style, styles);\n                return this;\n            },\n            hasClass: function(name, considerParent) {\n                var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n                return re.test(element.className) || !!(considerParent && re.test(element.parentNode.className));\n            },\n            addClass: function(name) {\n                if (!qq(element).hasClass(name)) {\n                    element.className += \" \" + name;\n                }\n                return this;\n            },\n            removeClass: function(name) {\n                var re = new RegExp(\"(^| )\" + name + \"( |$)\");\n                element.className = element.className.replace(re, \" \").replace(/^\\s+|\\s+$/g, \"\");\n                return this;\n            },\n            getByClass: function(className, first) {\n                var candidates, result = [];\n                if (first && element.querySelector) {\n                    return element.querySelector(\".\" + className);\n                } else if (element.querySelectorAll) {\n                    return element.querySelectorAll(\".\" + className);\n                }\n                candidates = element.getElementsByTagName(\"*\");\n                qq.each(candidates, function(idx, val) {\n                    if (qq(val).hasClass(className)) {\n                        result.push(val);\n                    }\n                });\n                return first ? result[0] : result;\n            },\n            getFirstByClass: function(className) {\n                return qq(element).getByClass(className, true);\n            },\n            children: function() {\n                var children = [], child = element.firstChild;\n                while (child) {\n                    if (child.nodeType === 1) {\n                        children.push(child);\n                    }\n                    child = child.nextSibling;\n                }\n                return children;\n            },\n            setText: function(text) {\n                element.innerText = text;\n                element.textContent = text;\n                return this;\n            },\n            clearText: function() {\n                return qq(element).setText(\"\");\n            },\n            hasAttribute: function(attrName) {\n                var attrVal;\n                if (element.hasAttribute) {\n                    if (!element.hasAttribute(attrName)) {\n                        return false;\n                    }\n                    return /^false$/i.exec(element.getAttribute(attrName)) == null;\n                } else {\n                    attrVal = element[attrName];\n                    if (attrVal === undefined) {\n                        return false;\n                    }\n                    return /^false$/i.exec(attrVal) == null;\n                }\n            }\n        };\n    };\n    (function() {\n        \"use strict\";\n        qq.canvasToBlob = function(canvas, mime, quality) {\n            return qq.dataUriToBlob(canvas.toDataURL(mime, quality));\n        };\n        qq.dataUriToBlob = function(dataUri) {\n            var arrayBuffer, byteString, createBlob = function(data, mime) {\n                var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, blobBuilder = BlobBuilder && new BlobBuilder();\n                if (blobBuilder) {\n                    blobBuilder.append(data);\n                    return blobBuilder.getBlob(mime);\n                } else {\n                    return new Blob([ data ], {\n                        type: mime\n                    });\n                }\n            }, intArray, mimeString;\n            if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n                byteString = atob(dataUri.split(\",\")[1]);\n            } else {\n                byteString = decodeURI(dataUri.split(\",\")[1]);\n            }\n            mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n            arrayBuffer = new ArrayBuffer(byteString.length);\n            intArray = new Uint8Array(arrayBuffer);\n            qq.each(byteString, function(idx, character) {\n                intArray[idx] = character.charCodeAt(0);\n            });\n            return createBlob(arrayBuffer, mimeString);\n        };\n        qq.log = function(message, level) {\n            if (window.console) {\n                if (!level || level === \"info\") {\n                    window.console.log(message);\n                } else {\n                    if (window.console[level]) {\n                        window.console[level](message);\n                    } else {\n                        window.console.log(\"<\" + level + \"> \" + message);\n                    }\n                }\n            }\n        };\n        qq.isObject = function(variable) {\n            return variable && !variable.nodeType && Object.prototype.toString.call(variable) === \"[object Object]\";\n        };\n        qq.isFunction = function(variable) {\n            return typeof variable === \"function\";\n        };\n        qq.isArray = function(value) {\n            return Object.prototype.toString.call(value) === \"[object Array]\" || value && window.ArrayBuffer && value.buffer && value.buffer.constructor === ArrayBuffer;\n        };\n        qq.isItemList = function(maybeItemList) {\n            return Object.prototype.toString.call(maybeItemList) === \"[object DataTransferItemList]\";\n        };\n        qq.isNodeList = function(maybeNodeList) {\n            return Object.prototype.toString.call(maybeNodeList) === \"[object NodeList]\" || maybeNodeList.item && maybeNodeList.namedItem;\n        };\n        qq.isString = function(maybeString) {\n            return Object.prototype.toString.call(maybeString) === \"[object String]\";\n        };\n        qq.trimStr = function(string) {\n            if (String.prototype.trim) {\n                return string.trim();\n            }\n            return string.replace(/^\\s+|\\s+$/g, \"\");\n        };\n        qq.format = function(str) {\n            var args = Array.prototype.slice.call(arguments, 1), newStr = str, nextIdxToReplace = newStr.indexOf(\"{}\");\n            qq.each(args, function(idx, val) {\n                var strBefore = newStr.substring(0, nextIdxToReplace), strAfter = newStr.substring(nextIdxToReplace + 2);\n                newStr = strBefore + val + strAfter;\n                nextIdxToReplace = newStr.indexOf(\"{}\", nextIdxToReplace + val.length);\n                if (nextIdxToReplace < 0) {\n                    return false;\n                }\n            });\n            return newStr;\n        };\n        qq.isFile = function(maybeFile) {\n            return window.File && Object.prototype.toString.call(maybeFile) === \"[object File]\";\n        };\n        qq.isFileList = function(maybeFileList) {\n            return window.FileList && Object.prototype.toString.call(maybeFileList) === \"[object FileList]\";\n        };\n        qq.isFileOrInput = function(maybeFileOrInput) {\n            return qq.isFile(maybeFileOrInput) || qq.isInput(maybeFileOrInput);\n        };\n        qq.isInput = function(maybeInput, notFile) {\n            var evaluateType = function(type) {\n                var normalizedType = type.toLowerCase();\n                if (notFile) {\n                    return normalizedType !== \"file\";\n                }\n                return normalizedType === \"file\";\n            };\n            if (window.HTMLInputElement) {\n                if (Object.prototype.toString.call(maybeInput) === \"[object HTMLInputElement]\") {\n                    if (maybeInput.type && evaluateType(maybeInput.type)) {\n                        return true;\n                    }\n                }\n            }\n            if (maybeInput.tagName) {\n                if (maybeInput.tagName.toLowerCase() === \"input\") {\n                    if (maybeInput.type && evaluateType(maybeInput.type)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        qq.isBlob = function(maybeBlob) {\n            if (window.Blob && Object.prototype.toString.call(maybeBlob) === \"[object Blob]\") {\n                return true;\n            }\n        };\n        qq.isXhrUploadSupported = function() {\n            var input = document.createElement(\"input\");\n            input.type = \"file\";\n            return input.multiple !== undefined && typeof File !== \"undefined\" && typeof FormData !== \"undefined\" && typeof qq.createXhrInstance().upload !== \"undefined\";\n        };\n        qq.createXhrInstance = function() {\n            if (window.XMLHttpRequest) {\n                return new XMLHttpRequest();\n            }\n            try {\n                return new ActiveXObject(\"MSXML2.XMLHTTP.3.0\");\n            } catch (error) {\n                qq.log(\"Neither XHR or ActiveX are supported!\", \"error\");\n                return null;\n            }\n        };\n        qq.isFolderDropSupported = function(dataTransfer) {\n            return dataTransfer.items && dataTransfer.items.length > 0 && dataTransfer.items[0].webkitGetAsEntry;\n        };\n        qq.isFileChunkingSupported = function() {\n            return !qq.androidStock() && qq.isXhrUploadSupported() && (File.prototype.slice !== undefined || File.prototype.webkitSlice !== undefined || File.prototype.mozSlice !== undefined);\n        };\n        qq.sliceBlob = function(fileOrBlob, start, end) {\n            var slicer = fileOrBlob.slice || fileOrBlob.mozSlice || fileOrBlob.webkitSlice;\n            return slicer.call(fileOrBlob, start, end);\n        };\n        qq.arrayBufferToHex = function(buffer) {\n            var bytesAsHex = \"\", bytes = new Uint8Array(buffer);\n            qq.each(bytes, function(idx, byt) {\n                var byteAsHexStr = byt.toString(16);\n                if (byteAsHexStr.length < 2) {\n                    byteAsHexStr = \"0\" + byteAsHexStr;\n                }\n                bytesAsHex += byteAsHexStr;\n            });\n            return bytesAsHex;\n        };\n        qq.readBlobToHex = function(blob, startOffset, length) {\n            var initialBlob = qq.sliceBlob(blob, startOffset, startOffset + length), fileReader = new FileReader(), promise = new qq.Promise();\n            fileReader.onload = function() {\n                promise.success(qq.arrayBufferToHex(fileReader.result));\n            };\n            fileReader.onerror = promise.failure;\n            fileReader.readAsArrayBuffer(initialBlob);\n            return promise;\n        };\n        qq.extend = function(first, second, extendNested) {\n            qq.each(second, function(prop, val) {\n                if (extendNested && qq.isObject(val)) {\n                    if (first[prop] === undefined) {\n                        first[prop] = {};\n                    }\n                    qq.extend(first[prop], val, true);\n                } else {\n                    first[prop] = val;\n                }\n            });\n            return first;\n        };\n        qq.override = function(target, sourceFn) {\n            var super_ = {}, source = sourceFn(super_);\n            qq.each(source, function(srcPropName, srcPropVal) {\n                if (target[srcPropName] !== undefined) {\n                    super_[srcPropName] = target[srcPropName];\n                }\n                target[srcPropName] = srcPropVal;\n            });\n            return target;\n        };\n        qq.indexOf = function(arr, elt, from) {\n            if (arr.indexOf) {\n                return arr.indexOf(elt, from);\n            }\n            from = from || 0;\n            var len = arr.length;\n            if (from < 0) {\n                from += len;\n            }\n            for (;from < len; from += 1) {\n                if (arr.hasOwnProperty(from) && arr[from] === elt) {\n                    return from;\n                }\n            }\n            return -1;\n        };\n        qq.getUniqueId = function() {\n            return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n                var r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 3 | 8;\n                return v.toString(16);\n            });\n        };\n        qq.ie = function() {\n            return navigator.userAgent.indexOf(\"MSIE\") !== -1 || navigator.userAgent.indexOf(\"Trident\") !== -1;\n        };\n        qq.ie7 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 7\") !== -1;\n        };\n        qq.ie8 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 8\") !== -1;\n        };\n        qq.ie10 = function() {\n            return navigator.userAgent.indexOf(\"MSIE 10\") !== -1;\n        };\n        qq.ie11 = function() {\n            return qq.ie() && navigator.userAgent.indexOf(\"rv:11\") !== -1;\n        };\n        qq.edge = function() {\n            return navigator.userAgent.indexOf(\"Edge\") >= 0;\n        };\n        qq.safari = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Apple\") !== -1;\n        };\n        qq.chrome = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Google\") !== -1;\n        };\n        qq.opera = function() {\n            return navigator.vendor !== undefined && navigator.vendor.indexOf(\"Opera\") !== -1;\n        };\n        qq.firefox = function() {\n            return !qq.edge() && !qq.ie11() && navigator.userAgent.indexOf(\"Mozilla\") !== -1 && navigator.vendor !== undefined && navigator.vendor === \"\";\n        };\n        qq.windows = function() {\n            return navigator.platform === \"Win32\";\n        };\n        qq.android = function() {\n            return navigator.userAgent.toLowerCase().indexOf(\"android\") !== -1;\n        };\n        qq.androidStock = function() {\n            return qq.android() && navigator.userAgent.toLowerCase().indexOf(\"chrome\") < 0;\n        };\n        qq.ios6 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 6_\") !== -1;\n        };\n        qq.ios7 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 7_\") !== -1;\n        };\n        qq.ios8 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 8_\") !== -1;\n        };\n        qq.ios800 = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\" OS 8_0 \") !== -1;\n        };\n        qq.ios = function() {\n            return navigator.userAgent.indexOf(\"iPad\") !== -1 || navigator.userAgent.indexOf(\"iPod\") !== -1 || navigator.userAgent.indexOf(\"iPhone\") !== -1;\n        };\n        qq.iosChrome = function() {\n            return qq.ios() && navigator.userAgent.indexOf(\"CriOS\") !== -1;\n        };\n        qq.iosSafari = function() {\n            return qq.ios() && !qq.iosChrome() && navigator.userAgent.indexOf(\"Safari\") !== -1;\n        };\n        qq.iosSafariWebView = function() {\n            return qq.ios() && !qq.iosChrome() && !qq.iosSafari();\n        };\n        qq.preventDefault = function(e) {\n            if (e.preventDefault) {\n                e.preventDefault();\n            } else {\n                e.returnValue = false;\n            }\n        };\n        qq.toElement = function() {\n            var div = document.createElement(\"div\");\n            return function(html) {\n                div.innerHTML = html;\n                var element = div.firstChild;\n                div.removeChild(element);\n                return element;\n            };\n        }();\n        qq.each = function(iterableItem, callback) {\n            var keyOrIndex, retVal;\n            if (iterableItem) {\n                if (window.Storage && iterableItem.constructor === window.Storage) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(iterableItem.key(keyOrIndex), iterableItem.getItem(iterableItem.key(keyOrIndex)));\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else if (qq.isArray(iterableItem) || qq.isItemList(iterableItem) || qq.isNodeList(iterableItem)) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else if (qq.isString(iterableItem)) {\n                    for (keyOrIndex = 0; keyOrIndex < iterableItem.length; keyOrIndex++) {\n                        retVal = callback(keyOrIndex, iterableItem.charAt(keyOrIndex));\n                        if (retVal === false) {\n                            break;\n                        }\n                    }\n                } else {\n                    for (keyOrIndex in iterableItem) {\n                        if (Object.prototype.hasOwnProperty.call(iterableItem, keyOrIndex)) {\n                            retVal = callback(keyOrIndex, iterableItem[keyOrIndex]);\n                            if (retVal === false) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        qq.bind = function(oldFunc, context) {\n            if (qq.isFunction(oldFunc)) {\n                var args = Array.prototype.slice.call(arguments, 2);\n                return function() {\n                    var newArgs = qq.extend([], args);\n                    if (arguments.length) {\n                        newArgs = newArgs.concat(Array.prototype.slice.call(arguments));\n                    }\n                    return oldFunc.apply(context, newArgs);\n                };\n            }\n            throw new Error(\"first parameter must be a function!\");\n        };\n        qq.obj2url = function(obj, temp, prefixDone) {\n            var uristrings = [], prefix = \"&\", add = function(nextObj, i) {\n                var nextTemp = temp ? /\\[\\]$/.test(temp) ? temp : temp + \"[\" + i + \"]\" : i;\n                if (nextTemp !== \"undefined\" && i !== \"undefined\") {\n                    uristrings.push(typeof nextObj === \"object\" ? qq.obj2url(nextObj, nextTemp, true) : Object.prototype.toString.call(nextObj) === \"[object Function]\" ? encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj()) : encodeURIComponent(nextTemp) + \"=\" + encodeURIComponent(nextObj));\n                }\n            };\n            if (!prefixDone && temp) {\n                prefix = /\\?/.test(temp) ? /\\?$/.test(temp) ? \"\" : \"&\" : \"?\";\n                uristrings.push(temp);\n                uristrings.push(qq.obj2url(obj));\n            } else if (Object.prototype.toString.call(obj) === \"[object Array]\" && typeof obj !== \"undefined\") {\n                qq.each(obj, function(idx, val) {\n                    add(val, idx);\n                });\n            } else if (typeof obj !== \"undefined\" && obj !== null && typeof obj === \"object\") {\n                qq.each(obj, function(prop, val) {\n                    add(val, prop);\n                });\n            } else {\n                uristrings.push(encodeURIComponent(temp) + \"=\" + encodeURIComponent(obj));\n            }\n            if (temp) {\n                return uristrings.join(prefix);\n            } else {\n                return uristrings.join(prefix).replace(/^&/, \"\").replace(/%20/g, \"+\");\n            }\n        };\n        qq.obj2FormData = function(obj, formData, arrayKeyName) {\n            if (!formData) {\n                formData = new FormData();\n            }\n            qq.each(obj, function(key, val) {\n                key = arrayKeyName ? arrayKeyName + \"[\" + key + \"]\" : key;\n                if (qq.isObject(val)) {\n                    qq.obj2FormData(val, formData, key);\n                } else if (qq.isFunction(val)) {\n                    formData.append(key, val());\n                } else {\n                    formData.append(key, val);\n                }\n            });\n            return formData;\n        };\n        qq.obj2Inputs = function(obj, form) {\n            var input;\n            if (!form) {\n                form = document.createElement(\"form\");\n            }\n            qq.obj2FormData(obj, {\n                append: function(key, val) {\n                    input = document.createElement(\"input\");\n                    input.setAttribute(\"name\", key);\n                    input.setAttribute(\"value\", val);\n                    form.appendChild(input);\n                }\n            });\n            return form;\n        };\n        qq.parseJson = function(json) {\n            if (window.JSON && qq.isFunction(JSON.parse)) {\n                return JSON.parse(json);\n            } else {\n                return eval(\"(\" + json + \")\");\n            }\n        };\n        qq.getExtension = function(filename) {\n            var extIdx = filename.lastIndexOf(\".\") + 1;\n            if (extIdx > 0) {\n                return filename.substr(extIdx, filename.length - extIdx);\n            }\n        };\n        qq.getFilename = function(blobOrFileInput) {\n            if (qq.isInput(blobOrFileInput)) {\n                return blobOrFileInput.value.replace(/.*(\\/|\\\\)/, \"\");\n            } else if (qq.isFile(blobOrFileInput)) {\n                if (blobOrFileInput.fileName !== null && blobOrFileInput.fileName !== undefined) {\n                    return blobOrFileInput.fileName;\n                }\n            }\n            return blobOrFileInput.name;\n        };\n        qq.DisposeSupport = function() {\n            var disposers = [];\n            return {\n                dispose: function() {\n                    var disposer;\n                    do {\n                        disposer = disposers.shift();\n                        if (disposer) {\n                            disposer();\n                        }\n                    } while (disposer);\n                },\n                attach: function() {\n                    var args = arguments;\n                    this.addDisposer(qq(args[0]).attach.apply(this, Array.prototype.slice.call(arguments, 1)));\n                },\n                addDisposer: function(disposeFunction) {\n                    disposers.push(disposeFunction);\n                }\n            };\n        };\n    })();\n    (function() {\n        \"use strict\";\n        if (true) {\n            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n                return qq;\n            }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        } else {}\n    })();\n    (function() {\n        \"use strict\";\n        qq.Error = function(message) {\n            this.message = \"[Fine Uploader \" + qq.version + \"] \" + message;\n        };\n        qq.Error.prototype = new Error();\n    })();\n    qq.version = \"5.16.2\";\n    qq.supportedFeatures = function() {\n        \"use strict\";\n        var supportsUploading, supportsUploadingBlobs, supportsFileDrop, supportsAjaxFileUploading, supportsFolderDrop, supportsChunking, supportsResume, supportsUploadViaPaste, supportsUploadCors, supportsDeleteFileXdr, supportsDeleteFileCorsXhr, supportsDeleteFileCors, supportsFolderSelection, supportsImagePreviews, supportsUploadProgress;\n        function testSupportsFileInputElement() {\n            var supported = true, tempInput;\n            try {\n                tempInput = document.createElement(\"input\");\n                tempInput.type = \"file\";\n                qq(tempInput).hide();\n                if (tempInput.disabled) {\n                    supported = false;\n                }\n            } catch (ex) {\n                supported = false;\n            }\n            return supported;\n        }\n        function isChrome14OrHigher() {\n            return (qq.chrome() || qq.opera()) && navigator.userAgent.match(/Chrome\\/[1][4-9]|Chrome\\/[2-9][0-9]/) !== undefined;\n        }\n        function isCrossOriginXhrSupported() {\n            if (window.XMLHttpRequest) {\n                var xhr = qq.createXhrInstance();\n                return xhr.withCredentials !== undefined;\n            }\n            return false;\n        }\n        function isXdrSupported() {\n            return window.XDomainRequest !== undefined;\n        }\n        function isCrossOriginAjaxSupported() {\n            if (isCrossOriginXhrSupported()) {\n                return true;\n            }\n            return isXdrSupported();\n        }\n        function isFolderSelectionSupported() {\n            return document.createElement(\"input\").webkitdirectory !== undefined;\n        }\n        function isLocalStorageSupported() {\n            try {\n                return !!window.localStorage && qq.isFunction(window.localStorage.setItem);\n            } catch (error) {\n                return false;\n            }\n        }\n        function isDragAndDropSupported() {\n            var span = document.createElement(\"span\");\n            return (\"draggable\" in span || \"ondragstart\" in span && \"ondrop\" in span) && !qq.android() && !qq.ios();\n        }\n        supportsUploading = testSupportsFileInputElement();\n        supportsAjaxFileUploading = supportsUploading && qq.isXhrUploadSupported();\n        supportsUploadingBlobs = supportsAjaxFileUploading && !qq.androidStock();\n        supportsFileDrop = supportsAjaxFileUploading && isDragAndDropSupported();\n        supportsFolderDrop = supportsFileDrop && function() {\n            var input = document.createElement(\"input\");\n            input.type = \"file\";\n            return !!(\"webkitdirectory\" in (input || document.querySelectorAll(\"input[type=file]\")[0]));\n        }();\n        supportsChunking = supportsAjaxFileUploading && qq.isFileChunkingSupported();\n        supportsResume = supportsAjaxFileUploading && supportsChunking && isLocalStorageSupported();\n        supportsUploadViaPaste = supportsAjaxFileUploading && isChrome14OrHigher();\n        supportsUploadCors = supportsUploading && (window.postMessage !== undefined || supportsAjaxFileUploading);\n        supportsDeleteFileCorsXhr = isCrossOriginXhrSupported();\n        supportsDeleteFileXdr = isXdrSupported();\n        supportsDeleteFileCors = isCrossOriginAjaxSupported();\n        supportsFolderSelection = isFolderSelectionSupported();\n        supportsImagePreviews = supportsAjaxFileUploading && window.FileReader !== undefined;\n        supportsUploadProgress = function() {\n            if (supportsAjaxFileUploading) {\n                return !qq.androidStock() && !qq.iosChrome();\n            }\n            return false;\n        }();\n        return {\n            ajaxUploading: supportsAjaxFileUploading,\n            blobUploading: supportsUploadingBlobs,\n            canDetermineSize: supportsAjaxFileUploading,\n            chunking: supportsChunking,\n            deleteFileCors: supportsDeleteFileCors,\n            deleteFileCorsXdr: supportsDeleteFileXdr,\n            deleteFileCorsXhr: supportsDeleteFileCorsXhr,\n            dialogElement: !!window.HTMLDialogElement,\n            fileDrop: supportsFileDrop,\n            folderDrop: supportsFolderDrop,\n            folderSelection: supportsFolderSelection,\n            imagePreviews: supportsImagePreviews,\n            imageValidation: supportsImagePreviews,\n            itemSizeValidation: supportsAjaxFileUploading,\n            pause: supportsChunking,\n            progressBar: supportsUploadProgress,\n            resume: supportsResume,\n            scaling: supportsImagePreviews && supportsUploadingBlobs,\n            tiffPreviews: qq.safari(),\n            unlimitedScaledImageSize: !qq.ios(),\n            uploading: supportsUploading,\n            uploadCors: supportsUploadCors,\n            uploadCustomHeaders: supportsAjaxFileUploading,\n            uploadNonMultipart: supportsAjaxFileUploading,\n            uploadViaPaste: supportsUploadViaPaste\n        };\n    }();\n    qq.isGenericPromise = function(maybePromise) {\n        \"use strict\";\n        return !!(maybePromise && maybePromise.then && qq.isFunction(maybePromise.then));\n    };\n    qq.Promise = function() {\n        \"use strict\";\n        var successArgs, failureArgs, successCallbacks = [], failureCallbacks = [], doneCallbacks = [], state = 0;\n        qq.extend(this, {\n            then: function(onSuccess, onFailure) {\n                if (state === 0) {\n                    if (onSuccess) {\n                        successCallbacks.push(onSuccess);\n                    }\n                    if (onFailure) {\n                        failureCallbacks.push(onFailure);\n                    }\n                } else if (state === -1) {\n                    onFailure && onFailure.apply(null, failureArgs);\n                } else if (onSuccess) {\n                    onSuccess.apply(null, successArgs);\n                }\n                return this;\n            },\n            done: function(callback) {\n                if (state === 0) {\n                    doneCallbacks.push(callback);\n                } else {\n                    callback.apply(null, failureArgs === undefined ? successArgs : failureArgs);\n                }\n                return this;\n            },\n            success: function() {\n                state = 1;\n                successArgs = arguments;\n                if (successCallbacks.length) {\n                    qq.each(successCallbacks, function(idx, callback) {\n                        callback.apply(null, successArgs);\n                    });\n                }\n                if (doneCallbacks.length) {\n                    qq.each(doneCallbacks, function(idx, callback) {\n                        callback.apply(null, successArgs);\n                    });\n                }\n                return this;\n            },\n            failure: function() {\n                state = -1;\n                failureArgs = arguments;\n                if (failureCallbacks.length) {\n                    qq.each(failureCallbacks, function(idx, callback) {\n                        callback.apply(null, failureArgs);\n                    });\n                }\n                if (doneCallbacks.length) {\n                    qq.each(doneCallbacks, function(idx, callback) {\n                        callback.apply(null, failureArgs);\n                    });\n                }\n                return this;\n            }\n        });\n    };\n    qq.BlobProxy = function(referenceBlob, onCreate) {\n        \"use strict\";\n        qq.extend(this, {\n            referenceBlob: referenceBlob,\n            create: function() {\n                return onCreate(referenceBlob);\n            }\n        });\n    };\n    qq.UploadButton = function(o) {\n        \"use strict\";\n        var self = this, disposeSupport = new qq.DisposeSupport(), options = {\n            acceptFiles: null,\n            element: null,\n            focusClass: \"qq-upload-button-focus\",\n            folders: false,\n            hoverClass: \"qq-upload-button-hover\",\n            ios8BrowserCrashWorkaround: false,\n            multiple: false,\n            name: \"qqfile\",\n            onChange: function(input) {},\n            title: null\n        }, input, buttonId;\n        qq.extend(options, o);\n        buttonId = qq.getUniqueId();\n        function createInput() {\n            var input = document.createElement(\"input\");\n            input.setAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME, buttonId);\n            input.setAttribute(\"title\", options.title);\n            self.setMultiple(options.multiple, input);\n            if (options.folders && qq.supportedFeatures.folderSelection) {\n                input.setAttribute(\"webkitdirectory\", \"\");\n            }\n            if (options.acceptFiles) {\n                input.setAttribute(\"accept\", options.acceptFiles);\n            }\n            input.setAttribute(\"type\", \"file\");\n            input.setAttribute(\"name\", options.name);\n            qq(input).css({\n                position: \"absolute\",\n                right: 0,\n                top: 0,\n                fontFamily: \"Arial\",\n                fontSize: qq.ie() && !qq.ie8() ? \"3500px\" : \"118px\",\n                margin: 0,\n                padding: 0,\n                cursor: \"pointer\",\n                opacity: 0\n            });\n            !qq.ie7() && qq(input).css({\n                height: \"100%\"\n            });\n            options.element.appendChild(input);\n            disposeSupport.attach(input, \"change\", function() {\n                options.onChange(input);\n            });\n            disposeSupport.attach(input, \"mouseover\", function() {\n                qq(options.element).addClass(options.hoverClass);\n            });\n            disposeSupport.attach(input, \"mouseout\", function() {\n                qq(options.element).removeClass(options.hoverClass);\n            });\n            disposeSupport.attach(input, \"focus\", function() {\n                qq(options.element).addClass(options.focusClass);\n            });\n            disposeSupport.attach(input, \"blur\", function() {\n                qq(options.element).removeClass(options.focusClass);\n            });\n            return input;\n        }\n        qq(options.element).css({\n            position: \"relative\",\n            overflow: \"hidden\",\n            direction: \"ltr\"\n        });\n        qq.extend(this, {\n            getInput: function() {\n                return input;\n            },\n            getButtonId: function() {\n                return buttonId;\n            },\n            setMultiple: function(isMultiple, optInput) {\n                var input = optInput || this.getInput();\n                if (options.ios8BrowserCrashWorkaround && qq.ios8() && (qq.iosChrome() || qq.iosSafariWebView())) {\n                    input.setAttribute(\"multiple\", \"\");\n                } else {\n                    if (isMultiple) {\n                        input.setAttribute(\"multiple\", \"\");\n                    } else {\n                        input.removeAttribute(\"multiple\");\n                    }\n                }\n            },\n            setAcceptFiles: function(acceptFiles) {\n                if (acceptFiles !== options.acceptFiles) {\n                    input.setAttribute(\"accept\", acceptFiles);\n                }\n            },\n            reset: function() {\n                if (input.parentNode) {\n                    qq(input).remove();\n                }\n                qq(options.element).removeClass(options.focusClass);\n                input = null;\n                input = createInput();\n            }\n        });\n        input = createInput();\n    };\n    qq.UploadButton.BUTTON_ID_ATTR_NAME = \"qq-button-id\";\n    qq.UploadData = function(uploaderProxy) {\n        \"use strict\";\n        var data = [], byUuid = {}, byStatus = {}, byProxyGroupId = {}, byBatchId = {};\n        function getDataByIds(idOrIds) {\n            if (qq.isArray(idOrIds)) {\n                var entries = [];\n                qq.each(idOrIds, function(idx, id) {\n                    entries.push(data[id]);\n                });\n                return entries;\n            }\n            return data[idOrIds];\n        }\n        function getDataByUuids(uuids) {\n            if (qq.isArray(uuids)) {\n                var entries = [];\n                qq.each(uuids, function(idx, uuid) {\n                    entries.push(data[byUuid[uuid]]);\n                });\n                return entries;\n            }\n            return data[byUuid[uuids]];\n        }\n        function getDataByStatus(status) {\n            var statusResults = [], statuses = [].concat(status);\n            qq.each(statuses, function(index, statusEnum) {\n                var statusResultIndexes = byStatus[statusEnum];\n                if (statusResultIndexes !== undefined) {\n                    qq.each(statusResultIndexes, function(i, dataIndex) {\n                        statusResults.push(data[dataIndex]);\n                    });\n                }\n            });\n            return statusResults;\n        }\n        qq.extend(this, {\n            addFile: function(spec) {\n                var status = spec.status || qq.status.SUBMITTING, id = data.push({\n                    name: spec.name,\n                    originalName: spec.name,\n                    uuid: spec.uuid,\n                    size: spec.size == null ? -1 : spec.size,\n                    status: status,\n                    file: spec.file\n                }) - 1;\n                if (spec.batchId) {\n                    data[id].batchId = spec.batchId;\n                    if (byBatchId[spec.batchId] === undefined) {\n                        byBatchId[spec.batchId] = [];\n                    }\n                    byBatchId[spec.batchId].push(id);\n                }\n                if (spec.proxyGroupId) {\n                    data[id].proxyGroupId = spec.proxyGroupId;\n                    if (byProxyGroupId[spec.proxyGroupId] === undefined) {\n                        byProxyGroupId[spec.proxyGroupId] = [];\n                    }\n                    byProxyGroupId[spec.proxyGroupId].push(id);\n                }\n                data[id].id = id;\n                byUuid[spec.uuid] = id;\n                if (byStatus[status] === undefined) {\n                    byStatus[status] = [];\n                }\n                byStatus[status].push(id);\n                spec.onBeforeStatusChange && spec.onBeforeStatusChange(id);\n                uploaderProxy.onStatusChange(id, null, status);\n                return id;\n            },\n            retrieve: function(optionalFilter) {\n                if (qq.isObject(optionalFilter) && data.length) {\n                    if (optionalFilter.id !== undefined) {\n                        return getDataByIds(optionalFilter.id);\n                    } else if (optionalFilter.uuid !== undefined) {\n                        return getDataByUuids(optionalFilter.uuid);\n                    } else if (optionalFilter.status) {\n                        return getDataByStatus(optionalFilter.status);\n                    }\n                } else {\n                    return qq.extend([], data, true);\n                }\n            },\n            removeFileRef: function(id) {\n                var record = getDataByIds(id);\n                if (record) {\n                    delete record.file;\n                }\n            },\n            reset: function() {\n                data = [];\n                byUuid = {};\n                byStatus = {};\n                byBatchId = {};\n            },\n            setStatus: function(id, newStatus) {\n                var oldStatus = data[id].status, byStatusOldStatusIndex = qq.indexOf(byStatus[oldStatus], id);\n                byStatus[oldStatus].splice(byStatusOldStatusIndex, 1);\n                data[id].status = newStatus;\n                if (byStatus[newStatus] === undefined) {\n                    byStatus[newStatus] = [];\n                }\n                byStatus[newStatus].push(id);\n                uploaderProxy.onStatusChange(id, oldStatus, newStatus);\n            },\n            uuidChanged: function(id, newUuid) {\n                var oldUuid = data[id].uuid;\n                data[id].uuid = newUuid;\n                byUuid[newUuid] = id;\n                delete byUuid[oldUuid];\n            },\n            updateName: function(id, newName) {\n                data[id].name = newName;\n            },\n            updateSize: function(id, newSize) {\n                data[id].size = newSize;\n            },\n            setParentId: function(targetId, parentId) {\n                data[targetId].parentId = parentId;\n            },\n            getIdsInProxyGroup: function(id) {\n                var proxyGroupId = data[id].proxyGroupId;\n                if (proxyGroupId) {\n                    return byProxyGroupId[proxyGroupId];\n                }\n                return [];\n            },\n            getIdsInBatch: function(id) {\n                var batchId = data[id].batchId;\n                return byBatchId[batchId];\n            }\n        });\n    };\n    qq.status = {\n        SUBMITTING: \"submitting\",\n        SUBMITTED: \"submitted\",\n        REJECTED: \"rejected\",\n        QUEUED: \"queued\",\n        CANCELED: \"canceled\",\n        PAUSED: \"paused\",\n        UPLOADING: \"uploading\",\n        UPLOAD_FINALIZING: \"upload finalizing\",\n        UPLOAD_RETRYING: \"retrying upload\",\n        UPLOAD_SUCCESSFUL: \"upload successful\",\n        UPLOAD_FAILED: \"upload failed\",\n        DELETE_FAILED: \"delete failed\",\n        DELETING: \"deleting\",\n        DELETED: \"deleted\"\n    };\n    (function() {\n        \"use strict\";\n        qq.basePublicApi = {\n            addBlobs: function(blobDataOrArray, params, endpoint) {\n                this.addFiles(blobDataOrArray, params, endpoint);\n            },\n            addInitialFiles: function(cannedFileList) {\n                var self = this;\n                qq.each(cannedFileList, function(index, cannedFile) {\n                    self._addCannedFile(cannedFile);\n                });\n            },\n            addFiles: function(data, params, endpoint) {\n                this._maybeHandleIos8SafariWorkaround();\n                var batchId = this._storedIds.length === 0 ? qq.getUniqueId() : this._currentBatchId, processBlob = qq.bind(function(blob) {\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName\n                    }, batchId, verifiedFiles);\n                }, this), processBlobData = qq.bind(function(blobData) {\n                    this._handleNewFile(blobData, batchId, verifiedFiles);\n                }, this), processCanvas = qq.bind(function(canvas) {\n                    var blob = qq.canvasToBlob(canvas);\n                    this._handleNewFile({\n                        blob: blob,\n                        name: this._options.blobs.defaultName + \".png\"\n                    }, batchId, verifiedFiles);\n                }, this), processCanvasData = qq.bind(function(canvasData) {\n                    var normalizedQuality = canvasData.quality && canvasData.quality / 100, blob = qq.canvasToBlob(canvasData.canvas, canvasData.type, normalizedQuality);\n                    this._handleNewFile({\n                        blob: blob,\n                        name: canvasData.name\n                    }, batchId, verifiedFiles);\n                }, this), processFileOrInput = qq.bind(function(fileOrInput) {\n                    if (qq.isInput(fileOrInput) && qq.supportedFeatures.ajaxUploading) {\n                        var files = Array.prototype.slice.call(fileOrInput.files), self = this;\n                        qq.each(files, function(idx, file) {\n                            self._handleNewFile(file, batchId, verifiedFiles);\n                        });\n                    } else {\n                        this._handleNewFile(fileOrInput, batchId, verifiedFiles);\n                    }\n                }, this), normalizeData = function() {\n                    if (qq.isFileList(data)) {\n                        data = Array.prototype.slice.call(data);\n                    }\n                    data = [].concat(data);\n                }, self = this, verifiedFiles = [];\n                this._currentBatchId = batchId;\n                if (data) {\n                    normalizeData();\n                    qq.each(data, function(idx, fileContainer) {\n                        if (qq.isFileOrInput(fileContainer)) {\n                            processFileOrInput(fileContainer);\n                        } else if (qq.isBlob(fileContainer)) {\n                            processBlob(fileContainer);\n                        } else if (qq.isObject(fileContainer)) {\n                            if (fileContainer.blob && fileContainer.name) {\n                                processBlobData(fileContainer);\n                            } else if (fileContainer.canvas && fileContainer.name) {\n                                processCanvasData(fileContainer);\n                            }\n                        } else if (fileContainer.tagName && fileContainer.tagName.toLowerCase() === \"canvas\") {\n                            processCanvas(fileContainer);\n                        } else {\n                            self.log(fileContainer + \" is not a valid file container!  Ignoring!\", \"warn\");\n                        }\n                    });\n                    this.log(\"Received \" + verifiedFiles.length + \" files.\");\n                    this._prepareItemsForUpload(verifiedFiles, params, endpoint);\n                }\n            },\n            cancel: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (uploadData && uploadData.status === qq.status.UPLOAD_FINALIZING) {\n                    this.log(qq.format(\"Ignoring cancel for file ID {} ({}).  Finalizing upload.\", id, this.getName(id)), \"error\");\n                } else {\n                    this._handler.cancel(id);\n                }\n            },\n            cancelAll: function() {\n                var storedIdsCopy = [], self = this;\n                qq.extend(storedIdsCopy, this._storedIds);\n                qq.each(storedIdsCopy, function(idx, storedFileId) {\n                    self.cancel(storedFileId);\n                });\n                this._handler.cancelAll();\n            },\n            clearStoredFiles: function() {\n                this._storedIds = [];\n            },\n            continueUpload: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                    return false;\n                }\n                if (uploadData.status === qq.status.PAUSED) {\n                    this.log(qq.format(\"Paused file ID {} ({}) will be continued.  Not paused.\", id, this.getName(id)));\n                    this._uploadFile(id);\n                    return true;\n                } else {\n                    this.log(qq.format(\"Ignoring continue for file ID {} ({}).  Not paused.\", id, this.getName(id)), \"error\");\n                }\n                return false;\n            },\n            deleteFile: function(id) {\n                return this._onSubmitDelete(id);\n            },\n            doesExist: function(fileOrBlobId) {\n                return this._handler.isValid(fileOrBlobId);\n            },\n            drawThumbnail: function(fileId, imgOrCanvas, maxSize, fromServer, customResizeFunction) {\n                var promiseToReturn = new qq.Promise(), fileOrUrl, options;\n                if (this._imageGenerator) {\n                    fileOrUrl = this._thumbnailUrls[fileId];\n                    options = {\n                        customResizeFunction: customResizeFunction,\n                        maxSize: maxSize > 0 ? maxSize : null,\n                        scale: maxSize > 0\n                    };\n                    if (!fromServer && qq.supportedFeatures.imagePreviews) {\n                        fileOrUrl = this.getFile(fileId);\n                    }\n                    if (fileOrUrl == null) {\n                        promiseToReturn.failure({\n                            container: imgOrCanvas,\n                            error: \"File or URL not found.\"\n                        });\n                    } else {\n                        this._imageGenerator.generate(fileOrUrl, imgOrCanvas, options).then(function success(modifiedContainer) {\n                            promiseToReturn.success(modifiedContainer);\n                        }, function failure(container, reason) {\n                            promiseToReturn.failure({\n                                container: container,\n                                error: reason || \"Problem generating thumbnail\"\n                            });\n                        });\n                    }\n                } else {\n                    promiseToReturn.failure({\n                        container: imgOrCanvas,\n                        error: \"Missing image generator module\"\n                    });\n                }\n                return promiseToReturn;\n            },\n            getButton: function(fileId) {\n                return this._getButton(this._buttonIdsForFileIds[fileId]);\n            },\n            getEndpoint: function(fileId) {\n                return this._endpointStore.get(fileId);\n            },\n            getFile: function(fileOrBlobId) {\n                var file = this._handler.getFile(fileOrBlobId);\n                var uploadDataRecord;\n                if (!file) {\n                    uploadDataRecord = this._uploadData.retrieve({\n                        id: fileOrBlobId\n                    });\n                    if (uploadDataRecord) {\n                        file = uploadDataRecord.file;\n                    }\n                }\n                return file || null;\n            },\n            getInProgress: function() {\n                return this._uploadData.retrieve({\n                    status: [ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED ]\n                }).length;\n            },\n            getName: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).name;\n            },\n            getParentId: function(id) {\n                var uploadDataEntry = this.getUploads({\n                    id: id\n                }), parentId = null;\n                if (uploadDataEntry) {\n                    if (uploadDataEntry.parentId !== undefined) {\n                        parentId = uploadDataEntry.parentId;\n                    }\n                }\n                return parentId;\n            },\n            getResumableFilesData: function() {\n                return this._handler.getResumableFilesData();\n            },\n            getSize: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).size;\n            },\n            getNetUploads: function() {\n                return this._netUploaded;\n            },\n            getRemainingAllowedItems: function() {\n                var allowedItems = this._currentItemLimit;\n                if (allowedItems > 0) {\n                    return allowedItems - this._netUploadedOrQueued;\n                }\n                return null;\n            },\n            getUploads: function(optionalFilter) {\n                return this._uploadData.retrieve(optionalFilter);\n            },\n            getUuid: function(id) {\n                return this._uploadData.retrieve({\n                    id: id\n                }).uuid;\n            },\n            isResumable: function(id) {\n                return this._handler.hasResumeRecord(id);\n            },\n            log: function(str, level) {\n                if (this._options.debug && (!level || level === \"info\")) {\n                    qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str);\n                } else if (level && level !== \"info\") {\n                    qq.log(\"[Fine Uploader \" + qq.version + \"] \" + str, level);\n                }\n            },\n            pauseUpload: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!qq.supportedFeatures.pause || !this._options.chunking.enabled) {\n                    return false;\n                }\n                if (qq.indexOf([ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING ], uploadData.status) >= 0) {\n                    if (this._handler.pause(id)) {\n                        this._uploadData.setStatus(id, qq.status.PAUSED);\n                        return true;\n                    } else {\n                        this.log(qq.format(\"Unable to pause file ID {} ({}).\", id, this.getName(id)), \"error\");\n                    }\n                } else {\n                    this.log(qq.format(\"Ignoring pause for file ID {} ({}).  Not in progress.\", id, this.getName(id)), \"error\");\n                }\n                return false;\n            },\n            removeFileRef: function(id) {\n                this._handler.expunge(id);\n                this._uploadData.removeFileRef(id);\n            },\n            reset: function() {\n                this.log(\"Resetting uploader...\");\n                this._handler.reset();\n                this._storedIds = [];\n                this._autoRetries = [];\n                this._retryTimeouts = [];\n                this._preventRetries = [];\n                this._thumbnailUrls = [];\n                qq.each(this._buttons, function(idx, button) {\n                    button.reset();\n                });\n                this._paramsStore.reset();\n                this._endpointStore.reset();\n                this._netUploadedOrQueued = 0;\n                this._netUploaded = 0;\n                this._uploadData.reset();\n                this._buttonIdsForFileIds = [];\n                this._pasteHandler && this._pasteHandler.reset();\n                this._options.session.refreshOnReset && this._refreshSessionData();\n                this._succeededSinceLastAllComplete = [];\n                this._failedSinceLastAllComplete = [];\n                this._totalProgress && this._totalProgress.reset();\n                this._customResumeDataStore.reset();\n            },\n            retry: function(id) {\n                return this._manualRetry(id);\n            },\n            scaleImage: function(id, specs) {\n                var self = this;\n                return qq.Scaler.prototype.scaleImage(id, specs, {\n                    log: qq.bind(self.log, self),\n                    getFile: qq.bind(self.getFile, self),\n                    uploadData: self._uploadData\n                });\n            },\n            setCustomHeaders: function(headers, id) {\n                this._customHeadersStore.set(headers, id);\n            },\n            setCustomResumeData: function(id, data) {\n                this._customResumeDataStore.set(data, id);\n            },\n            setDeleteFileCustomHeaders: function(headers, id) {\n                this._deleteFileCustomHeadersStore.set(headers, id);\n            },\n            setDeleteFileEndpoint: function(endpoint, id) {\n                this._deleteFileEndpointStore.set(endpoint, id);\n            },\n            setDeleteFileParams: function(params, id) {\n                this._deleteFileParamsStore.set(params, id);\n            },\n            setEndpoint: function(endpoint, id) {\n                this._endpointStore.set(endpoint, id);\n            },\n            setForm: function(elementOrId) {\n                this._updateFormSupportAndParams(elementOrId);\n            },\n            setItemLimit: function(newItemLimit) {\n                this._currentItemLimit = newItemLimit;\n            },\n            setName: function(id, newName) {\n                this._uploadData.updateName(id, newName);\n            },\n            setParams: function(params, id) {\n                this._paramsStore.set(params, id);\n            },\n            setUuid: function(id, newUuid) {\n                return this._uploadData.uuidChanged(id, newUuid);\n            },\n            setStatus: function(id, newStatus) {\n                var fileRecord = this.getUploads({\n                    id: id\n                });\n                if (!fileRecord) {\n                    throw new qq.Error(id + \" is not a valid file ID.\");\n                }\n                switch (newStatus) {\n                  case qq.status.DELETED:\n                    this._onDeleteComplete(id, null, false);\n                    break;\n\n                  case qq.status.DELETE_FAILED:\n                    this._onDeleteComplete(id, null, true);\n                    break;\n\n                  default:\n                    var errorMessage = \"Method setStatus called on '\" + name + \"' not implemented yet for \" + newStatus;\n                    this.log(errorMessage);\n                    throw new qq.Error(errorMessage);\n                }\n            },\n            uploadStoredFiles: function() {\n                if (this._storedIds.length === 0) {\n                    this._itemError(\"noFilesError\");\n                } else {\n                    this._uploadStoredFiles();\n                }\n            }\n        };\n        qq.basePrivateApi = {\n            _addCannedFile: function(sessionData) {\n                var self = this;\n                return this._uploadData.addFile({\n                    uuid: sessionData.uuid,\n                    name: sessionData.name,\n                    size: sessionData.size,\n                    status: qq.status.UPLOAD_SUCCESSFUL,\n                    onBeforeStatusChange: function(id) {\n                        sessionData.deleteFileEndpoint && self.setDeleteFileEndpoint(sessionData.deleteFileEndpoint, id);\n                        sessionData.deleteFileParams && self.setDeleteFileParams(sessionData.deleteFileParams, id);\n                        if (sessionData.thumbnailUrl) {\n                            self._thumbnailUrls[id] = sessionData.thumbnailUrl;\n                        }\n                        self._netUploaded++;\n                        self._netUploadedOrQueued++;\n                    }\n                });\n            },\n            _annotateWithButtonId: function(file, associatedInput) {\n                if (qq.isFile(file)) {\n                    file.qqButtonId = this._getButtonId(associatedInput);\n                }\n            },\n            _batchError: function(message) {\n                this._options.callbacks.onError(null, null, message, undefined);\n            },\n            _createDeleteHandler: function() {\n                var self = this;\n                return new qq.DeleteFileAjaxRequester({\n                    method: this._options.deleteFile.method.toUpperCase(),\n                    maxConnections: this._options.maxConnections,\n                    uuidParamName: this._options.request.uuidName,\n                    customHeaders: this._deleteFileCustomHeadersStore,\n                    paramsStore: this._deleteFileParamsStore,\n                    endpointStore: this._deleteFileEndpointStore,\n                    cors: this._options.cors,\n                    log: qq.bind(self.log, self),\n                    onDelete: function(id) {\n                        self._onDelete(id);\n                        self._options.callbacks.onDelete(id);\n                    },\n                    onDeleteComplete: function(id, xhrOrXdr, isError) {\n                        self._onDeleteComplete(id, xhrOrXdr, isError);\n                        self._options.callbacks.onDeleteComplete(id, xhrOrXdr, isError);\n                    }\n                });\n            },\n            _createPasteHandler: function() {\n                var self = this;\n                return new qq.PasteSupport({\n                    targetElement: this._options.paste.targetElement,\n                    callbacks: {\n                        log: qq.bind(self.log, self),\n                        pasteReceived: function(blob) {\n                            self._handleCheckedCallback({\n                                name: \"onPasteReceived\",\n                                callback: qq.bind(self._options.callbacks.onPasteReceived, self, blob),\n                                onSuccess: qq.bind(self._handlePasteSuccess, self, blob),\n                                identifier: \"pasted image\"\n                            });\n                        }\n                    }\n                });\n            },\n            _createStore: function(initialValue, _readOnlyValues_) {\n                var store = {}, catchall = initialValue, perIdReadOnlyValues = {}, readOnlyValues = _readOnlyValues_, copy = function(orig) {\n                    if (qq.isObject(orig)) {\n                        return qq.extend({}, orig);\n                    }\n                    return orig;\n                }, getReadOnlyValues = function() {\n                    if (qq.isFunction(readOnlyValues)) {\n                        return readOnlyValues();\n                    }\n                    return readOnlyValues;\n                }, includeReadOnlyValues = function(id, existing) {\n                    if (readOnlyValues && qq.isObject(existing)) {\n                        qq.extend(existing, getReadOnlyValues());\n                    }\n                    if (perIdReadOnlyValues[id]) {\n                        qq.extend(existing, perIdReadOnlyValues[id]);\n                    }\n                };\n                return {\n                    set: function(val, id) {\n                        if (id == null) {\n                            store = {};\n                            catchall = copy(val);\n                        } else {\n                            store[id] = copy(val);\n                        }\n                    },\n                    get: function(id) {\n                        var values;\n                        if (id != null && store[id]) {\n                            values = store[id];\n                        } else {\n                            values = copy(catchall);\n                        }\n                        includeReadOnlyValues(id, values);\n                        return copy(values);\n                    },\n                    addReadOnly: function(id, values) {\n                        if (qq.isObject(store)) {\n                            if (id === null) {\n                                if (qq.isFunction(values)) {\n                                    readOnlyValues = values;\n                                } else {\n                                    readOnlyValues = readOnlyValues || {};\n                                    qq.extend(readOnlyValues, values);\n                                }\n                            } else {\n                                perIdReadOnlyValues[id] = perIdReadOnlyValues[id] || {};\n                                qq.extend(perIdReadOnlyValues[id], values);\n                            }\n                        }\n                    },\n                    remove: function(fileId) {\n                        return delete store[fileId];\n                    },\n                    reset: function() {\n                        store = {};\n                        perIdReadOnlyValues = {};\n                        catchall = initialValue;\n                    }\n                };\n            },\n            _createUploadDataTracker: function() {\n                var self = this;\n                return new qq.UploadData({\n                    getName: function(id) {\n                        return self.getName(id);\n                    },\n                    getUuid: function(id) {\n                        return self.getUuid(id);\n                    },\n                    getSize: function(id) {\n                        return self.getSize(id);\n                    },\n                    onStatusChange: function(id, oldStatus, newStatus) {\n                        self._onUploadStatusChange(id, oldStatus, newStatus);\n                        self._options.callbacks.onStatusChange(id, oldStatus, newStatus);\n                        self._maybeAllComplete(id, newStatus);\n                        if (self._totalProgress) {\n                            setTimeout(function() {\n                                self._totalProgress.onStatusChange(id, oldStatus, newStatus);\n                            }, 0);\n                        }\n                    }\n                });\n            },\n            _createUploadButton: function(spec) {\n                var self = this, acceptFiles = spec.accept || this._options.validation.acceptFiles, allowedExtensions = spec.allowedExtensions || this._options.validation.allowedExtensions, button;\n                function allowMultiple() {\n                    if (qq.supportedFeatures.ajaxUploading) {\n                        if (self._options.workarounds.iosEmptyVideos && qq.ios() && !qq.ios6() && self._isAllowedExtension(allowedExtensions, \".mov\")) {\n                            return false;\n                        }\n                        if (spec.multiple === undefined) {\n                            return self._options.multiple;\n                        }\n                        return spec.multiple;\n                    }\n                    return false;\n                }\n                button = new qq.UploadButton({\n                    acceptFiles: acceptFiles,\n                    element: spec.element,\n                    focusClass: this._options.classes.buttonFocus,\n                    folders: spec.folders,\n                    hoverClass: this._options.classes.buttonHover,\n                    ios8BrowserCrashWorkaround: this._options.workarounds.ios8BrowserCrash,\n                    multiple: allowMultiple(),\n                    name: this._options.request.inputName,\n                    onChange: function(input) {\n                        self._onInputChange(input);\n                    },\n                    title: spec.title == null ? this._options.text.fileInputTitle : spec.title\n                });\n                this._disposeSupport.addDisposer(function() {\n                    button.dispose();\n                });\n                self._buttons.push(button);\n                return button;\n            },\n            _createUploadHandler: function(additionalOptions, namespace) {\n                var self = this, lastOnProgress = {}, options = {\n                    debug: this._options.debug,\n                    maxConnections: this._options.maxConnections,\n                    cors: this._options.cors,\n                    paramsStore: this._paramsStore,\n                    endpointStore: this._endpointStore,\n                    chunking: this._options.chunking,\n                    resume: this._options.resume,\n                    blobs: this._options.blobs,\n                    log: qq.bind(self.log, self),\n                    preventRetryParam: this._options.retry.preventRetryResponseProperty,\n                    onProgress: function(id, name, loaded, total) {\n                        if (loaded < 0 || total < 0) {\n                            return;\n                        }\n                        if (lastOnProgress[id]) {\n                            if (lastOnProgress[id].loaded !== loaded || lastOnProgress[id].total !== total) {\n                                self._onProgress(id, name, loaded, total);\n                                self._options.callbacks.onProgress(id, name, loaded, total);\n                            }\n                        } else {\n                            self._onProgress(id, name, loaded, total);\n                            self._options.callbacks.onProgress(id, name, loaded, total);\n                        }\n                        lastOnProgress[id] = {\n                            loaded: loaded,\n                            total: total\n                        };\n                    },\n                    onComplete: function(id, name, result, xhr) {\n                        delete lastOnProgress[id];\n                        var status = self.getUploads({\n                            id: id\n                        }).status, retVal;\n                        if (status === qq.status.UPLOAD_SUCCESSFUL || status === qq.status.UPLOAD_FAILED) {\n                            return;\n                        }\n                        retVal = self._onComplete(id, name, result, xhr);\n                        if (retVal instanceof qq.Promise) {\n                            retVal.done(function() {\n                                self._options.callbacks.onComplete(id, name, result, xhr);\n                            });\n                        } else {\n                            self._options.callbacks.onComplete(id, name, result, xhr);\n                        }\n                    },\n                    onCancel: function(id, name, cancelFinalizationEffort) {\n                        var promise = new qq.Promise();\n                        self._handleCheckedCallback({\n                            name: \"onCancel\",\n                            callback: qq.bind(self._options.callbacks.onCancel, self, id, name),\n                            onFailure: promise.failure,\n                            onSuccess: function() {\n                                cancelFinalizationEffort.then(function() {\n                                    self._onCancel(id, name);\n                                });\n                                promise.success();\n                            },\n                            identifier: id\n                        });\n                        return promise;\n                    },\n                    onUploadPrep: qq.bind(this._onUploadPrep, this),\n                    onUpload: function(id, name) {\n                        self._onUpload(id, name);\n                        var onUploadResult = self._options.callbacks.onUpload(id, name);\n                        if (qq.isGenericPromise(onUploadResult)) {\n                            self.log(qq.format(\"onUpload for {} returned a Promise - waiting for resolution.\", id));\n                            return onUploadResult;\n                        }\n                        return new qq.Promise().success();\n                    },\n                    onUploadChunk: function(id, name, chunkData) {\n                        self._onUploadChunk(id, chunkData);\n                        var onUploadChunkResult = self._options.callbacks.onUploadChunk(id, name, chunkData);\n                        if (qq.isGenericPromise(onUploadChunkResult)) {\n                            self.log(qq.format(\"onUploadChunk for {}.{} returned a Promise - waiting for resolution.\", id, chunkData.partIndex));\n                            return onUploadChunkResult;\n                        }\n                        return new qq.Promise().success();\n                    },\n                    onUploadChunkSuccess: function(id, chunkData, result, xhr) {\n                        self._onUploadChunkSuccess(id, chunkData);\n                        self._options.callbacks.onUploadChunkSuccess.apply(self, arguments);\n                    },\n                    onResume: function(id, name, chunkData, customResumeData) {\n                        return self._options.callbacks.onResume(id, name, chunkData, customResumeData);\n                    },\n                    onAutoRetry: function(id, name, responseJSON, xhr) {\n                        return self._onAutoRetry.apply(self, arguments);\n                    },\n                    onUuidChanged: function(id, newUuid) {\n                        self.log(\"Server requested UUID change from '\" + self.getUuid(id) + \"' to '\" + newUuid + \"'\");\n                        self.setUuid(id, newUuid);\n                    },\n                    getName: qq.bind(self.getName, self),\n                    getUuid: qq.bind(self.getUuid, self),\n                    getSize: qq.bind(self.getSize, self),\n                    setSize: qq.bind(self._setSize, self),\n                    getDataByUuid: function(uuid) {\n                        return self.getUploads({\n                            uuid: uuid\n                        });\n                    },\n                    isQueued: function(id) {\n                        var status = self.getUploads({\n                            id: id\n                        }).status;\n                        return status === qq.status.QUEUED || status === qq.status.SUBMITTED || status === qq.status.UPLOAD_RETRYING || status === qq.status.PAUSED;\n                    },\n                    getIdsInProxyGroup: self._uploadData.getIdsInProxyGroup,\n                    getIdsInBatch: self._uploadData.getIdsInBatch,\n                    isInProgress: function(id) {\n                        return self.getUploads({\n                            id: id\n                        }).status === qq.status.UPLOADING;\n                    },\n                    getCustomResumeData: qq.bind(self._getCustomResumeData, self),\n                    setStatus: function(id, status) {\n                        self._uploadData.setStatus(id, status);\n                    }\n                };\n                qq.each(this._options.request, function(prop, val) {\n                    options[prop] = val;\n                });\n                options.customHeaders = this._customHeadersStore;\n                if (additionalOptions) {\n                    qq.each(additionalOptions, function(key, val) {\n                        options[key] = val;\n                    });\n                }\n                return new qq.UploadHandlerController(options, namespace);\n            },\n            _fileOrBlobRejected: function(id) {\n                this._netUploadedOrQueued--;\n                this._uploadData.setStatus(id, qq.status.REJECTED);\n            },\n            _formatSize: function(bytes) {\n                if (bytes === 0) {\n                    return bytes + this._options.text.sizeSymbols[0];\n                }\n                var i = -1;\n                do {\n                    bytes = bytes / 1e3;\n                    i++;\n                } while (bytes > 999);\n                return Math.max(bytes, .1).toFixed(1) + this._options.text.sizeSymbols[i];\n            },\n            _generateExtraButtonSpecs: function() {\n                var self = this;\n                this._extraButtonSpecs = {};\n                qq.each(this._options.extraButtons, function(idx, extraButtonOptionEntry) {\n                    var multiple = extraButtonOptionEntry.multiple, validation = qq.extend({}, self._options.validation, true), extraButtonSpec = qq.extend({}, extraButtonOptionEntry);\n                    if (multiple === undefined) {\n                        multiple = self._options.multiple;\n                    }\n                    if (extraButtonSpec.validation) {\n                        qq.extend(validation, extraButtonOptionEntry.validation, true);\n                    }\n                    qq.extend(extraButtonSpec, {\n                        multiple: multiple,\n                        validation: validation\n                    }, true);\n                    self._initExtraButton(extraButtonSpec);\n                });\n            },\n            _getButton: function(buttonId) {\n                var extraButtonsSpec = this._extraButtonSpecs[buttonId];\n                if (extraButtonsSpec) {\n                    return extraButtonsSpec.element;\n                } else if (buttonId === this._defaultButtonId) {\n                    return this._options.button;\n                }\n            },\n            _getButtonId: function(buttonOrFileInputOrFile) {\n                var inputs, fileInput, fileBlobOrInput = buttonOrFileInputOrFile;\n                if (fileBlobOrInput instanceof qq.BlobProxy) {\n                    fileBlobOrInput = fileBlobOrInput.referenceBlob;\n                }\n                if (fileBlobOrInput && !qq.isBlob(fileBlobOrInput)) {\n                    if (qq.isFile(fileBlobOrInput)) {\n                        return fileBlobOrInput.qqButtonId;\n                    } else if (fileBlobOrInput.tagName.toLowerCase() === \"input\" && fileBlobOrInput.type.toLowerCase() === \"file\") {\n                        return fileBlobOrInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                    }\n                    inputs = fileBlobOrInput.getElementsByTagName(\"input\");\n                    qq.each(inputs, function(idx, input) {\n                        if (input.getAttribute(\"type\") === \"file\") {\n                            fileInput = input;\n                            return false;\n                        }\n                    });\n                    if (fileInput) {\n                        return fileInput.getAttribute(qq.UploadButton.BUTTON_ID_ATTR_NAME);\n                    }\n                }\n            },\n            _getCustomResumeData: function(fileId) {\n                return this._customResumeDataStore.get(fileId);\n            },\n            _getNotFinished: function() {\n                return this._uploadData.retrieve({\n                    status: [ qq.status.UPLOADING, qq.status.UPLOAD_RETRYING, qq.status.QUEUED, qq.status.SUBMITTING, qq.status.SUBMITTED, qq.status.PAUSED ]\n                }).length;\n            },\n            _getValidationBase: function(buttonId) {\n                var extraButtonSpec = this._extraButtonSpecs[buttonId];\n                return extraButtonSpec ? extraButtonSpec.validation : this._options.validation;\n            },\n            _getValidationDescriptor: function(fileWrapper) {\n                if (fileWrapper.file instanceof qq.BlobProxy) {\n                    return {\n                        name: qq.getFilename(fileWrapper.file.referenceBlob),\n                        size: fileWrapper.file.referenceBlob.size\n                    };\n                }\n                return {\n                    name: this.getUploads({\n                        id: fileWrapper.id\n                    }).name,\n                    size: this.getUploads({\n                        id: fileWrapper.id\n                    }).size\n                };\n            },\n            _getValidationDescriptors: function(fileWrappers) {\n                var self = this, fileDescriptors = [];\n                qq.each(fileWrappers, function(idx, fileWrapper) {\n                    fileDescriptors.push(self._getValidationDescriptor(fileWrapper));\n                });\n                return fileDescriptors;\n            },\n            _handleCameraAccess: function() {\n                if (this._options.camera.ios && qq.ios()) {\n                    var acceptIosCamera = \"image/*;capture=camera\", button = this._options.camera.button, buttonId = button ? this._getButtonId(button) : this._defaultButtonId, optionRoot = this._options;\n                    if (buttonId && buttonId !== this._defaultButtonId) {\n                        optionRoot = this._extraButtonSpecs[buttonId];\n                    }\n                    optionRoot.multiple = false;\n                    if (optionRoot.validation.acceptFiles === null) {\n                        optionRoot.validation.acceptFiles = acceptIosCamera;\n                    } else {\n                        optionRoot.validation.acceptFiles += \",\" + acceptIosCamera;\n                    }\n                    qq.each(this._buttons, function(idx, button) {\n                        if (button.getButtonId() === buttonId) {\n                            button.setMultiple(optionRoot.multiple);\n                            button.setAcceptFiles(optionRoot.acceptFiles);\n                            return false;\n                        }\n                    });\n                }\n            },\n            _handleCheckedCallback: function(details) {\n                var self = this, callbackRetVal = details.callback();\n                if (qq.isGenericPromise(callbackRetVal)) {\n                    this.log(details.name + \" - waiting for \" + details.name + \" promise to be fulfilled for \" + details.identifier);\n                    return callbackRetVal.then(function(successParam) {\n                        self.log(details.name + \" promise success for \" + details.identifier);\n                        details.onSuccess(successParam);\n                    }, function() {\n                        if (details.onFailure) {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                            details.onFailure();\n                        } else {\n                            self.log(details.name + \" promise failure for \" + details.identifier);\n                        }\n                    });\n                }\n                if (callbackRetVal !== false) {\n                    details.onSuccess(callbackRetVal);\n                } else {\n                    if (details.onFailure) {\n                        this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Invoking failure callback.\");\n                        details.onFailure();\n                    } else {\n                        this.log(details.name + \" - return value was 'false' for \" + details.identifier + \".  Will not proceed.\");\n                    }\n                }\n                return callbackRetVal;\n            },\n            _handleNewFile: function(file, batchId, newFileWrapperList) {\n                var self = this, uuid = qq.getUniqueId(), size = -1, name = qq.getFilename(file), actualFile = file.blob || file, handler = this._customNewFileHandler ? this._customNewFileHandler : qq.bind(self._handleNewFileGeneric, self);\n                if (!qq.isInput(actualFile) && actualFile.size >= 0) {\n                    size = actualFile.size;\n                }\n                handler(actualFile, name, uuid, size, newFileWrapperList, batchId, this._options.request.uuidName, {\n                    uploadData: self._uploadData,\n                    paramsStore: self._paramsStore,\n                    addFileToHandler: function(id, file) {\n                        self._handler.add(id, file);\n                        self._netUploadedOrQueued++;\n                        self._trackButton(id);\n                    }\n                });\n            },\n            _handleNewFileGeneric: function(file, name, uuid, size, fileList, batchId) {\n                var id = this._uploadData.addFile({\n                    uuid: uuid,\n                    name: name,\n                    size: size,\n                    batchId: batchId,\n                    file: file\n                });\n                this._handler.add(id, file);\n                this._trackButton(id);\n                this._netUploadedOrQueued++;\n                fileList.push({\n                    id: id,\n                    file: file\n                });\n            },\n            _handlePasteSuccess: function(blob, extSuppliedName) {\n                var extension = blob.type.split(\"/\")[1], name = extSuppliedName;\n                if (name == null) {\n                    name = this._options.paste.defaultName;\n                }\n                name += \".\" + extension;\n                this.addFiles({\n                    name: name,\n                    blob: blob\n                });\n            },\n            _handleDeleteSuccess: function(id) {\n                if (this.getUploads({\n                    id: id\n                }).status !== qq.status.DELETED) {\n                    var name = this.getName(id);\n                    this._netUploadedOrQueued--;\n                    this._netUploaded--;\n                    this._handler.expunge(id);\n                    this._uploadData.setStatus(id, qq.status.DELETED);\n                    this.log(\"Delete request for '\" + name + \"' has succeeded.\");\n                }\n            },\n            _handleDeleteFailed: function(id, xhrOrXdr) {\n                var name = this.getName(id);\n                this._uploadData.setStatus(id, qq.status.DELETE_FAILED);\n                this.log(\"Delete request for '\" + name + \"' has failed.\", \"error\");\n                if (!xhrOrXdr || xhrOrXdr.withCredentials === undefined) {\n                    this._options.callbacks.onError(id, name, \"Delete request failed\", xhrOrXdr);\n                } else {\n                    this._options.callbacks.onError(id, name, \"Delete request failed with response code \" + xhrOrXdr.status, xhrOrXdr);\n                }\n            },\n            _initExtraButton: function(spec) {\n                var button = this._createUploadButton({\n                    accept: spec.validation.acceptFiles,\n                    allowedExtensions: spec.validation.allowedExtensions,\n                    element: spec.element,\n                    folders: spec.folders,\n                    multiple: spec.multiple,\n                    title: spec.fileInputTitle\n                });\n                this._extraButtonSpecs[button.getButtonId()] = spec;\n            },\n            _initFormSupportAndParams: function() {\n                this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n                if (this._formSupport && this._formSupport.attachedToForm) {\n                    this._paramsStore = this._createStore(this._options.request.params, this._formSupport.getFormInputsAsObject);\n                    this._options.autoUpload = this._formSupport.newAutoUpload;\n                    if (this._formSupport.newEndpoint) {\n                        this._options.request.endpoint = this._formSupport.newEndpoint;\n                    }\n                } else {\n                    this._paramsStore = this._createStore(this._options.request.params);\n                }\n            },\n            _isDeletePossible: function() {\n                if (!qq.DeleteFileAjaxRequester || !this._options.deleteFile.enabled) {\n                    return false;\n                }\n                if (this._options.cors.expected) {\n                    if (qq.supportedFeatures.deleteFileCorsXhr) {\n                        return true;\n                    }\n                    if (qq.supportedFeatures.deleteFileCorsXdr && this._options.cors.allowXdr) {\n                        return true;\n                    }\n                    return false;\n                }\n                return true;\n            },\n            _isAllowedExtension: function(allowed, fileName) {\n                var valid = false;\n                if (!allowed.length) {\n                    return true;\n                }\n                qq.each(allowed, function(idx, allowedExt) {\n                    if (qq.isString(allowedExt)) {\n                        var extRegex = new RegExp(\"\\\\.\" + allowedExt + \"$\", \"i\");\n                        if (fileName.match(extRegex) != null) {\n                            valid = true;\n                            return false;\n                        }\n                    }\n                });\n                return valid;\n            },\n            _itemError: function(code, maybeNameOrNames, item) {\n                var message = this._options.messages[code], allowedExtensions = [], names = [].concat(maybeNameOrNames), name = names[0], buttonId = this._getButtonId(item), validationBase = this._getValidationBase(buttonId), extensionsForMessage, placeholderMatch;\n                function r(name, replacement) {\n                    message = message.replace(name, replacement);\n                }\n                qq.each(validationBase.allowedExtensions, function(idx, allowedExtension) {\n                    if (qq.isString(allowedExtension)) {\n                        allowedExtensions.push(allowedExtension);\n                    }\n                });\n                extensionsForMessage = allowedExtensions.join(\", \").toLowerCase();\n                r(\"{file}\", this._options.formatFileName(name));\n                r(\"{extensions}\", extensionsForMessage);\n                r(\"{sizeLimit}\", this._formatSize(validationBase.sizeLimit));\n                r(\"{minSizeLimit}\", this._formatSize(validationBase.minSizeLimit));\n                placeholderMatch = message.match(/(\\{\\w+\\})/g);\n                if (placeholderMatch !== null) {\n                    qq.each(placeholderMatch, function(idx, placeholder) {\n                        r(placeholder, names[idx]);\n                    });\n                }\n                this._options.callbacks.onError(null, name, message, undefined);\n                return message;\n            },\n            _manualRetry: function(id, callback) {\n                if (this._onBeforeManualRetry(id)) {\n                    this._netUploadedOrQueued++;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n                    if (callback) {\n                        callback(id);\n                    } else {\n                        this._handler.retry(id);\n                    }\n                    return true;\n                }\n            },\n            _maybeAllComplete: function(id, status) {\n                var self = this, notFinished = this._getNotFinished();\n                if (status === qq.status.UPLOAD_SUCCESSFUL) {\n                    this._succeededSinceLastAllComplete.push(id);\n                } else if (status === qq.status.UPLOAD_FAILED) {\n                    this._failedSinceLastAllComplete.push(id);\n                }\n                if (notFinished === 0 && (this._succeededSinceLastAllComplete.length || this._failedSinceLastAllComplete.length)) {\n                    setTimeout(function() {\n                        self._onAllComplete(self._succeededSinceLastAllComplete, self._failedSinceLastAllComplete);\n                    }, 0);\n                }\n            },\n            _maybeHandleIos8SafariWorkaround: function() {\n                var self = this;\n                if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n                    setTimeout(function() {\n                        window.alert(self._options.messages.unsupportedBrowserIos8Safari);\n                    }, 0);\n                    throw new qq.Error(this._options.messages.unsupportedBrowserIos8Safari);\n                }\n            },\n            _maybeParseAndSendUploadError: function(id, name, response, xhr) {\n                if (!response.success) {\n                    if (xhr && xhr.status !== 200 && !response.error) {\n                        this._options.callbacks.onError(id, name, \"XHR returned response code \" + xhr.status, xhr);\n                    } else {\n                        var errorReason = response.error ? response.error : this._options.text.defaultResponseError;\n                        this._options.callbacks.onError(id, name, errorReason, xhr);\n                    }\n                }\n            },\n            _maybeProcessNextItemAfterOnValidateCallback: function(validItem, items, index, params, endpoint) {\n                var self = this;\n                if (items.length > index) {\n                    if (validItem || !this._options.validation.stopOnFirstInvalidFile) {\n                        setTimeout(function() {\n                            var validationDescriptor = self._getValidationDescriptor(items[index]), buttonId = self._getButtonId(items[index].file), button = self._getButton(buttonId);\n                            self._handleCheckedCallback({\n                                name: \"onValidate\",\n                                callback: qq.bind(self._options.callbacks.onValidate, self, validationDescriptor, button),\n                                onSuccess: qq.bind(self._onValidateCallbackSuccess, self, items, index, params, endpoint),\n                                onFailure: qq.bind(self._onValidateCallbackFailure, self, items, index, params, endpoint),\n                                identifier: \"Item '\" + validationDescriptor.name + \"', size: \" + validationDescriptor.size\n                            });\n                        }, 0);\n                    } else if (!validItem) {\n                        for (;index < items.length; index++) {\n                            self._fileOrBlobRejected(items[index].id);\n                        }\n                    }\n                }\n            },\n            _onAllComplete: function(successful, failed) {\n                this._totalProgress && this._totalProgress.onAllComplete(successful, failed, this._preventRetries);\n                this._options.callbacks.onAllComplete(qq.extend([], successful), qq.extend([], failed));\n                this._succeededSinceLastAllComplete = [];\n                this._failedSinceLastAllComplete = [];\n            },\n            _onAutoRetry: function(id, name, responseJSON, xhr, callback) {\n                var self = this;\n                self._preventRetries[id] = responseJSON[self._options.retry.preventRetryResponseProperty];\n                if (self._shouldAutoRetry(id)) {\n                    var retryWaitPeriod = self._options.retry.autoAttemptDelay * 1e3;\n                    self._maybeParseAndSendUploadError.apply(self, arguments);\n                    self._options.callbacks.onAutoRetry(id, name, self._autoRetries[id]);\n                    self._onBeforeAutoRetry(id, name);\n                    self._uploadData.setStatus(id, qq.status.UPLOAD_RETRYING);\n                    self._retryTimeouts[id] = setTimeout(function() {\n                        self.log(\"Starting retry for \" + name + \"...\");\n                        if (callback) {\n                            callback(id);\n                        } else {\n                            self._handler.retry(id);\n                        }\n                    }, retryWaitPeriod);\n                    return true;\n                }\n            },\n            _onBeforeAutoRetry: function(id, name) {\n                this.log(\"Waiting \" + this._options.retry.autoAttemptDelay + \" seconds before retrying \" + name + \"...\");\n            },\n            _onBeforeManualRetry: function(id) {\n                var itemLimit = this._currentItemLimit, fileName;\n                if (this._preventRetries[id]) {\n                    this.log(\"Retries are forbidden for id \" + id, \"warn\");\n                    return false;\n                } else if (this._handler.isValid(id)) {\n                    fileName = this.getName(id);\n                    if (this._options.callbacks.onManualRetry(id, fileName) === false) {\n                        return false;\n                    }\n                    if (itemLimit > 0 && this._netUploadedOrQueued + 1 > itemLimit) {\n                        this._itemError(\"retryFailTooManyItems\");\n                        return false;\n                    }\n                    this.log(\"Retrying upload for '\" + fileName + \"' (id: \" + id + \")...\");\n                    return true;\n                } else {\n                    this.log(\"'\" + id + \"' is not a valid file ID\", \"error\");\n                    return false;\n                }\n            },\n            _onCancel: function(id, name) {\n                this._netUploadedOrQueued--;\n                clearTimeout(this._retryTimeouts[id]);\n                var storedItemIndex = qq.indexOf(this._storedIds, id);\n                if (!this._options.autoUpload && storedItemIndex >= 0) {\n                    this._storedIds.splice(storedItemIndex, 1);\n                }\n                this._uploadData.setStatus(id, qq.status.CANCELED);\n            },\n            _onComplete: function(id, name, result, xhr) {\n                if (!result.success) {\n                    this._netUploadedOrQueued--;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_FAILED);\n                    if (result[this._options.retry.preventRetryResponseProperty] === true) {\n                        this._preventRetries[id] = true;\n                    }\n                } else {\n                    if (result.thumbnailUrl) {\n                        this._thumbnailUrls[id] = result.thumbnailUrl;\n                    }\n                    this._netUploaded++;\n                    this._uploadData.setStatus(id, qq.status.UPLOAD_SUCCESSFUL);\n                }\n                this._maybeParseAndSendUploadError(id, name, result, xhr);\n                return result.success ? true : false;\n            },\n            _onDelete: function(id) {\n                this._uploadData.setStatus(id, qq.status.DELETING);\n            },\n            _onDeleteComplete: function(id, xhrOrXdr, isError) {\n                var name = this.getName(id);\n                if (isError) {\n                    this._handleDeleteFailed(id, xhrOrXdr);\n                } else {\n                    this._handleDeleteSuccess(id);\n                }\n            },\n            _onInputChange: function(input) {\n                var fileIndex;\n                if (qq.supportedFeatures.ajaxUploading) {\n                    for (fileIndex = 0; fileIndex < input.files.length; fileIndex++) {\n                        this._annotateWithButtonId(input.files[fileIndex], input);\n                    }\n                    this.addFiles(input.files);\n                } else if (input.value.length > 0) {\n                    this.addFiles(input);\n                }\n                qq.each(this._buttons, function(idx, button) {\n                    button.reset();\n                });\n            },\n            _onProgress: function(id, name, loaded, total) {\n                this._totalProgress && this._totalProgress.onIndividualProgress(id, loaded, total);\n            },\n            _onSubmit: function(id, name) {},\n            _onSubmitCallbackSuccess: function(id, name) {\n                this._onSubmit.apply(this, arguments);\n                this._uploadData.setStatus(id, qq.status.SUBMITTED);\n                this._onSubmitted.apply(this, arguments);\n                if (this._options.autoUpload) {\n                    this._options.callbacks.onSubmitted.apply(this, arguments);\n                    this._uploadFile(id);\n                } else {\n                    this._storeForLater(id);\n                    this._options.callbacks.onSubmitted.apply(this, arguments);\n                }\n            },\n            _onSubmitDelete: function(id, onSuccessCallback, additionalMandatedParams) {\n                var uuid = this.getUuid(id), adjustedOnSuccessCallback;\n                if (onSuccessCallback) {\n                    adjustedOnSuccessCallback = qq.bind(onSuccessCallback, this, id, uuid, additionalMandatedParams);\n                }\n                if (this._isDeletePossible()) {\n                    this._handleCheckedCallback({\n                        name: \"onSubmitDelete\",\n                        callback: qq.bind(this._options.callbacks.onSubmitDelete, this, id),\n                        onSuccess: adjustedOnSuccessCallback || qq.bind(this._deleteHandler.sendDelete, this, id, uuid, additionalMandatedParams),\n                        identifier: id\n                    });\n                    return true;\n                } else {\n                    this.log(\"Delete request ignored for ID \" + id + \", delete feature is disabled or request not possible \" + \"due to CORS on a user agent that does not support pre-flighting.\", \"warn\");\n                    return false;\n                }\n            },\n            _onSubmitted: function(id) {},\n            _onTotalProgress: function(loaded, total) {\n                this._options.callbacks.onTotalProgress(loaded, total);\n            },\n            _onUploadPrep: function(id) {},\n            _onUpload: function(id, name) {\n                this._uploadData.setStatus(id, qq.status.UPLOADING);\n            },\n            _onUploadChunk: function(id, chunkData) {},\n            _onUploadChunkSuccess: function(id, chunkData) {\n                if (!this._preventRetries[id] && this._options.retry.enableAuto) {\n                    this._autoRetries[id] = 0;\n                }\n            },\n            _onUploadStatusChange: function(id, oldStatus, newStatus) {\n                if (newStatus === qq.status.PAUSED) {\n                    clearTimeout(this._retryTimeouts[id]);\n                }\n            },\n            _onValidateBatchCallbackFailure: function(fileWrappers) {\n                var self = this;\n                qq.each(fileWrappers, function(idx, fileWrapper) {\n                    self._fileOrBlobRejected(fileWrapper.id);\n                });\n            },\n            _onValidateBatchCallbackSuccess: function(validationDescriptors, items, params, endpoint, button) {\n                var errorMessage, itemLimit = this._currentItemLimit, proposedNetFilesUploadedOrQueued = this._netUploadedOrQueued;\n                if (itemLimit === 0 || proposedNetFilesUploadedOrQueued <= itemLimit) {\n                    if (items.length > 0) {\n                        this._handleCheckedCallback({\n                            name: \"onValidate\",\n                            callback: qq.bind(this._options.callbacks.onValidate, this, validationDescriptors[0], button),\n                            onSuccess: qq.bind(this._onValidateCallbackSuccess, this, items, 0, params, endpoint),\n                            onFailure: qq.bind(this._onValidateCallbackFailure, this, items, 0, params, endpoint),\n                            identifier: \"Item '\" + items[0].file.name + \"', size: \" + items[0].file.size\n                        });\n                    } else {\n                        this._itemError(\"noFilesError\");\n                    }\n                } else {\n                    this._onValidateBatchCallbackFailure(items);\n                    errorMessage = this._options.messages.tooManyItemsError.replace(/\\{netItems\\}/g, proposedNetFilesUploadedOrQueued).replace(/\\{itemLimit\\}/g, itemLimit);\n                    this._batchError(errorMessage);\n                }\n            },\n            _onValidateCallbackFailure: function(items, index, params, endpoint) {\n                var nextIndex = index + 1;\n                this._fileOrBlobRejected(items[index].id, items[index].file.name);\n                this._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n            },\n            _onValidateCallbackSuccess: function(items, index, params, endpoint) {\n                var self = this, nextIndex = index + 1, validationDescriptor = this._getValidationDescriptor(items[index]);\n                this._validateFileOrBlobData(items[index], validationDescriptor).then(function() {\n                    self._upload(items[index].id, params, endpoint);\n                    self._maybeProcessNextItemAfterOnValidateCallback(true, items, nextIndex, params, endpoint);\n                }, function() {\n                    self._maybeProcessNextItemAfterOnValidateCallback(false, items, nextIndex, params, endpoint);\n                });\n            },\n            _prepareItemsForUpload: function(items, params, endpoint) {\n                if (items.length === 0) {\n                    this._itemError(\"noFilesError\");\n                    return;\n                }\n                var validationDescriptors = this._getValidationDescriptors(items), buttonId = this._getButtonId(items[0].file), button = this._getButton(buttonId);\n                this._handleCheckedCallback({\n                    name: \"onValidateBatch\",\n                    callback: qq.bind(this._options.callbacks.onValidateBatch, this, validationDescriptors, button),\n                    onSuccess: qq.bind(this._onValidateBatchCallbackSuccess, this, validationDescriptors, items, params, endpoint, button),\n                    onFailure: qq.bind(this._onValidateBatchCallbackFailure, this, items),\n                    identifier: \"batch validation\"\n                });\n            },\n            _preventLeaveInProgress: function() {\n                var self = this;\n                this._disposeSupport.attach(window, \"beforeunload\", function(e) {\n                    if (self.getInProgress()) {\n                        e = e || window.event;\n                        e.returnValue = self._options.messages.onLeave;\n                        return self._options.messages.onLeave;\n                    }\n                });\n            },\n            _refreshSessionData: function() {\n                var self = this, options = this._options.session;\n                if (qq.Session && this._options.session.endpoint != null) {\n                    if (!this._session) {\n                        qq.extend(options, {\n                            cors: this._options.cors\n                        });\n                        options.log = qq.bind(this.log, this);\n                        options.addFileRecord = qq.bind(this._addCannedFile, this);\n                        this._session = new qq.Session(options);\n                    }\n                    setTimeout(function() {\n                        self._session.refresh().then(function(response, xhrOrXdr) {\n                            self._sessionRequestComplete();\n                            self._options.callbacks.onSessionRequestComplete(response, true, xhrOrXdr);\n                        }, function(response, xhrOrXdr) {\n                            self._options.callbacks.onSessionRequestComplete(response, false, xhrOrXdr);\n                        });\n                    }, 0);\n                }\n            },\n            _sessionRequestComplete: function() {},\n            _setSize: function(id, newSize) {\n                this._uploadData.updateSize(id, newSize);\n                this._totalProgress && this._totalProgress.onNewSize(id);\n            },\n            _shouldAutoRetry: function(id) {\n                var uploadData = this._uploadData.retrieve({\n                    id: id\n                });\n                if (!this._preventRetries[id] && this._options.retry.enableAuto && uploadData.status !== qq.status.PAUSED) {\n                    if (this._autoRetries[id] === undefined) {\n                        this._autoRetries[id] = 0;\n                    }\n                    if (this._autoRetries[id] < this._options.retry.maxAutoAttempts) {\n                        this._autoRetries[id] += 1;\n                        return true;\n                    }\n                }\n                return false;\n            },\n            _storeForLater: function(id) {\n                this._storedIds.push(id);\n            },\n            _trackButton: function(id) {\n                var buttonId;\n                if (qq.supportedFeatures.ajaxUploading) {\n                    buttonId = this._handler.getFile(id).qqButtonId;\n                } else {\n                    buttonId = this._getButtonId(this._handler.getInput(id));\n                }\n                if (buttonId) {\n                    this._buttonIdsForFileIds[id] = buttonId;\n                }\n            },\n            _updateFormSupportAndParams: function(formElementOrId) {\n                this._options.form.element = formElementOrId;\n                this._formSupport = qq.FormSupport && new qq.FormSupport(this._options.form, qq.bind(this.uploadStoredFiles, this), qq.bind(this.log, this));\n                if (this._formSupport && this._formSupport.attachedToForm) {\n                    this._paramsStore.addReadOnly(null, this._formSupport.getFormInputsAsObject);\n                    this._options.autoUpload = this._formSupport.newAutoUpload;\n                    if (this._formSupport.newEndpoint) {\n                        this.setEndpoint(this._formSupport.newEndpoint);\n                    }\n                }\n            },\n            _upload: function(id, params, endpoint) {\n                var name = this.getName(id);\n                if (params) {\n                    this.setParams(params, id);\n                }\n                if (endpoint) {\n                    this.setEndpoint(endpoint, id);\n                }\n                this._handleCheckedCallback({\n                    name: \"onSubmit\",\n                    callback: qq.bind(this._options.callbacks.onSubmit, this, id, name),\n                    onSuccess: qq.bind(this._onSubmitCallbackSuccess, this, id, name),\n                    onFailure: qq.bind(this._fileOrBlobRejected, this, id, name),\n                    identifier: id\n                });\n            },\n            _uploadFile: function(id) {\n                if (!this._handler.upload(id)) {\n                    this._uploadData.setStatus(id, qq.status.QUEUED);\n                }\n            },\n            _uploadStoredFiles: function() {\n                var idToUpload, stillSubmitting, self = this;\n                while (this._storedIds.length) {\n                    idToUpload = this._storedIds.shift();\n                    this._uploadFile(idToUpload);\n                }\n                stillSubmitting = this.getUploads({\n                    status: qq.status.SUBMITTING\n                }).length;\n                if (stillSubmitting) {\n                    qq.log(\"Still waiting for \" + stillSubmitting + \" files to clear submit queue. Will re-parse stored IDs array shortly.\");\n                    setTimeout(function() {\n                        self._uploadStoredFiles();\n                    }, 1e3);\n                }\n            },\n            _validateFileOrBlobData: function(fileWrapper, validationDescriptor) {\n                var self = this, file = function() {\n                    if (fileWrapper.file instanceof qq.BlobProxy) {\n                        return fileWrapper.file.referenceBlob;\n                    }\n                    return fileWrapper.file;\n                }(), name = validationDescriptor.name, size = validationDescriptor.size, buttonId = this._getButtonId(fileWrapper.file), validationBase = this._getValidationBase(buttonId), validityChecker = new qq.Promise();\n                validityChecker.then(function() {}, function() {\n                    self._fileOrBlobRejected(fileWrapper.id, name);\n                });\n                if (qq.isFileOrInput(file) && !this._isAllowedExtension(validationBase.allowedExtensions, name)) {\n                    this._itemError(\"typeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (!this._options.validation.allowEmpty && size === 0) {\n                    this._itemError(\"emptyError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (size > 0 && validationBase.sizeLimit && size > validationBase.sizeLimit) {\n                    this._itemError(\"sizeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (size > 0 && size < validationBase.minSizeLimit) {\n                    this._itemError(\"minSizeError\", name, file);\n                    return validityChecker.failure();\n                }\n                if (qq.ImageValidation && qq.supportedFeatures.imagePreviews && qq.isFile(file)) {\n                    new qq.ImageValidation(file, qq.bind(self.log, self)).validate(validationBase.image).then(validityChecker.success, function(errorCode) {\n                        self._itemError(errorCode + \"ImageError\", name, file);\n                        validityChecker.failure();\n                    });\n                } else {\n                    validityChecker.success();\n                }\n                return validityChecker;\n            },\n            _wrapCallbacks: function() {\n                var self, safeCallback, prop;\n                self = this;\n                safeCallback = function(name, callback, args) {\n                    var errorMsg;\n                    try {\n                        return callback.apply(self, args);\n                    } catch (exception) {\n                        errorMsg = exception.message || exception.toString();\n                        self.log(\"Caught exception in '\" + name + \"' callback - \" + errorMsg, \"error\");\n                    }\n                };\n                for (prop in this._options.callbacks) {\n                    (function() {\n                        var callbackName, callbackFunc;\n                        callbackName = prop;\n                        callbackFunc = self._options.callbacks[callbackName];\n                        self._options.callbacks[callbackName] = function() {\n                            return safeCallback(callbackName, callbackFunc, arguments);\n                        };\n                    })();\n                }\n            }\n        };\n    })();\n    (function() {\n        \"use strict\";\n        qq.FineUploaderBasic = function(o) {\n            var self = this;\n            this._options = {\n                debug: false,\n                button: null,\n                multiple: true,\n                maxConnections: 3,\n                disableCancelForFormUploads: false,\n                autoUpload: true,\n                warnBeforeUnload: true,\n                request: {\n                    customHeaders: {},\n                    endpoint: \"/server/upload\",\n                    filenameParam: \"qqfilename\",\n                    forceMultipart: true,\n                    inputName: \"qqfile\",\n                    method: \"POST\",\n                    omitDefaultParams: false,\n                    params: {},\n                    paramsInBody: true,\n                    requireSuccessJson: true,\n                    totalFileSizeName: \"qqtotalfilesize\",\n                    uuidName: \"qquuid\"\n                },\n                validation: {\n                    allowedExtensions: [],\n                    sizeLimit: 0,\n                    minSizeLimit: 0,\n                    itemLimit: 0,\n                    stopOnFirstInvalidFile: true,\n                    acceptFiles: null,\n                    image: {\n                        maxHeight: 0,\n                        maxWidth: 0,\n                        minHeight: 0,\n                        minWidth: 0\n                    },\n                    allowEmpty: false\n                },\n                callbacks: {\n                    onSubmit: function(id, name) {},\n                    onSubmitted: function(id, name) {},\n                    onComplete: function(id, name, responseJSON, maybeXhr) {},\n                    onAllComplete: function(successful, failed) {},\n                    onCancel: function(id, name) {},\n                    onUpload: function(id, name) {},\n                    onUploadChunk: function(id, name, chunkData) {},\n                    onUploadChunkSuccess: function(id, chunkData, responseJSON, xhr) {},\n                    onResume: function(id, fileName, chunkData, customResumeData) {},\n                    onProgress: function(id, name, loaded, total) {},\n                    onTotalProgress: function(loaded, total) {},\n                    onError: function(id, name, reason, maybeXhrOrXdr) {},\n                    onAutoRetry: function(id, name, attemptNumber) {},\n                    onManualRetry: function(id, name) {},\n                    onValidateBatch: function(fileOrBlobData) {},\n                    onValidate: function(fileOrBlobData) {},\n                    onSubmitDelete: function(id) {},\n                    onDelete: function(id) {},\n                    onDeleteComplete: function(id, xhrOrXdr, isError) {},\n                    onPasteReceived: function(blob) {},\n                    onStatusChange: function(id, oldStatus, newStatus) {},\n                    onSessionRequestComplete: function(response, success, xhrOrXdr) {}\n                },\n                messages: {\n                    typeError: \"{file} has an invalid extension. Valid extension(s): {extensions}.\",\n                    sizeError: \"{file} is too large, maximum file size is {sizeLimit}.\",\n                    minSizeError: \"{file} is too small, minimum file size is {minSizeLimit}.\",\n                    emptyError: \"{file} is empty, please select files again without it.\",\n                    noFilesError: \"No files to upload.\",\n                    tooManyItemsError: \"Too many items ({netItems}) would be uploaded.  Item limit is {itemLimit}.\",\n                    maxHeightImageError: \"Image is too tall.\",\n                    maxWidthImageError: \"Image is too wide.\",\n                    minHeightImageError: \"Image is not tall enough.\",\n                    minWidthImageError: \"Image is not wide enough.\",\n                    retryFailTooManyItems: \"Retry failed - you have reached your file limit.\",\n                    onLeave: \"The files are being uploaded, if you leave now the upload will be canceled.\",\n                    unsupportedBrowserIos8Safari: \"Unrecoverable error - this browser does not permit file uploading of any kind due to serious bugs in iOS8 Safari.  Please use iOS8 Chrome until Apple fixes these issues.\"\n                },\n                retry: {\n                    enableAuto: false,\n                    maxAutoAttempts: 3,\n                    autoAttemptDelay: 5,\n                    preventRetryResponseProperty: \"preventRetry\"\n                },\n                classes: {\n                    buttonHover: \"qq-upload-button-hover\",\n                    buttonFocus: \"qq-upload-button-focus\"\n                },\n                chunking: {\n                    enabled: false,\n                    concurrent: {\n                        enabled: false\n                    },\n                    mandatory: false,\n                    paramNames: {\n                        partIndex: \"qqpartindex\",\n                        partByteOffset: \"qqpartbyteoffset\",\n                        chunkSize: \"qqchunksize\",\n                        totalFileSize: \"qqtotalfilesize\",\n                        totalParts: \"qqtotalparts\"\n                    },\n                    partSize: function(id) {\n                        return 2e6;\n                    },\n                    success: {\n                        endpoint: null,\n                        headers: function(id) {\n                            return null;\n                        },\n                        jsonPayload: false,\n                        method: \"POST\",\n                        params: function(id) {\n                            return null;\n                        },\n                        resetOnStatus: []\n                    }\n                },\n                resume: {\n                    enabled: false,\n                    recordsExpireIn: 7,\n                    paramNames: {\n                        resuming: \"qqresume\"\n                    },\n                    customKeys: function(fileId) {\n                        return [];\n                    }\n                },\n                formatFileName: function(fileOrBlobName) {\n                    return fileOrBlobName;\n                },\n                text: {\n                    defaultResponseError: \"Upload failure reason unknown\",\n                    fileInputTitle: \"file input\",\n                    sizeSymbols: [ \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\" ]\n                },\n                deleteFile: {\n                    enabled: false,\n                    method: \"DELETE\",\n                    endpoint: \"/server/upload\",\n                    customHeaders: {},\n                    params: {}\n                },\n                cors: {\n                    expected: false,\n                    sendCredentials: false,\n                    allowXdr: false\n                },\n                blobs: {\n                    defaultName: \"misc_data\"\n                },\n                paste: {\n                    targetElement: null,\n                    defaultName: \"pasted_image\"\n                },\n                camera: {\n                    ios: false,\n                    button: null\n                },\n                extraButtons: [],\n                session: {\n                    endpoint: null,\n                    params: {},\n                    customHeaders: {},\n                    refreshOnReset: true\n                },\n                form: {\n                    element: \"qq-form\",\n                    autoUpload: false,\n                    interceptSubmit: true\n                },\n                scaling: {\n                    customResizer: null,\n                    sendOriginal: true,\n                    orient: true,\n                    defaultType: null,\n                    defaultQuality: 80,\n                    failureText: \"Failed to scale\",\n                    includeExif: false,\n                    sizes: []\n                },\n                workarounds: {\n                    iosEmptyVideos: true,\n                    ios8SafariUploads: true,\n                    ios8BrowserCrash: false\n                }\n            };\n            qq.extend(this._options, o, true);\n            this._buttons = [];\n            this._extraButtonSpecs = {};\n            this._buttonIdsForFileIds = [];\n            this._wrapCallbacks();\n            this._disposeSupport = new qq.DisposeSupport();\n            this._storedIds = [];\n            this._autoRetries = [];\n            this._retryTimeouts = [];\n            this._preventRetries = [];\n            this._thumbnailUrls = [];\n            this._netUploadedOrQueued = 0;\n            this._netUploaded = 0;\n            this._uploadData = this._createUploadDataTracker();\n            this._initFormSupportAndParams();\n            this._customHeadersStore = this._createStore(this._options.request.customHeaders);\n            this._deleteFileCustomHeadersStore = this._createStore(this._options.deleteFile.customHeaders);\n            this._deleteFileParamsStore = this._createStore(this._options.deleteFile.params);\n            this._endpointStore = this._createStore(this._options.request.endpoint);\n            this._deleteFileEndpointStore = this._createStore(this._options.deleteFile.endpoint);\n            this._handler = this._createUploadHandler();\n            this._deleteHandler = qq.DeleteFileAjaxRequester && this._createDeleteHandler();\n            if (this._options.button) {\n                this._defaultButtonId = this._createUploadButton({\n                    element: this._options.button,\n                    title: this._options.text.fileInputTitle\n                }).getButtonId();\n            }\n            this._generateExtraButtonSpecs();\n            this._handleCameraAccess();\n            if (this._options.paste.targetElement) {\n                if (qq.PasteSupport) {\n                    this._pasteHandler = this._createPasteHandler();\n                } else {\n                    this.log(\"Paste support module not found\", \"error\");\n                }\n            }\n            this._options.warnBeforeUnload && this._preventLeaveInProgress();\n            this._imageGenerator = qq.ImageGenerator && new qq.ImageGenerator(qq.bind(this.log, this));\n            this._refreshSessionData();\n            this._succeededSinceLastAllComplete = [];\n            this._failedSinceLastAllComplete = [];\n            this._scaler = qq.Scaler && new qq.Scaler(this._options.scaling, qq.bind(this.log, this)) || {};\n            if (this._scaler.enabled) {\n                this._customNewFileHandler = qq.bind(this._scaler.handleNewFile, this._scaler);\n            }\n            if (qq.TotalProgress && qq.supportedFeatures.progressBar) {\n                this._totalProgress = new qq.TotalProgress(qq.bind(this._onTotalProgress, this), function(id) {\n                    var entry = self._uploadData.retrieve({\n                        id: id\n                    });\n                    return entry && entry.size || 0;\n                });\n            }\n            this._currentItemLimit = this._options.validation.itemLimit;\n            this._customResumeDataStore = this._createStore();\n        };\n        qq.FineUploaderBasic.prototype = qq.basePublicApi;\n        qq.extend(qq.FineUploaderBasic.prototype, qq.basePrivateApi);\n    })();\n    qq.AjaxRequester = function(o) {\n        \"use strict\";\n        var log, shouldParamsBeInQueryString, queue = [], requestData = {}, options = {\n            acceptHeader: null,\n            validMethods: [ \"PATCH\", \"POST\", \"PUT\" ],\n            method: \"POST\",\n            contentType: \"application/x-www-form-urlencoded\",\n            maxConnections: 3,\n            customHeaders: {},\n            endpointStore: {},\n            paramsStore: {},\n            mandatedParams: {},\n            allowXRequestedWithAndCacheControl: true,\n            successfulResponseCodes: {\n                DELETE: [ 200, 202, 204 ],\n                PATCH: [ 200, 201, 202, 203, 204 ],\n                POST: [ 200, 201, 202, 203, 204 ],\n                PUT: [ 200, 201, 202, 203, 204 ],\n                GET: [ 200 ]\n            },\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onSend: function(id) {},\n            onComplete: function(id, xhrOrXdr, isError) {},\n            onProgress: null\n        };\n        qq.extend(options, o);\n        log = options.log;\n        if (qq.indexOf(options.validMethods, options.method) < 0) {\n            throw new Error(\"'\" + options.method + \"' is not a supported method for this type of request!\");\n        }\n        function isSimpleMethod() {\n            return qq.indexOf([ \"GET\", \"POST\", \"HEAD\" ], options.method) >= 0;\n        }\n        function containsNonSimpleHeaders(headers) {\n            var containsNonSimple = false;\n            qq.each(containsNonSimple, function(idx, header) {\n                if (qq.indexOf([ \"Accept\", \"Accept-Language\", \"Content-Language\", \"Content-Type\" ], header) < 0) {\n                    containsNonSimple = true;\n                    return false;\n                }\n            });\n            return containsNonSimple;\n        }\n        function isXdr(xhr) {\n            return options.cors.expected && xhr.withCredentials === undefined;\n        }\n        function getCorsAjaxTransport() {\n            var xhrOrXdr;\n            if (window.XMLHttpRequest || window.ActiveXObject) {\n                xhrOrXdr = qq.createXhrInstance();\n                if (xhrOrXdr.withCredentials === undefined) {\n                    xhrOrXdr = new XDomainRequest();\n                    xhrOrXdr.onload = function() {};\n                    xhrOrXdr.onerror = function() {};\n                    xhrOrXdr.ontimeout = function() {};\n                    xhrOrXdr.onprogress = function() {};\n                }\n            }\n            return xhrOrXdr;\n        }\n        function getXhrOrXdr(id, suppliedXhr) {\n            var xhrOrXdr = requestData[id] && requestData[id].xhr;\n            if (!xhrOrXdr) {\n                if (suppliedXhr) {\n                    xhrOrXdr = suppliedXhr;\n                } else {\n                    if (options.cors.expected) {\n                        xhrOrXdr = getCorsAjaxTransport();\n                    } else {\n                        xhrOrXdr = qq.createXhrInstance();\n                    }\n                }\n                requestData[id].xhr = xhrOrXdr;\n            }\n            return xhrOrXdr;\n        }\n        function dequeue(id) {\n            var i = qq.indexOf(queue, id), max = options.maxConnections, nextId;\n            delete requestData[id];\n            queue.splice(i, 1);\n            if (queue.length >= max && i < max) {\n                nextId = queue[max - 1];\n                sendRequest(nextId);\n            }\n        }\n        function onComplete(id, xdrError) {\n            var xhr = getXhrOrXdr(id), method = options.method, isError = xdrError === true;\n            dequeue(id);\n            if (isError) {\n                log(method + \" request for \" + id + \" has failed\", \"error\");\n            } else if (!isXdr(xhr) && !isResponseSuccessful(xhr.status)) {\n                isError = true;\n                log(method + \" request for \" + id + \" has failed - response code \" + xhr.status, \"error\");\n            }\n            options.onComplete(id, xhr, isError);\n        }\n        function getParams(id) {\n            var onDemandParams = requestData[id].additionalParams, mandatedParams = options.mandatedParams, params;\n            if (options.paramsStore.get) {\n                params = options.paramsStore.get(id);\n            }\n            if (onDemandParams) {\n                qq.each(onDemandParams, function(name, val) {\n                    params = params || {};\n                    params[name] = val;\n                });\n            }\n            if (mandatedParams) {\n                qq.each(mandatedParams, function(name, val) {\n                    params = params || {};\n                    params[name] = val;\n                });\n            }\n            return params;\n        }\n        function sendRequest(id, optXhr) {\n            var xhr = getXhrOrXdr(id, optXhr), method = options.method, params = getParams(id), payload = requestData[id].payload, url;\n            options.onSend(id);\n            url = createUrl(id, params, requestData[id].additionalQueryParams);\n            if (isXdr(xhr)) {\n                xhr.onload = getXdrLoadHandler(id);\n                xhr.onerror = getXdrErrorHandler(id);\n            } else {\n                xhr.onreadystatechange = getXhrReadyStateChangeHandler(id);\n            }\n            registerForUploadProgress(id);\n            xhr.open(method, url, true);\n            if (options.cors.expected && options.cors.sendCredentials && !isXdr(xhr)) {\n                xhr.withCredentials = true;\n            }\n            setHeaders(id);\n            log(\"Sending \" + method + \" request for \" + id);\n            if (payload) {\n                xhr.send(payload);\n            } else if (shouldParamsBeInQueryString || !params) {\n                xhr.send();\n            } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/x-www-form-urlencoded\") >= 0) {\n                xhr.send(qq.obj2url(params, \"\"));\n            } else if (params && options.contentType && options.contentType.toLowerCase().indexOf(\"application/json\") >= 0) {\n                xhr.send(JSON.stringify(params));\n            } else {\n                xhr.send(params);\n            }\n            return xhr;\n        }\n        function createUrl(id, params, additionalQueryParams) {\n            var endpoint = options.endpointStore.get(id), addToPath = requestData[id].addToPath;\n            if (addToPath != undefined) {\n                endpoint += \"/\" + addToPath;\n            }\n            if (shouldParamsBeInQueryString && params) {\n                endpoint = qq.obj2url(params, endpoint);\n            }\n            if (additionalQueryParams) {\n                endpoint = qq.obj2url(additionalQueryParams, endpoint);\n            }\n            return endpoint;\n        }\n        function getXhrReadyStateChangeHandler(id) {\n            return function() {\n                if (getXhrOrXdr(id).readyState === 4) {\n                    onComplete(id);\n                }\n            };\n        }\n        function registerForUploadProgress(id) {\n            var onProgress = options.onProgress;\n            if (onProgress) {\n                getXhrOrXdr(id).upload.onprogress = function(e) {\n                    if (e.lengthComputable) {\n                        onProgress(id, e.loaded, e.total);\n                    }\n                };\n            }\n        }\n        function getXdrLoadHandler(id) {\n            return function() {\n                onComplete(id);\n            };\n        }\n        function getXdrErrorHandler(id) {\n            return function() {\n                onComplete(id, true);\n            };\n        }\n        function setHeaders(id) {\n            var xhr = getXhrOrXdr(id), customHeaders = options.customHeaders, onDemandHeaders = requestData[id].additionalHeaders || {}, method = options.method, allHeaders = {};\n            if (!isXdr(xhr)) {\n                options.acceptHeader && xhr.setRequestHeader(\"Accept\", options.acceptHeader);\n                if (options.allowXRequestedWithAndCacheControl) {\n                    if (!options.cors.expected || (!isSimpleMethod() || containsNonSimpleHeaders(customHeaders))) {\n                        xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                        xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n                    }\n                }\n                if (options.contentType && (method === \"POST\" || method === \"PUT\")) {\n                    xhr.setRequestHeader(\"Content-Type\", options.contentType);\n                }\n                qq.extend(allHeaders, qq.isFunction(customHeaders) ? customHeaders(id) : customHeaders);\n                qq.extend(allHeaders, onDemandHeaders);\n                qq.each(allHeaders, function(name, val) {\n                    xhr.setRequestHeader(name, val);\n                });\n            }\n        }\n        function isResponseSuccessful(responseCode) {\n            return qq.indexOf(options.successfulResponseCodes[options.method], responseCode) >= 0;\n        }\n        function prepareToSend(id, optXhr, addToPath, additionalParams, additionalQueryParams, additionalHeaders, payload) {\n            requestData[id] = {\n                addToPath: addToPath,\n                additionalParams: additionalParams,\n                additionalQueryParams: additionalQueryParams,\n                additionalHeaders: additionalHeaders,\n                payload: payload\n            };\n            var len = queue.push(id);\n            if (len <= options.maxConnections) {\n                return sendRequest(id, optXhr);\n            }\n        }\n        shouldParamsBeInQueryString = options.method === \"GET\" || options.method === \"DELETE\";\n        qq.extend(this, {\n            initTransport: function(id) {\n                var path, params, headers, payload, cacheBuster, additionalQueryParams;\n                return {\n                    withPath: function(appendToPath) {\n                        path = appendToPath;\n                        return this;\n                    },\n                    withParams: function(additionalParams) {\n                        params = additionalParams;\n                        return this;\n                    },\n                    withQueryParams: function(_additionalQueryParams_) {\n                        additionalQueryParams = _additionalQueryParams_;\n                        return this;\n                    },\n                    withHeaders: function(additionalHeaders) {\n                        headers = additionalHeaders;\n                        return this;\n                    },\n                    withPayload: function(thePayload) {\n                        payload = thePayload;\n                        return this;\n                    },\n                    withCacheBuster: function() {\n                        cacheBuster = true;\n                        return this;\n                    },\n                    send: function(optXhr) {\n                        if (cacheBuster && qq.indexOf([ \"GET\", \"DELETE\" ], options.method) >= 0) {\n                            params.qqtimestamp = new Date().getTime();\n                        }\n                        return prepareToSend(id, optXhr, path, params, additionalQueryParams, headers, payload);\n                    }\n                };\n            },\n            canceled: function(id) {\n                dequeue(id);\n            }\n        });\n    };\n    qq.UploadHandler = function(spec) {\n        \"use strict\";\n        var proxy = spec.proxy, fileState = {}, onCancel = proxy.onCancel, getName = proxy.getName;\n        qq.extend(this, {\n            add: function(id, fileItem) {\n                fileState[id] = fileItem;\n                fileState[id].temp = {};\n            },\n            cancel: function(id) {\n                var self = this, cancelFinalizationEffort = new qq.Promise(), onCancelRetVal = onCancel(id, getName(id), cancelFinalizationEffort);\n                onCancelRetVal.then(function() {\n                    if (self.isValid(id)) {\n                        fileState[id].canceled = true;\n                        self.expunge(id);\n                    }\n                    cancelFinalizationEffort.success();\n                });\n            },\n            expunge: function(id) {\n                delete fileState[id];\n            },\n            getThirdPartyFileId: function(id) {\n                return fileState[id].key;\n            },\n            isValid: function(id) {\n                return fileState[id] !== undefined;\n            },\n            reset: function() {\n                fileState = {};\n            },\n            _getFileState: function(id) {\n                return fileState[id];\n            },\n            _setThirdPartyFileId: function(id, thirdPartyFileId) {\n                fileState[id].key = thirdPartyFileId;\n            },\n            _wasCanceled: function(id) {\n                return !!fileState[id].canceled;\n            }\n        });\n    };\n    qq.UploadHandlerController = function(o, namespace) {\n        \"use strict\";\n        var controller = this, chunkingPossible = false, concurrentChunkingPossible = false, chunking, preventRetryResponse, log, handler, options = {\n            paramsStore: {},\n            maxConnections: 3,\n            chunking: {\n                enabled: false,\n                multiple: {\n                    enabled: false\n                }\n            },\n            log: function(str, level) {},\n            onProgress: function(id, fileName, loaded, total) {},\n            onComplete: function(id, fileName, response, xhr) {},\n            onCancel: function(id, fileName) {},\n            onUploadPrep: function(id) {},\n            onUpload: function(id, fileName) {},\n            onUploadChunk: function(id, fileName, chunkData) {},\n            onUploadChunkSuccess: function(id, chunkData, response, xhr) {},\n            onAutoRetry: function(id, fileName, response, xhr) {},\n            onResume: function(id, fileName, chunkData, customResumeData) {},\n            onUuidChanged: function(id, newUuid) {},\n            getName: function(id) {},\n            setSize: function(id, newSize) {},\n            isQueued: function(id) {},\n            getIdsInProxyGroup: function(id) {},\n            getIdsInBatch: function(id) {},\n            isInProgress: function(id) {}\n        }, chunked = {\n            done: function(id, chunkIdx, response, xhr) {\n                var chunkData = handler._getChunkData(id, chunkIdx);\n                handler._getFileState(id).attemptingResume = false;\n                delete handler._getFileState(id).temp.chunkProgress[chunkIdx];\n                handler._getFileState(id).loaded += chunkData.size;\n                options.onUploadChunkSuccess(id, handler._getChunkDataForCallback(chunkData), response, xhr);\n            },\n            finalize: function(id) {\n                var size = options.getSize(id), name = options.getName(id);\n                log(\"All chunks have been uploaded for \" + id + \" - finalizing....\");\n                handler.finalizeChunks(id).then(function(response, xhr) {\n                    log(\"Finalize successful for \" + id);\n                    var normaizedResponse = upload.normalizeResponse(response, true);\n                    options.onProgress(id, name, size, size);\n                    handler._maybeDeletePersistedChunkData(id);\n                    upload.cleanup(id, normaizedResponse, xhr);\n                }, function(response, xhr) {\n                    var normalizedResponse = upload.normalizeResponse(response, false);\n                    log(\"Problem finalizing chunks for file ID \" + id + \" - \" + normalizedResponse.error, \"error\");\n                    if (normalizedResponse.reset || xhr && options.chunking.success.resetOnStatus.indexOf(xhr.status) >= 0) {\n                        chunked.reset(id);\n                    }\n                    if (!options.onAutoRetry(id, name, normalizedResponse, xhr)) {\n                        upload.cleanup(id, normalizedResponse, xhr);\n                    }\n                });\n            },\n            handleFailure: function(chunkIdx, id, response, xhr) {\n                var name = options.getName(id);\n                log(\"Chunked upload request failed for \" + id + \", chunk \" + chunkIdx);\n                handler.clearCachedChunk(id, chunkIdx);\n                var responseToReport = upload.normalizeResponse(response, false), inProgressIdx;\n                if (responseToReport.reset) {\n                    chunked.reset(id);\n                } else {\n                    var inProgressChunksArray = handler._getFileState(id).chunking.inProgress;\n                    inProgressIdx = inProgressChunksArray ? qq.indexOf(inProgressChunksArray, chunkIdx) : -1;\n                    if (inProgressIdx >= 0) {\n                        handler._getFileState(id).chunking.inProgress.splice(inProgressIdx, 1);\n                        handler._getFileState(id).chunking.remaining.unshift(chunkIdx);\n                    }\n                }\n                if (!handler._getFileState(id).temp.ignoreFailure) {\n                    if (concurrentChunkingPossible) {\n                        handler._getFileState(id).temp.ignoreFailure = true;\n                        log(qq.format(\"Going to attempt to abort these chunks: {}. These are currently in-progress: {}.\", JSON.stringify(Object.keys(handler._getXhrs(id))), JSON.stringify(handler._getFileState(id).chunking.inProgress)));\n                        qq.each(handler._getXhrs(id), function(ckid, ckXhr) {\n                            log(qq.format(\"Attempting to abort file {}.{}. XHR readyState {}. \", id, ckid, ckXhr.readyState));\n                            ckXhr.abort();\n                            ckXhr._cancelled = true;\n                        });\n                        handler.moveInProgressToRemaining(id);\n                        connectionManager.free(id, true);\n                    }\n                    if (!options.onAutoRetry(id, name, responseToReport, xhr)) {\n                        upload.cleanup(id, responseToReport, xhr);\n                    }\n                }\n            },\n            hasMoreParts: function(id) {\n                return !!handler._getFileState(id).chunking.remaining.length;\n            },\n            nextPart: function(id) {\n                var nextIdx = handler._getFileState(id).chunking.remaining.shift();\n                if (nextIdx >= handler._getTotalChunks(id)) {\n                    nextIdx = null;\n                }\n                return nextIdx;\n            },\n            reset: function(id) {\n                log(\"Server or callback has ordered chunking effort to be restarted on next attempt for item ID \" + id, \"error\");\n                handler._maybeDeletePersistedChunkData(id);\n                handler.reevaluateChunking(id);\n                handler._getFileState(id).loaded = 0;\n                handler._getFileState(id).attemptingResume = false;\n            },\n            sendNext: function(id) {\n                var size = options.getSize(id), name = options.getName(id), chunkIdx = chunked.nextPart(id), chunkData = handler._getChunkData(id, chunkIdx), fileState = handler._getFileState(id), resuming = fileState.attemptingResume, inProgressChunks = fileState.chunking.inProgress || [];\n                if (fileState.loaded == null) {\n                    fileState.loaded = 0;\n                }\n                if (resuming && options.onResume(id, name, chunkData, fileState.customResumeData) === false) {\n                    chunked.reset(id);\n                    chunkIdx = chunked.nextPart(id);\n                    chunkData = handler._getChunkData(id, chunkIdx);\n                    resuming = false;\n                }\n                if (chunkIdx == null && inProgressChunks.length === 0) {\n                    chunked.finalize(id);\n                } else {\n                    inProgressChunks.push(chunkIdx);\n                    handler._getFileState(id).chunking.inProgress = inProgressChunks;\n                    if (concurrentChunkingPossible) {\n                        connectionManager.open(id, chunkIdx);\n                    }\n                    if (concurrentChunkingPossible && connectionManager.available() && handler._getFileState(id).chunking.remaining.length) {\n                        chunked.sendNext(id);\n                    }\n                    if (chunkData.blob.size === 0) {\n                        log(qq.format(\"Chunk {} for file {} will not be uploaded, zero sized chunk.\", chunkIdx, id), \"error\");\n                        chunked.handleFailure(chunkIdx, id, \"File is no longer available\", null);\n                    }\n                    var onUploadChunkPromise = options.onUploadChunk(id, name, handler._getChunkDataForCallback(chunkData));\n                    onUploadChunkPromise.then(function(requestOverrides) {\n                        if (!options.isInProgress(id)) {\n                            log(qq.format(\"Not sending chunked upload request for item {}.{} - no longer in progress.\", id, chunkIdx));\n                        } else {\n                            log(qq.format(\"Sending chunked upload request for item {}.{}, bytes {}-{} of {}.\", id, chunkIdx, chunkData.start + 1, chunkData.end, size));\n                            var uploadChunkData = {\n                                chunkIdx: chunkIdx,\n                                id: id,\n                                overrides: requestOverrides,\n                                resuming: resuming\n                            };\n                            handler.uploadChunk(uploadChunkData).then(function success(response, xhr) {\n                                log(\"Chunked upload request succeeded for \" + id + \", chunk \" + chunkIdx);\n                                handler.clearCachedChunk(id, chunkIdx);\n                                var inProgressChunks = handler._getFileState(id).chunking.inProgress || [], responseToReport = upload.normalizeResponse(response, true), inProgressChunkIdx = qq.indexOf(inProgressChunks, chunkIdx);\n                                log(qq.format(\"Chunk {} for file {} uploaded successfully.\", chunkIdx, id));\n                                chunked.done(id, chunkIdx, responseToReport, xhr);\n                                if (inProgressChunkIdx >= 0) {\n                                    inProgressChunks.splice(inProgressChunkIdx, 1);\n                                }\n                                handler._maybePersistChunkedState(id);\n                                if (!chunked.hasMoreParts(id) && inProgressChunks.length === 0) {\n                                    chunked.finalize(id);\n                                } else if (chunked.hasMoreParts(id)) {\n                                    chunked.sendNext(id);\n                                } else {\n                                    log(qq.format(\"File ID {} has no more chunks to send and these chunk indexes are still marked as in-progress: {}\", id, JSON.stringify(inProgressChunks)));\n                                }\n                            }, function failure(response, xhr) {\n                                chunked.handleFailure(chunkIdx, id, response, xhr);\n                            }).done(function() {\n                                handler.clearXhr(id, chunkIdx);\n                            });\n                        }\n                    }, function(error) {\n                        chunked.handleFailure(chunkIdx, id, error, null);\n                    });\n                }\n            }\n        }, connectionManager = {\n            _open: [],\n            _openChunks: {},\n            _waiting: [],\n            available: function() {\n                var max = options.maxConnections, openChunkEntriesCount = 0, openChunksCount = 0;\n                qq.each(connectionManager._openChunks, function(fileId, openChunkIndexes) {\n                    openChunkEntriesCount++;\n                    openChunksCount += openChunkIndexes.length;\n                });\n                return max - (connectionManager._open.length - openChunkEntriesCount + openChunksCount);\n            },\n            free: function(id, dontAllowNext) {\n                var allowNext = !dontAllowNext, waitingIndex = qq.indexOf(connectionManager._waiting, id), connectionsIndex = qq.indexOf(connectionManager._open, id), nextId;\n                delete connectionManager._openChunks[id];\n                if (upload.getProxyOrBlob(id) instanceof qq.BlobProxy) {\n                    log(\"Generated blob upload has ended for \" + id + \", disposing generated blob.\");\n                    delete handler._getFileState(id).file;\n                }\n                if (waitingIndex >= 0) {\n                    connectionManager._waiting.splice(waitingIndex, 1);\n                } else if (allowNext && connectionsIndex >= 0) {\n                    connectionManager._open.splice(connectionsIndex, 1);\n                    nextId = connectionManager._waiting.shift();\n                    if (nextId >= 0) {\n                        connectionManager._open.push(nextId);\n                        upload.start(nextId);\n                    }\n                }\n            },\n            getWaitingOrConnected: function() {\n                var waitingOrConnected = [];\n                qq.each(connectionManager._openChunks, function(fileId, chunks) {\n                    if (chunks && chunks.length) {\n                        waitingOrConnected.push(parseInt(fileId));\n                    }\n                });\n                qq.each(connectionManager._open, function(idx, fileId) {\n                    if (!connectionManager._openChunks[fileId]) {\n                        waitingOrConnected.push(parseInt(fileId));\n                    }\n                });\n                waitingOrConnected = waitingOrConnected.concat(connectionManager._waiting);\n                return waitingOrConnected;\n            },\n            isUsingConnection: function(id) {\n                return qq.indexOf(connectionManager._open, id) >= 0;\n            },\n            open: function(id, chunkIdx) {\n                if (chunkIdx == null) {\n                    connectionManager._waiting.push(id);\n                }\n                if (connectionManager.available()) {\n                    if (chunkIdx == null) {\n                        connectionManager._waiting.pop();\n                        connectionManager._open.push(id);\n                    } else {\n                        (function() {\n                            var openChunksEntry = connectionManager._openChunks[id] || [];\n                            openChunksEntry.push(chunkIdx);\n                            connectionManager._openChunks[id] = openChunksEntry;\n                        })();\n                    }\n                    return true;\n                }\n                return false;\n            },\n            reset: function() {\n                connectionManager._waiting = [];\n                connectionManager._open = [];\n            }\n        }, simple = {\n            send: function(id, name) {\n                var fileState = handler._getFileState(id);\n                if (!fileState) {\n                    log(\"Ignoring send request as this upload may have been cancelled, File ID \" + id, \"warn\");\n                    return;\n                }\n                fileState.loaded = 0;\n                log(\"Sending simple upload request for \" + id);\n                handler.uploadFile(id).then(function(response, optXhr) {\n                    log(\"Simple upload request succeeded for \" + id);\n                    var responseToReport = upload.normalizeResponse(response, true), size = options.getSize(id);\n                    options.onProgress(id, name, size, size);\n                    upload.maybeNewUuid(id, responseToReport);\n                    upload.cleanup(id, responseToReport, optXhr);\n                }, function(response, optXhr) {\n                    log(\"Simple upload request failed for \" + id);\n                    var responseToReport = upload.normalizeResponse(response, false);\n                    if (!options.onAutoRetry(id, name, responseToReport, optXhr)) {\n                        upload.cleanup(id, responseToReport, optXhr);\n                    }\n                });\n            }\n        }, upload = {\n            cancel: function(id) {\n                log(\"Cancelling \" + id);\n                options.paramsStore.remove(id);\n                connectionManager.free(id);\n            },\n            cleanup: function(id, response, optXhr) {\n                var name = options.getName(id);\n                options.onComplete(id, name, response, optXhr);\n                if (handler._getFileState(id)) {\n                    handler._clearXhrs && handler._clearXhrs(id);\n                }\n                connectionManager.free(id);\n            },\n            getProxyOrBlob: function(id) {\n                return handler.getProxy && handler.getProxy(id) || handler.getFile && handler.getFile(id);\n            },\n            initHandler: function() {\n                var handlerType = namespace ? qq[namespace] : qq.traditional, handlerModuleSubtype = qq.supportedFeatures.ajaxUploading ? \"Xhr\" : \"Form\";\n                handler = new handlerType[handlerModuleSubtype + \"UploadHandler\"](options, {\n                    getCustomResumeData: options.getCustomResumeData,\n                    getDataByUuid: options.getDataByUuid,\n                    getName: options.getName,\n                    getSize: options.getSize,\n                    getUuid: options.getUuid,\n                    log: log,\n                    onCancel: options.onCancel,\n                    onProgress: options.onProgress,\n                    onUuidChanged: options.onUuidChanged,\n                    onFinalizing: function(id) {\n                        options.setStatus(id, qq.status.UPLOAD_FINALIZING);\n                    }\n                });\n                if (handler._removeExpiredChunkingRecords) {\n                    handler._removeExpiredChunkingRecords();\n                }\n            },\n            isDeferredEligibleForUpload: function(id) {\n                return options.isQueued(id);\n            },\n            maybeDefer: function(id, blob) {\n                if (blob && !handler.getFile(id) && blob instanceof qq.BlobProxy) {\n                    options.onUploadPrep(id);\n                    log(\"Attempting to generate a blob on-demand for \" + id);\n                    blob.create().then(function(generatedBlob) {\n                        log(\"Generated an on-demand blob for \" + id);\n                        handler.updateBlob(id, generatedBlob);\n                        options.setSize(id, generatedBlob.size);\n                        handler.reevaluateChunking(id);\n                        upload.maybeSendDeferredFiles(id);\n                    }, function(errorMessage) {\n                        var errorResponse = {};\n                        if (errorMessage) {\n                            errorResponse.error = errorMessage;\n                        }\n                        log(qq.format(\"Failed to generate blob for ID {}.  Error message: {}.\", id, errorMessage), \"error\");\n                        options.onComplete(id, options.getName(id), qq.extend(errorResponse, preventRetryResponse), null);\n                        upload.maybeSendDeferredFiles(id);\n                        connectionManager.free(id);\n                    });\n                } else {\n                    return upload.maybeSendDeferredFiles(id);\n                }\n                return false;\n            },\n            maybeSendDeferredFiles: function(id) {\n                var idsInGroup = options.getIdsInProxyGroup(id), uploadedThisId = false;\n                if (idsInGroup && idsInGroup.length) {\n                    log(\"Maybe ready to upload proxy group file \" + id);\n                    qq.each(idsInGroup, function(idx, idInGroup) {\n                        if (upload.isDeferredEligibleForUpload(idInGroup) && !!handler.getFile(idInGroup)) {\n                            uploadedThisId = idInGroup === id;\n                            upload.now(idInGroup);\n                        } else if (upload.isDeferredEligibleForUpload(idInGroup)) {\n                            return false;\n                        }\n                    });\n                } else {\n                    uploadedThisId = true;\n                    upload.now(id);\n                }\n                return uploadedThisId;\n            },\n            maybeNewUuid: function(id, response) {\n                if (response.newUuid !== undefined) {\n                    options.onUuidChanged(id, response.newUuid);\n                }\n            },\n            normalizeResponse: function(originalResponse, successful) {\n                var response = originalResponse;\n                if (!qq.isObject(originalResponse)) {\n                    response = {};\n                    if (qq.isString(originalResponse) && !successful) {\n                        response.error = originalResponse;\n                    }\n                }\n                response.success = successful;\n                return response;\n            },\n            now: function(id) {\n                var name = options.getName(id);\n                if (!controller.isValid(id)) {\n                    throw new qq.Error(id + \" is not a valid file ID to upload!\");\n                }\n                options.onUpload(id, name).then(function(response) {\n                    if (response && response.pause) {\n                        options.setStatus(id, qq.status.PAUSED);\n                        handler.pause(id);\n                        connectionManager.free(id);\n                    } else {\n                        if (chunkingPossible && handler._shouldChunkThisFile(id)) {\n                            chunked.sendNext(id);\n                        } else {\n                            simple.send(id, name);\n                        }\n                    }\n                }, function(error) {\n                    error = error || {};\n                    log(id + \" upload start aborted due to rejected onUpload Promise - details: \" + error, \"error\");\n                    if (!options.onAutoRetry(id, name, error.responseJSON || {})) {\n                        var response = upload.normalizeResponse(error.responseJSON, false);\n                        upload.cleanup(id, response);\n                    }\n                });\n            },\n            start: function(id) {\n                var blobToUpload = upload.getProxyOrBlob(id);\n                if (blobToUpload) {\n                    return upload.maybeDefer(id, blobToUpload);\n                } else {\n                    upload.now(id);\n                    return true;\n                }\n            }\n        };\n        qq.extend(this, {\n            add: function(id, file) {\n                handler.add.apply(this, arguments);\n            },\n            upload: function(id) {\n                if (connectionManager.open(id)) {\n                    return upload.start(id);\n                }\n                return false;\n            },\n            retry: function(id) {\n                if (concurrentChunkingPossible) {\n                    handler._getFileState(id).temp.ignoreFailure = false;\n                }\n                if (connectionManager.isUsingConnection(id)) {\n                    return upload.start(id);\n                } else {\n                    return controller.upload(id);\n                }\n            },\n            cancel: function(id) {\n                var cancelRetVal = handler.cancel(id);\n                if (qq.isGenericPromise(cancelRetVal)) {\n                    cancelRetVal.then(function() {\n                        upload.cancel(id);\n                    });\n                } else if (cancelRetVal !== false) {\n                    upload.cancel(id);\n                }\n            },\n            cancelAll: function() {\n                var waitingOrConnected = connectionManager.getWaitingOrConnected(), i;\n                if (waitingOrConnected.length) {\n                    for (i = waitingOrConnected.length - 1; i >= 0; i--) {\n                        controller.cancel(waitingOrConnected[i]);\n                    }\n                }\n                connectionManager.reset();\n            },\n            getFile: function(id) {\n                if (handler.getProxy && handler.getProxy(id)) {\n                    return handler.getProxy(id).referenceBlob;\n                }\n                return handler.getFile && handler.getFile(id);\n            },\n            isProxied: function(id) {\n                return !!(handler.getProxy && handler.getProxy(id));\n            },\n            getInput: function(id) {\n                if (handler.getInput) {\n                    return handler.getInput(id);\n                }\n            },\n            reset: function() {\n                log(\"Resetting upload handler\");\n                controller.cancelAll();\n                connectionManager.reset();\n                handler.reset();\n            },\n            expunge: function(id) {\n                if (controller.isValid(id)) {\n                    return handler.expunge(id);\n                }\n            },\n            isValid: function(id) {\n                return handler.isValid(id);\n            },\n            hasResumeRecord: function(id) {\n                var key = handler.isValid(id) && handler._getLocalStorageId && handler._getLocalStorageId(id);\n                if (key) {\n                    return !!localStorage.getItem(key);\n                }\n                return false;\n            },\n            getResumableFilesData: function() {\n                if (handler.getResumableFilesData) {\n                    return handler.getResumableFilesData();\n                }\n                return [];\n            },\n            getThirdPartyFileId: function(id) {\n                if (controller.isValid(id)) {\n                    return handler.getThirdPartyFileId(id);\n                }\n            },\n            pause: function(id) {\n                if (controller.isResumable(id) && handler.pause && controller.isValid(id) && handler.pause(id)) {\n                    connectionManager.free(id);\n                    handler.moveInProgressToRemaining(id);\n                    return true;\n                }\n                return false;\n            },\n            isAttemptingResume: function(id) {\n                return !!handler.isAttemptingResume && handler.isAttemptingResume(id);\n            },\n            isResumable: function(id) {\n                return !!handler.isResumable && handler.isResumable(id);\n            }\n        });\n        qq.extend(options, o);\n        log = options.log;\n        chunkingPossible = options.chunking.enabled && qq.supportedFeatures.chunking;\n        concurrentChunkingPossible = chunkingPossible && options.chunking.concurrent.enabled;\n        preventRetryResponse = function() {\n            var response = {};\n            response[options.preventRetryParam] = true;\n            return response;\n        }();\n        upload.initHandler();\n    };\n    qq.WindowReceiveMessage = function(o) {\n        \"use strict\";\n        var options = {\n            log: function(message, level) {}\n        }, callbackWrapperDetachers = {};\n        qq.extend(options, o);\n        qq.extend(this, {\n            receiveMessage: function(id, callback) {\n                var onMessageCallbackWrapper = function(event) {\n                    callback(event.data);\n                };\n                if (window.postMessage) {\n                    callbackWrapperDetachers[id] = qq(window).attach(\"message\", onMessageCallbackWrapper);\n                } else {\n                    log(\"iframe message passing not supported in this browser!\", \"error\");\n                }\n            },\n            stopReceivingMessages: function(id) {\n                if (window.postMessage) {\n                    var detacher = callbackWrapperDetachers[id];\n                    if (detacher) {\n                        detacher();\n                    }\n                }\n            }\n        });\n    };\n    qq.FormUploadHandler = function(spec) {\n        \"use strict\";\n        var options = spec.options, handler = this, proxy = spec.proxy, formHandlerInstanceId = qq.getUniqueId(), onloadCallbacks = {}, detachLoadEvents = {}, postMessageCallbackTimers = {}, isCors = options.isCors, inputName = options.inputName, getUuid = proxy.getUuid, log = proxy.log, corsMessageReceiver = new qq.WindowReceiveMessage({\n            log: log\n        });\n        function expungeFile(id) {\n            delete detachLoadEvents[id];\n            if (isCors) {\n                clearTimeout(postMessageCallbackTimers[id]);\n                delete postMessageCallbackTimers[id];\n                corsMessageReceiver.stopReceivingMessages(id);\n            }\n            var iframe = document.getElementById(handler._getIframeName(id));\n            if (iframe) {\n                iframe.setAttribute(\"src\", \"javascript:false;\");\n                qq(iframe).remove();\n            }\n        }\n        function getFileIdForIframeName(iframeName) {\n            return iframeName.split(\"_\")[0];\n        }\n        function initIframeForUpload(name) {\n            var iframe = qq.toElement(\"<iframe src='javascript:false;' name='\" + name + \"' />\");\n            iframe.setAttribute(\"id\", name);\n            iframe.style.display = \"none\";\n            document.body.appendChild(iframe);\n            return iframe;\n        }\n        function registerPostMessageCallback(iframe, callback) {\n            var iframeName = iframe.id, fileId = getFileIdForIframeName(iframeName), uuid = getUuid(fileId);\n            onloadCallbacks[uuid] = callback;\n            detachLoadEvents[fileId] = qq(iframe).attach(\"load\", function() {\n                if (handler.getInput(fileId)) {\n                    log(\"Received iframe load event for CORS upload request (iframe name \" + iframeName + \")\");\n                    postMessageCallbackTimers[iframeName] = setTimeout(function() {\n                        var errorMessage = \"No valid message received from loaded iframe for iframe name \" + iframeName;\n                        log(errorMessage, \"error\");\n                        callback({\n                            error: errorMessage\n                        });\n                    }, 1e3);\n                }\n            });\n            corsMessageReceiver.receiveMessage(iframeName, function(message) {\n                log(\"Received the following window message: '\" + message + \"'\");\n                var fileId = getFileIdForIframeName(iframeName), response = handler._parseJsonResponse(message), uuid = response.uuid, onloadCallback;\n                if (uuid && onloadCallbacks[uuid]) {\n                    log(\"Handling response for iframe name \" + iframeName);\n                    clearTimeout(postMessageCallbackTimers[iframeName]);\n                    delete postMessageCallbackTimers[iframeName];\n                    handler._detachLoadEvent(iframeName);\n                    onloadCallback = onloadCallbacks[uuid];\n                    delete onloadCallbacks[uuid];\n                    corsMessageReceiver.stopReceivingMessages(iframeName);\n                    onloadCallback(response);\n                } else if (!uuid) {\n                    log(\"'\" + message + \"' does not contain a UUID - ignoring.\");\n                }\n            });\n        }\n        qq.extend(this, new qq.UploadHandler(spec));\n        qq.override(this, function(super_) {\n            return {\n                add: function(id, fileInput) {\n                    super_.add(id, {\n                        input: fileInput\n                    });\n                    fileInput.setAttribute(\"name\", inputName);\n                    if (fileInput.parentNode) {\n                        qq(fileInput).remove();\n                    }\n                },\n                expunge: function(id) {\n                    expungeFile(id);\n                    super_.expunge(id);\n                },\n                isValid: function(id) {\n                    return super_.isValid(id) && handler._getFileState(id).input !== undefined;\n                }\n            };\n        });\n        qq.extend(this, {\n            getInput: function(id) {\n                return handler._getFileState(id).input;\n            },\n            _attachLoadEvent: function(iframe, callback) {\n                var responseDescriptor;\n                if (isCors) {\n                    registerPostMessageCallback(iframe, callback);\n                } else {\n                    detachLoadEvents[iframe.id] = qq(iframe).attach(\"load\", function() {\n                        log(\"Received response for \" + iframe.id);\n                        if (!iframe.parentNode) {\n                            return;\n                        }\n                        try {\n                            if (iframe.contentDocument && iframe.contentDocument.body && iframe.contentDocument.body.innerHTML == \"false\") {\n                                return;\n                            }\n                        } catch (error) {\n                            log(\"Error when attempting to access iframe during handling of upload response (\" + error.message + \")\", \"error\");\n                            responseDescriptor = {\n                                success: false\n                            };\n                        }\n                        callback(responseDescriptor);\n                    });\n                }\n            },\n            _createIframe: function(id) {\n                var iframeName = handler._getIframeName(id);\n                return initIframeForUpload(iframeName);\n            },\n            _detachLoadEvent: function(id) {\n                if (detachLoadEvents[id] !== undefined) {\n                    detachLoadEvents[id]();\n                    delete detachLoadEvents[id];\n                }\n            },\n            _getIframeName: function(fileId) {\n                return fileId + \"_\" + formHandlerInstanceId;\n            },\n            _initFormForUpload: function(spec) {\n                var method = spec.method, endpoint = spec.endpoint, params = spec.params, paramsInBody = spec.paramsInBody, targetName = spec.targetName, form = qq.toElement(\"<form method='\" + method + \"' enctype='multipart/form-data'></form>\"), url = endpoint;\n                if (paramsInBody) {\n                    qq.obj2Inputs(params, form);\n                } else {\n                    url = qq.obj2url(params, endpoint);\n                }\n                form.setAttribute(\"action\", url);\n                form.setAttribute(\"target\", targetName);\n                form.style.display = \"none\";\n                document.body.appendChild(form);\n                return form;\n            },\n            _parseJsonResponse: function(innerHtmlOrMessage) {\n                var response = {};\n                try {\n                    response = qq.parseJson(innerHtmlOrMessage);\n                } catch (error) {\n                    log(\"Error when attempting to parse iframe upload response (\" + error.message + \")\", \"error\");\n                }\n                return response;\n            }\n        });\n    };\n    qq.XhrUploadHandler = function(spec) {\n        \"use strict\";\n        var handler = this, namespace = spec.options.namespace, proxy = spec.proxy, chunking = spec.options.chunking, getChunkSize = function(id) {\n            var fileState = handler._getFileState(id);\n            if (fileState.chunkSize) {\n                return fileState.chunkSize;\n            } else {\n                var chunkSize = chunking.partSize;\n                if (qq.isFunction(chunkSize)) {\n                    chunkSize = chunkSize(id, getSize(id));\n                }\n                fileState.chunkSize = chunkSize;\n                return chunkSize;\n            }\n        }, resume = spec.options.resume, chunkFiles = chunking && spec.options.chunking.enabled && qq.supportedFeatures.chunking, resumeEnabled = resume && spec.options.resume.enabled && chunkFiles && qq.supportedFeatures.resume, getName = proxy.getName, getSize = proxy.getSize, getUuid = proxy.getUuid, getEndpoint = proxy.getEndpoint, getDataByUuid = proxy.getDataByUuid, onUuidChanged = proxy.onUuidChanged, onProgress = proxy.onProgress, log = proxy.log, getCustomResumeData = proxy.getCustomResumeData;\n        function abort(id) {\n            qq.each(handler._getXhrs(id), function(xhrId, xhr) {\n                var ajaxRequester = handler._getAjaxRequester(id, xhrId);\n                xhr.onreadystatechange = null;\n                xhr.upload.onprogress = null;\n                xhr.abort();\n                ajaxRequester && ajaxRequester.canceled && ajaxRequester.canceled(id);\n            });\n        }\n        qq.extend(this, new qq.UploadHandler(spec));\n        qq.override(this, function(super_) {\n            return {\n                add: function(id, blobOrProxy) {\n                    if (qq.isFile(blobOrProxy) || qq.isBlob(blobOrProxy)) {\n                        super_.add(id, {\n                            file: blobOrProxy\n                        });\n                    } else if (blobOrProxy instanceof qq.BlobProxy) {\n                        super_.add(id, {\n                            proxy: blobOrProxy\n                        });\n                    } else {\n                        throw new Error(\"Passed obj is not a File, Blob, or proxy\");\n                    }\n                    handler._initTempState(id);\n                    resumeEnabled && handler._maybePrepareForResume(id);\n                },\n                expunge: function(id) {\n                    abort(id);\n                    handler._maybeDeletePersistedChunkData(id);\n                    handler._clearXhrs(id);\n                    super_.expunge(id);\n                }\n            };\n        });\n        qq.extend(this, {\n            clearCachedChunk: function(id, chunkIdx) {\n                var fileState = handler._getFileState(id);\n                if (fileState) {\n                    delete fileState.temp.cachedChunks[chunkIdx];\n                }\n            },\n            clearXhr: function(id, chunkIdx) {\n                var tempState = handler._getFileState(id).temp;\n                if (tempState.xhrs) {\n                    delete tempState.xhrs[chunkIdx];\n                }\n                if (tempState.ajaxRequesters) {\n                    delete tempState.ajaxRequesters[chunkIdx];\n                }\n            },\n            finalizeChunks: function(id, responseParser) {\n                var lastChunkIdx = handler._getTotalChunks(id) - 1, xhr = handler._getXhr(id, lastChunkIdx);\n                if (responseParser) {\n                    return new qq.Promise().success(responseParser(xhr), xhr);\n                }\n                return new qq.Promise().success({}, xhr);\n            },\n            getFile: function(id) {\n                return handler.isValid(id) && handler._getFileState(id).file;\n            },\n            getProxy: function(id) {\n                return handler.isValid(id) && handler._getFileState(id).proxy;\n            },\n            getResumableFilesData: function() {\n                var resumableFilesData = [];\n                handler._iterateResumeRecords(function(key, uploadData) {\n                    handler.moveInProgressToRemaining(null, uploadData.chunking.inProgress, uploadData.chunking.remaining);\n                    var data = {\n                        name: uploadData.name,\n                        remaining: uploadData.chunking.remaining,\n                        size: uploadData.size,\n                        uuid: uploadData.uuid\n                    };\n                    if (uploadData.key) {\n                        data.key = uploadData.key;\n                    }\n                    if (uploadData.customResumeData) {\n                        data.customResumeData = uploadData.customResumeData;\n                    }\n                    resumableFilesData.push(data);\n                });\n                return resumableFilesData;\n            },\n            isAttemptingResume: function(id) {\n                return handler._getFileState(id).attemptingResume;\n            },\n            isResumable: function(id) {\n                return !!chunking && handler.isValid(id) && !handler._getFileState(id).notResumable;\n            },\n            moveInProgressToRemaining: function(id, optInProgress, optRemaining) {\n                var fileState = handler._getFileState(id) || {}, chunkingState = fileState.chunking || {}, inProgress = optInProgress || chunkingState.inProgress, remaining = optRemaining || chunkingState.remaining;\n                if (inProgress) {\n                    log(qq.format(\"Moving these chunks from in-progress {}, to remaining.\", JSON.stringify(inProgress)));\n                    inProgress.reverse();\n                    qq.each(inProgress, function(idx, chunkIdx) {\n                        remaining.unshift(chunkIdx);\n                    });\n                    inProgress.length = 0;\n                }\n            },\n            pause: function(id) {\n                if (handler.isValid(id)) {\n                    log(qq.format(\"Aborting XHR upload for {} '{}' due to pause instruction.\", id, getName(id)));\n                    handler._getFileState(id).paused = true;\n                    abort(id);\n                    return true;\n                }\n            },\n            reevaluateChunking: function(id) {\n                if (chunking && handler.isValid(id)) {\n                    var state = handler._getFileState(id), totalChunks, i;\n                    delete state.chunking;\n                    state.chunking = {};\n                    totalChunks = handler._getTotalChunks(id);\n                    if (totalChunks > 1 || chunking.mandatory) {\n                        state.chunking.enabled = true;\n                        state.chunking.parts = totalChunks;\n                        state.chunking.remaining = [];\n                        for (i = 0; i < totalChunks; i++) {\n                            state.chunking.remaining.push(i);\n                        }\n                        handler._initTempState(id);\n                    } else {\n                        state.chunking.enabled = false;\n                    }\n                }\n            },\n            updateBlob: function(id, newBlob) {\n                if (handler.isValid(id)) {\n                    handler._getFileState(id).file = newBlob;\n                }\n            },\n            _clearXhrs: function(id) {\n                var tempState = handler._getFileState(id).temp;\n                qq.each(tempState.ajaxRequesters, function(chunkId) {\n                    delete tempState.ajaxRequesters[chunkId];\n                });\n                qq.each(tempState.xhrs, function(chunkId) {\n                    delete tempState.xhrs[chunkId];\n                });\n            },\n            _createXhr: function(id, optChunkIdx) {\n                return handler._registerXhr(id, optChunkIdx, qq.createXhrInstance());\n            },\n            _getAjaxRequester: function(id, optChunkIdx) {\n                var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n                return handler._getFileState(id).temp.ajaxRequesters[chunkIdx];\n            },\n            _getChunkData: function(id, chunkIndex) {\n                var chunkSize = getChunkSize(id), fileSize = getSize(id), fileOrBlob = handler.getFile(id), startBytes = chunkSize * chunkIndex, endBytes = startBytes + chunkSize >= fileSize ? fileSize : startBytes + chunkSize, totalChunks = handler._getTotalChunks(id), cachedChunks = this._getFileState(id).temp.cachedChunks, blob = cachedChunks[chunkIndex] || qq.sliceBlob(fileOrBlob, startBytes, endBytes);\n                cachedChunks[chunkIndex] = blob;\n                return {\n                    part: chunkIndex,\n                    start: startBytes,\n                    end: endBytes,\n                    count: totalChunks,\n                    blob: blob,\n                    size: endBytes - startBytes\n                };\n            },\n            _getChunkDataForCallback: function(chunkData) {\n                return {\n                    partIndex: chunkData.part,\n                    startByte: chunkData.start + 1,\n                    endByte: chunkData.end,\n                    totalParts: chunkData.count\n                };\n            },\n            _getLocalStorageId: function(id) {\n                var formatVersion = \"5.0\", name = getName(id), size = getSize(id), chunkSize = getChunkSize(id), endpoint = getEndpoint(id), customKeys = resume.customKeys(id), localStorageId = qq.format(\"qq{}resume{}-{}-{}-{}-{}\", namespace, formatVersion, name, size, chunkSize, endpoint);\n                customKeys.forEach(function(key) {\n                    localStorageId += \"-\" + key;\n                });\n                return localStorageId;\n            },\n            _getMimeType: function(id) {\n                return handler.getFile(id).type;\n            },\n            _getPersistableData: function(id) {\n                return handler._getFileState(id).chunking;\n            },\n            _getTotalChunks: function(id) {\n                if (chunking) {\n                    var fileSize = getSize(id), chunkSize = getChunkSize(id);\n                    return Math.ceil(fileSize / chunkSize);\n                }\n            },\n            _getXhr: function(id, optChunkIdx) {\n                var chunkIdx = optChunkIdx == null ? -1 : optChunkIdx;\n                return handler._getFileState(id).temp.xhrs[chunkIdx];\n            },\n            _getXhrs: function(id) {\n                return handler._getFileState(id).temp.xhrs;\n            },\n            _iterateResumeRecords: function(callback) {\n                if (resumeEnabled) {\n                    qq.each(localStorage, function(key, item) {\n                        if (key.indexOf(qq.format(\"qq{}resume\", namespace)) === 0) {\n                            var uploadData = JSON.parse(item);\n                            callback(key, uploadData);\n                        }\n                    });\n                }\n            },\n            _initTempState: function(id) {\n                handler._getFileState(id).temp = {\n                    ajaxRequesters: {},\n                    chunkProgress: {},\n                    xhrs: {},\n                    cachedChunks: {}\n                };\n            },\n            _markNotResumable: function(id) {\n                handler._getFileState(id).notResumable = true;\n            },\n            _maybeDeletePersistedChunkData: function(id) {\n                var localStorageId;\n                if (resumeEnabled && handler.isResumable(id)) {\n                    localStorageId = handler._getLocalStorageId(id);\n                    if (localStorageId && localStorage.getItem(localStorageId)) {\n                        localStorage.removeItem(localStorageId);\n                        return true;\n                    }\n                }\n                return false;\n            },\n            _maybePrepareForResume: function(id) {\n                var state = handler._getFileState(id), localStorageId, persistedData;\n                if (resumeEnabled && state.key === undefined) {\n                    localStorageId = handler._getLocalStorageId(id);\n                    persistedData = localStorage.getItem(localStorageId);\n                    if (persistedData) {\n                        persistedData = JSON.parse(persistedData);\n                        if (getDataByUuid(persistedData.uuid)) {\n                            handler._markNotResumable(id);\n                        } else {\n                            log(qq.format(\"Identified file with ID {} and name of {} as resumable.\", id, getName(id)));\n                            onUuidChanged(id, persistedData.uuid);\n                            state.key = persistedData.key;\n                            state.chunking = persistedData.chunking;\n                            state.loaded = persistedData.loaded;\n                            state.customResumeData = persistedData.customResumeData;\n                            state.attemptingResume = true;\n                            handler.moveInProgressToRemaining(id);\n                        }\n                    }\n                }\n            },\n            _maybePersistChunkedState: function(id) {\n                var state = handler._getFileState(id), localStorageId, persistedData;\n                if (resumeEnabled && handler.isResumable(id)) {\n                    var customResumeData = getCustomResumeData(id);\n                    localStorageId = handler._getLocalStorageId(id);\n                    persistedData = {\n                        name: getName(id),\n                        size: getSize(id),\n                        uuid: getUuid(id),\n                        key: state.key,\n                        chunking: state.chunking,\n                        loaded: state.loaded,\n                        lastUpdated: Date.now()\n                    };\n                    if (customResumeData) {\n                        persistedData.customResumeData = customResumeData;\n                    }\n                    try {\n                        localStorage.setItem(localStorageId, JSON.stringify(persistedData));\n                    } catch (error) {\n                        log(qq.format(\"Unable to save resume data for '{}' due to error: '{}'.\", id, error.toString()), \"warn\");\n                    }\n                }\n            },\n            _registerProgressHandler: function(id, chunkIdx, chunkSize) {\n                var xhr = handler._getXhr(id, chunkIdx), name = getName(id), progressCalculator = {\n                    simple: function(loaded, total) {\n                        var fileSize = getSize(id);\n                        if (loaded === total) {\n                            onProgress(id, name, fileSize, fileSize);\n                        } else {\n                            onProgress(id, name, loaded >= fileSize ? fileSize - 1 : loaded, fileSize);\n                        }\n                    },\n                    chunked: function(loaded, total) {\n                        var chunkProgress = handler._getFileState(id).temp.chunkProgress, totalSuccessfullyLoadedForFile = handler._getFileState(id).loaded, loadedForRequest = loaded, totalForRequest = total, totalFileSize = getSize(id), estActualChunkLoaded = loadedForRequest - (totalForRequest - chunkSize), totalLoadedForFile = totalSuccessfullyLoadedForFile;\n                        chunkProgress[chunkIdx] = estActualChunkLoaded;\n                        qq.each(chunkProgress, function(chunkIdx, chunkLoaded) {\n                            totalLoadedForFile += chunkLoaded;\n                        });\n                        onProgress(id, name, totalLoadedForFile, totalFileSize);\n                    }\n                };\n                xhr.upload.onprogress = function(e) {\n                    if (e.lengthComputable) {\n                        var type = chunkSize == null ? \"simple\" : \"chunked\";\n                        progressCalculator[type](e.loaded, e.total);\n                    }\n                };\n            },\n            _registerXhr: function(id, optChunkIdx, xhr, optAjaxRequester) {\n                var xhrsId = optChunkIdx == null ? -1 : optChunkIdx, tempState = handler._getFileState(id).temp;\n                tempState.xhrs = tempState.xhrs || {};\n                tempState.ajaxRequesters = tempState.ajaxRequesters || {};\n                tempState.xhrs[xhrsId] = xhr;\n                if (optAjaxRequester) {\n                    tempState.ajaxRequesters[xhrsId] = optAjaxRequester;\n                }\n                return xhr;\n            },\n            _removeExpiredChunkingRecords: function() {\n                var expirationDays = resume.recordsExpireIn;\n                handler._iterateResumeRecords(function(key, uploadData) {\n                    var expirationDate = new Date(uploadData.lastUpdated);\n                    expirationDate.setDate(expirationDate.getDate() + expirationDays);\n                    if (expirationDate.getTime() <= Date.now()) {\n                        log(\"Removing expired resume record with key \" + key);\n                        localStorage.removeItem(key);\n                    }\n                });\n            },\n            _shouldChunkThisFile: function(id) {\n                var state = handler._getFileState(id);\n                if (state) {\n                    if (!state.chunking) {\n                        handler.reevaluateChunking(id);\n                    }\n                    return state.chunking.enabled;\n                }\n            }\n        });\n    };\n    qq.DeleteFileAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, options = {\n            method: \"DELETE\",\n            uuidParamName: \"qquuid\",\n            endpointStore: {},\n            maxConnections: 3,\n            customHeaders: function(id) {\n                return {};\n            },\n            paramsStore: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            log: function(str, level) {},\n            onDelete: function(id) {},\n            onDeleteComplete: function(id, xhrOrXdr, isError) {}\n        };\n        qq.extend(options, o);\n        function getMandatedParams() {\n            if (options.method.toUpperCase() === \"POST\") {\n                return {\n                    _method: \"DELETE\"\n                };\n            }\n            return {};\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            validMethods: [ \"POST\", \"DELETE\" ],\n            method: options.method,\n            endpointStore: options.endpointStore,\n            paramsStore: options.paramsStore,\n            mandatedParams: getMandatedParams(),\n            maxConnections: options.maxConnections,\n            customHeaders: function(id) {\n                return options.customHeaders.get(id);\n            },\n            log: options.log,\n            onSend: options.onDelete,\n            onComplete: options.onDeleteComplete,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            sendDelete: function(id, uuid, additionalMandatedParams) {\n                var additionalOptions = additionalMandatedParams || {};\n                options.log(\"Submitting delete file request for \" + id);\n                if (options.method === \"DELETE\") {\n                    requester.initTransport(id).withPath(uuid).withParams(additionalOptions).send();\n                } else {\n                    additionalOptions[options.uuidParamName] = uuid;\n                    requester.initTransport(id).withParams(additionalOptions).send();\n                }\n            }\n        });\n    };\n    (function() {\n        function detectSubsampling(img) {\n            var iw = img.naturalWidth, ih = img.naturalHeight, canvas = document.createElement(\"canvas\"), ctx;\n            if (iw * ih > 1024 * 1024) {\n                canvas.width = canvas.height = 1;\n                ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(img, -iw + 1, 0);\n                return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n            } else {\n                return false;\n            }\n        }\n        function detectVerticalSquash(img, iw, ih) {\n            var canvas = document.createElement(\"canvas\"), sy = 0, ey = ih, py = ih, ctx, data, alpha, ratio;\n            canvas.width = 1;\n            canvas.height = ih;\n            ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(img, 0, 0);\n            data = ctx.getImageData(0, 0, 1, ih).data;\n            while (py > sy) {\n                alpha = data[(py - 1) * 4 + 3];\n                if (alpha === 0) {\n                    ey = py;\n                } else {\n                    sy = py;\n                }\n                py = ey + sy >> 1;\n            }\n            ratio = py / ih;\n            return ratio === 0 ? 1 : ratio;\n        }\n        function renderImageToDataURL(img, blob, options, doSquash) {\n            var canvas = document.createElement(\"canvas\"), mime = options.mime || \"image/jpeg\", promise = new qq.Promise();\n            renderImageToCanvas(img, blob, canvas, options, doSquash).then(function() {\n                promise.success(canvas.toDataURL(mime, options.quality || .8));\n            });\n            return promise;\n        }\n        function maybeCalculateDownsampledDimensions(spec) {\n            var maxPixels = 5241e3;\n            if (!qq.ios()) {\n                throw new qq.Error(\"Downsampled dimensions can only be reliably calculated for iOS!\");\n            }\n            if (spec.origHeight * spec.origWidth > maxPixels) {\n                return {\n                    newHeight: Math.round(Math.sqrt(maxPixels * (spec.origHeight / spec.origWidth))),\n                    newWidth: Math.round(Math.sqrt(maxPixels * (spec.origWidth / spec.origHeight)))\n                };\n            }\n        }\n        function renderImageToCanvas(img, blob, canvas, options, doSquash) {\n            var iw = img.naturalWidth, ih = img.naturalHeight, width = options.width, height = options.height, ctx = canvas.getContext(\"2d\"), promise = new qq.Promise(), modifiedDimensions;\n            ctx.save();\n            if (options.resize) {\n                return renderImageToCanvasWithCustomResizer({\n                    blob: blob,\n                    canvas: canvas,\n                    image: img,\n                    imageHeight: ih,\n                    imageWidth: iw,\n                    orientation: options.orientation,\n                    resize: options.resize,\n                    targetHeight: height,\n                    targetWidth: width\n                });\n            }\n            if (!qq.supportedFeatures.unlimitedScaledImageSize) {\n                modifiedDimensions = maybeCalculateDownsampledDimensions({\n                    origWidth: width,\n                    origHeight: height\n                });\n                if (modifiedDimensions) {\n                    qq.log(qq.format(\"Had to reduce dimensions due to device limitations from {}w / {}h to {}w / {}h\", width, height, modifiedDimensions.newWidth, modifiedDimensions.newHeight), \"warn\");\n                    width = modifiedDimensions.newWidth;\n                    height = modifiedDimensions.newHeight;\n                }\n            }\n            transformCoordinate(canvas, width, height, options.orientation);\n            if (qq.ios()) {\n                (function() {\n                    if (detectSubsampling(img)) {\n                        iw /= 2;\n                        ih /= 2;\n                    }\n                    var d = 1024, tmpCanvas = document.createElement(\"canvas\"), vertSquashRatio = doSquash ? detectVerticalSquash(img, iw, ih) : 1, dw = Math.ceil(d * width / iw), dh = Math.ceil(d * height / ih / vertSquashRatio), sy = 0, dy = 0, tmpCtx, sx, dx;\n                    tmpCanvas.width = tmpCanvas.height = d;\n                    tmpCtx = tmpCanvas.getContext(\"2d\");\n                    while (sy < ih) {\n                        sx = 0;\n                        dx = 0;\n                        while (sx < iw) {\n                            tmpCtx.clearRect(0, 0, d, d);\n                            tmpCtx.drawImage(img, -sx, -sy);\n                            ctx.drawImage(tmpCanvas, 0, 0, d, d, dx, dy, dw, dh);\n                            sx += d;\n                            dx += dw;\n                        }\n                        sy += d;\n                        dy += dh;\n                    }\n                    ctx.restore();\n                    tmpCanvas = tmpCtx = null;\n                })();\n            } else {\n                ctx.drawImage(img, 0, 0, width, height);\n            }\n            canvas.qqImageRendered && canvas.qqImageRendered();\n            promise.success();\n            return promise;\n        }\n        function renderImageToCanvasWithCustomResizer(resizeInfo) {\n            var blob = resizeInfo.blob, image = resizeInfo.image, imageHeight = resizeInfo.imageHeight, imageWidth = resizeInfo.imageWidth, orientation = resizeInfo.orientation, promise = new qq.Promise(), resize = resizeInfo.resize, sourceCanvas = document.createElement(\"canvas\"), sourceCanvasContext = sourceCanvas.getContext(\"2d\"), targetCanvas = resizeInfo.canvas, targetHeight = resizeInfo.targetHeight, targetWidth = resizeInfo.targetWidth;\n            transformCoordinate(sourceCanvas, imageWidth, imageHeight, orientation);\n            targetCanvas.height = targetHeight;\n            targetCanvas.width = targetWidth;\n            sourceCanvasContext.drawImage(image, 0, 0);\n            resize({\n                blob: blob,\n                height: targetHeight,\n                image: image,\n                sourceCanvas: sourceCanvas,\n                targetCanvas: targetCanvas,\n                width: targetWidth\n            }).then(function success() {\n                targetCanvas.qqImageRendered && targetCanvas.qqImageRendered();\n                promise.success();\n            }, promise.failure);\n            return promise;\n        }\n        function transformCoordinate(canvas, width, height, orientation) {\n            switch (orientation) {\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n                canvas.width = height;\n                canvas.height = width;\n                break;\n\n              default:\n                canvas.width = width;\n                canvas.height = height;\n            }\n            var ctx = canvas.getContext(\"2d\");\n            switch (orientation) {\n              case 2:\n                ctx.translate(width, 0);\n                ctx.scale(-1, 1);\n                break;\n\n              case 3:\n                ctx.translate(width, height);\n                ctx.rotate(Math.PI);\n                break;\n\n              case 4:\n                ctx.translate(0, height);\n                ctx.scale(1, -1);\n                break;\n\n              case 5:\n                ctx.rotate(.5 * Math.PI);\n                ctx.scale(1, -1);\n                break;\n\n              case 6:\n                ctx.rotate(.5 * Math.PI);\n                ctx.translate(0, -height);\n                break;\n\n              case 7:\n                ctx.rotate(.5 * Math.PI);\n                ctx.translate(width, -height);\n                ctx.scale(-1, 1);\n                break;\n\n              case 8:\n                ctx.rotate(-.5 * Math.PI);\n                ctx.translate(-width, 0);\n                break;\n\n              default:\n                break;\n            }\n        }\n        function MegaPixImage(srcImage, errorCallback) {\n            var self = this;\n            if (window.Blob && srcImage instanceof Blob) {\n                (function() {\n                    var img = new Image(), URL = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n                    if (!URL) {\n                        throw Error(\"No createObjectURL function found to create blob url\");\n                    }\n                    img.src = URL.createObjectURL(srcImage);\n                    self.blob = srcImage;\n                    srcImage = img;\n                })();\n            }\n            if (!srcImage.naturalWidth && !srcImage.naturalHeight) {\n                srcImage.onload = function() {\n                    var listeners = self.imageLoadListeners;\n                    if (listeners) {\n                        self.imageLoadListeners = null;\n                        setTimeout(function() {\n                            for (var i = 0, len = listeners.length; i < len; i++) {\n                                listeners[i]();\n                            }\n                        }, 0);\n                    }\n                };\n                srcImage.onerror = errorCallback;\n                this.imageLoadListeners = [];\n            }\n            this.srcImage = srcImage;\n        }\n        MegaPixImage.prototype.render = function(target, options) {\n            options = options || {};\n            var self = this, imgWidth = this.srcImage.naturalWidth, imgHeight = this.srcImage.naturalHeight, width = options.width, height = options.height, maxWidth = options.maxWidth, maxHeight = options.maxHeight, doSquash = !this.blob || this.blob.type === \"image/jpeg\", tagName = target.tagName.toLowerCase(), opt;\n            if (this.imageLoadListeners) {\n                this.imageLoadListeners.push(function() {\n                    self.render(target, options);\n                });\n                return;\n            }\n            if (width && !height) {\n                height = imgHeight * width / imgWidth << 0;\n            } else if (height && !width) {\n                width = imgWidth * height / imgHeight << 0;\n            } else {\n                width = imgWidth;\n                height = imgHeight;\n            }\n            if (maxWidth && width > maxWidth) {\n                width = maxWidth;\n                height = imgHeight * width / imgWidth << 0;\n            }\n            if (maxHeight && height > maxHeight) {\n                height = maxHeight;\n                width = imgWidth * height / imgHeight << 0;\n            }\n            opt = {\n                width: width,\n                height: height\n            }, qq.each(options, function(optionsKey, optionsValue) {\n                opt[optionsKey] = optionsValue;\n            });\n            if (tagName === \"img\") {\n                (function() {\n                    var oldTargetSrc = target.src;\n                    renderImageToDataURL(self.srcImage, self.blob, opt, doSquash).then(function(dataUri) {\n                        target.src = dataUri;\n                        oldTargetSrc === target.src && target.onload();\n                    });\n                })();\n            } else if (tagName === \"canvas\") {\n                renderImageToCanvas(this.srcImage, this.blob, target, opt, doSquash);\n            }\n            if (typeof this.onrender === \"function\") {\n                this.onrender(target);\n            }\n        };\n        qq.MegaPixImage = MegaPixImage;\n    })();\n    qq.ImageGenerator = function(log) {\n        \"use strict\";\n        function isImg(el) {\n            return el.tagName.toLowerCase() === \"img\";\n        }\n        function isCanvas(el) {\n            return el.tagName.toLowerCase() === \"canvas\";\n        }\n        function isImgCorsSupported() {\n            return new Image().crossOrigin !== undefined;\n        }\n        function isCanvasSupported() {\n            var canvas = document.createElement(\"canvas\");\n            return canvas.getContext && canvas.getContext(\"2d\");\n        }\n        function determineMimeOfFileName(nameWithPath) {\n            var pathSegments = nameWithPath.split(\"/\"), name = pathSegments[pathSegments.length - 1].split(\"?\")[0], extension = qq.getExtension(name);\n            extension = extension && extension.toLowerCase();\n            switch (extension) {\n              case \"jpeg\":\n              case \"jpg\":\n                return \"image/jpeg\";\n\n              case \"png\":\n                return \"image/png\";\n\n              case \"bmp\":\n                return \"image/bmp\";\n\n              case \"gif\":\n                return \"image/gif\";\n\n              case \"tiff\":\n              case \"tif\":\n                return \"image/tiff\";\n            }\n        }\n        function isCrossOrigin(url) {\n            var targetAnchor = document.createElement(\"a\"), targetProtocol, targetHostname, targetPort;\n            targetAnchor.href = url;\n            targetProtocol = targetAnchor.protocol;\n            targetPort = targetAnchor.port;\n            targetHostname = targetAnchor.hostname;\n            if (targetProtocol.toLowerCase() !== window.location.protocol.toLowerCase()) {\n                return true;\n            }\n            if (targetHostname.toLowerCase() !== window.location.hostname.toLowerCase()) {\n                return true;\n            }\n            if (targetPort !== window.location.port && !qq.ie()) {\n                return true;\n            }\n            return false;\n        }\n        function registerImgLoadListeners(img, promise) {\n            img.onload = function() {\n                img.onload = null;\n                img.onerror = null;\n                promise.success(img);\n            };\n            img.onerror = function() {\n                img.onload = null;\n                img.onerror = null;\n                log(\"Problem drawing thumbnail!\", \"error\");\n                promise.failure(img, \"Problem drawing thumbnail!\");\n            };\n        }\n        function registerCanvasDrawImageListener(canvas, promise) {\n            canvas.qqImageRendered = function() {\n                promise.success(canvas);\n            };\n        }\n        function registerThumbnailRenderedListener(imgOrCanvas, promise) {\n            var registered = isImg(imgOrCanvas) || isCanvas(imgOrCanvas);\n            if (isImg(imgOrCanvas)) {\n                registerImgLoadListeners(imgOrCanvas, promise);\n            } else if (isCanvas(imgOrCanvas)) {\n                registerCanvasDrawImageListener(imgOrCanvas, promise);\n            } else {\n                promise.failure(imgOrCanvas);\n                log(qq.format(\"Element container of type {} is not supported!\", imgOrCanvas.tagName), \"error\");\n            }\n            return registered;\n        }\n        function draw(fileOrBlob, container, options) {\n            var drawPreview = new qq.Promise(), identifier = new qq.Identify(fileOrBlob, log), maxSize = options.maxSize, orient = options.orient == null ? true : options.orient, megapixErrorHandler = function() {\n                container.onerror = null;\n                container.onload = null;\n                log(\"Could not render preview, file may be too large!\", \"error\");\n                drawPreview.failure(container, \"Browser cannot render image!\");\n            };\n            identifier.isPreviewable().then(function(mime) {\n                var dummyExif = {\n                    parse: function() {\n                        return new qq.Promise().success();\n                    }\n                }, exif = orient ? new qq.Exif(fileOrBlob, log) : dummyExif, mpImg = new qq.MegaPixImage(fileOrBlob, megapixErrorHandler);\n                if (registerThumbnailRenderedListener(container, drawPreview)) {\n                    exif.parse().then(function(exif) {\n                        var orientation = exif && exif.Orientation;\n                        mpImg.render(container, {\n                            maxWidth: maxSize,\n                            maxHeight: maxSize,\n                            orientation: orientation,\n                            mime: mime,\n                            resize: options.customResizeFunction\n                        });\n                    }, function(failureMsg) {\n                        log(qq.format(\"EXIF data could not be parsed ({}).  Assuming orientation = 1.\", failureMsg));\n                        mpImg.render(container, {\n                            maxWidth: maxSize,\n                            maxHeight: maxSize,\n                            mime: mime,\n                            resize: options.customResizeFunction\n                        });\n                    });\n                }\n            }, function() {\n                log(\"Not previewable\");\n                drawPreview.failure(container, \"Not previewable\");\n            });\n            return drawPreview;\n        }\n        function drawOnCanvasOrImgFromUrl(url, canvasOrImg, draw, maxSize, customResizeFunction) {\n            var tempImg = new Image(), tempImgRender = new qq.Promise();\n            registerThumbnailRenderedListener(tempImg, tempImgRender);\n            if (isCrossOrigin(url)) {\n                tempImg.crossOrigin = \"anonymous\";\n            }\n            tempImg.src = url;\n            tempImgRender.then(function rendered() {\n                registerThumbnailRenderedListener(canvasOrImg, draw);\n                var mpImg = new qq.MegaPixImage(tempImg);\n                mpImg.render(canvasOrImg, {\n                    maxWidth: maxSize,\n                    maxHeight: maxSize,\n                    mime: determineMimeOfFileName(url),\n                    resize: customResizeFunction\n                });\n            }, draw.failure);\n        }\n        function drawOnImgFromUrlWithCssScaling(url, img, draw, maxSize) {\n            registerThumbnailRenderedListener(img, draw);\n            qq(img).css({\n                maxWidth: maxSize + \"px\",\n                maxHeight: maxSize + \"px\"\n            });\n            img.src = url;\n        }\n        function drawFromUrl(url, container, options) {\n            var draw = new qq.Promise(), scale = options.scale, maxSize = scale ? options.maxSize : null;\n            if (scale && isImg(container)) {\n                if (isCanvasSupported()) {\n                    if (isCrossOrigin(url) && !isImgCorsSupported()) {\n                        drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n                    } else {\n                        drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n                    }\n                } else {\n                    drawOnImgFromUrlWithCssScaling(url, container, draw, maxSize);\n                }\n            } else if (isCanvas(container)) {\n                drawOnCanvasOrImgFromUrl(url, container, draw, maxSize);\n            } else if (registerThumbnailRenderedListener(container, draw)) {\n                container.src = url;\n            }\n            return draw;\n        }\n        qq.extend(this, {\n            generate: function(fileBlobOrUrl, container, options) {\n                if (qq.isString(fileBlobOrUrl)) {\n                    log(\"Attempting to update thumbnail based on server response.\");\n                    return drawFromUrl(fileBlobOrUrl, container, options || {});\n                } else {\n                    log(\"Attempting to draw client-side image preview.\");\n                    return draw(fileBlobOrUrl, container, options || {});\n                }\n            }\n        });\n        this._testing = {};\n        this._testing.isImg = isImg;\n        this._testing.isCanvas = isCanvas;\n        this._testing.isCrossOrigin = isCrossOrigin;\n        this._testing.determineMimeOfFileName = determineMimeOfFileName;\n    };\n    qq.Exif = function(fileOrBlob, log) {\n        \"use strict\";\n        var TAG_IDS = [ 274 ], TAG_INFO = {\n            274: {\n                name: \"Orientation\",\n                bytes: 2\n            }\n        };\n        function parseLittleEndian(hex) {\n            var result = 0, pow = 0;\n            while (hex.length > 0) {\n                result += parseInt(hex.substring(0, 2), 16) * Math.pow(2, pow);\n                hex = hex.substring(2, hex.length);\n                pow += 8;\n            }\n            return result;\n        }\n        function seekToApp1(offset, promise) {\n            var theOffset = offset, thePromise = promise;\n            if (theOffset === undefined) {\n                theOffset = 2;\n                thePromise = new qq.Promise();\n            }\n            qq.readBlobToHex(fileOrBlob, theOffset, 4).then(function(hex) {\n                var match = /^ffe([0-9])/.exec(hex), segmentLength;\n                if (match) {\n                    if (match[1] !== \"1\") {\n                        segmentLength = parseInt(hex.slice(4, 8), 16);\n                        seekToApp1(theOffset + segmentLength + 2, thePromise);\n                    } else {\n                        thePromise.success(theOffset);\n                    }\n                } else {\n                    thePromise.failure(\"No EXIF header to be found!\");\n                }\n            });\n            return thePromise;\n        }\n        function getApp1Offset() {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, 0, 6).then(function(hex) {\n                if (hex.indexOf(\"ffd8\") !== 0) {\n                    promise.failure(\"Not a valid JPEG!\");\n                } else {\n                    seekToApp1().then(function(offset) {\n                        promise.success(offset);\n                    }, function(error) {\n                        promise.failure(error);\n                    });\n                }\n            });\n            return promise;\n        }\n        function isLittleEndian(app1Start) {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, app1Start + 10, 2).then(function(hex) {\n                promise.success(hex === \"4949\");\n            });\n            return promise;\n        }\n        function getDirEntryCount(app1Start, littleEndian) {\n            var promise = new qq.Promise();\n            qq.readBlobToHex(fileOrBlob, app1Start + 18, 2).then(function(hex) {\n                if (littleEndian) {\n                    return promise.success(parseLittleEndian(hex));\n                } else {\n                    promise.success(parseInt(hex, 16));\n                }\n            });\n            return promise;\n        }\n        function getIfd(app1Start, dirEntries) {\n            var offset = app1Start + 20, bytes = dirEntries * 12;\n            return qq.readBlobToHex(fileOrBlob, offset, bytes);\n        }\n        function getDirEntries(ifdHex) {\n            var entries = [], offset = 0;\n            while (offset + 24 <= ifdHex.length) {\n                entries.push(ifdHex.slice(offset, offset + 24));\n                offset += 24;\n            }\n            return entries;\n        }\n        function getTagValues(littleEndian, dirEntries) {\n            var TAG_VAL_OFFSET = 16, tagsToFind = qq.extend([], TAG_IDS), vals = {};\n            qq.each(dirEntries, function(idx, entry) {\n                var idHex = entry.slice(0, 4), id = littleEndian ? parseLittleEndian(idHex) : parseInt(idHex, 16), tagsToFindIdx = tagsToFind.indexOf(id), tagValHex, tagName, tagValLength;\n                if (tagsToFindIdx >= 0) {\n                    tagName = TAG_INFO[id].name;\n                    tagValLength = TAG_INFO[id].bytes;\n                    tagValHex = entry.slice(TAG_VAL_OFFSET, TAG_VAL_OFFSET + tagValLength * 2);\n                    vals[tagName] = littleEndian ? parseLittleEndian(tagValHex) : parseInt(tagValHex, 16);\n                    tagsToFind.splice(tagsToFindIdx, 1);\n                }\n                if (tagsToFind.length === 0) {\n                    return false;\n                }\n            });\n            return vals;\n        }\n        qq.extend(this, {\n            parse: function() {\n                var parser = new qq.Promise(), onParseFailure = function(message) {\n                    log(qq.format(\"EXIF header parse failed: '{}' \", message));\n                    parser.failure(message);\n                };\n                getApp1Offset().then(function(app1Offset) {\n                    log(qq.format(\"Moving forward with EXIF header parsing for '{}'\", fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name));\n                    isLittleEndian(app1Offset).then(function(littleEndian) {\n                        log(qq.format(\"EXIF Byte order is {} endian\", littleEndian ? \"little\" : \"big\"));\n                        getDirEntryCount(app1Offset, littleEndian).then(function(dirEntryCount) {\n                            log(qq.format(\"Found {} APP1 directory entries\", dirEntryCount));\n                            getIfd(app1Offset, dirEntryCount).then(function(ifdHex) {\n                                var dirEntries = getDirEntries(ifdHex), tagValues = getTagValues(littleEndian, dirEntries);\n                                log(\"Successfully parsed some EXIF tags\");\n                                parser.success(tagValues);\n                            }, onParseFailure);\n                        }, onParseFailure);\n                    }, onParseFailure);\n                }, onParseFailure);\n                return parser;\n            }\n        });\n        this._testing = {};\n        this._testing.parseLittleEndian = parseLittleEndian;\n    };\n    qq.Identify = function(fileOrBlob, log) {\n        \"use strict\";\n        function isIdentifiable(magicBytes, questionableBytes) {\n            var identifiable = false, magicBytesEntries = [].concat(magicBytes);\n            qq.each(magicBytesEntries, function(idx, magicBytesArrayEntry) {\n                if (questionableBytes.indexOf(magicBytesArrayEntry) === 0) {\n                    identifiable = true;\n                    return false;\n                }\n            });\n            return identifiable;\n        }\n        qq.extend(this, {\n            isPreviewable: function() {\n                var self = this, identifier = new qq.Promise(), previewable = false, name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n                log(qq.format(\"Attempting to determine if {} can be rendered in this browser\", name));\n                log(\"First pass: check type attribute of blob object.\");\n                if (this.isPreviewableSync()) {\n                    log(\"Second pass: check for magic bytes in file header.\");\n                    qq.readBlobToHex(fileOrBlob, 0, 4).then(function(hex) {\n                        qq.each(self.PREVIEWABLE_MIME_TYPES, function(mime, bytes) {\n                            if (isIdentifiable(bytes, hex)) {\n                                if (mime !== \"image/tiff\" || qq.supportedFeatures.tiffPreviews) {\n                                    previewable = true;\n                                    identifier.success(mime);\n                                }\n                                return false;\n                            }\n                        });\n                        log(qq.format(\"'{}' is {} able to be rendered in this browser\", name, previewable ? \"\" : \"NOT\"));\n                        if (!previewable) {\n                            identifier.failure();\n                        }\n                    }, function() {\n                        log(\"Error reading file w/ name '\" + name + \"'.  Not able to be rendered in this browser.\");\n                        identifier.failure();\n                    });\n                } else {\n                    identifier.failure();\n                }\n                return identifier;\n            },\n            isPreviewableSync: function() {\n                var fileMime = fileOrBlob.type, isRecognizedImage = qq.indexOf(Object.keys(this.PREVIEWABLE_MIME_TYPES), fileMime) >= 0, previewable = false, name = fileOrBlob.name === undefined ? \"blob\" : fileOrBlob.name;\n                if (isRecognizedImage) {\n                    if (fileMime === \"image/tiff\") {\n                        previewable = qq.supportedFeatures.tiffPreviews;\n                    } else {\n                        previewable = true;\n                    }\n                }\n                !previewable && log(name + \" is not previewable in this browser per the blob's type attr\");\n                return previewable;\n            }\n        });\n    };\n    qq.Identify.prototype.PREVIEWABLE_MIME_TYPES = {\n        \"image/jpeg\": \"ffd8ff\",\n        \"image/gif\": \"474946\",\n        \"image/png\": \"89504e\",\n        \"image/bmp\": \"424d\",\n        \"image/tiff\": [ \"49492a00\", \"4d4d002a\" ]\n    };\n    qq.ImageValidation = function(blob, log) {\n        \"use strict\";\n        function hasNonZeroLimits(limits) {\n            var atLeastOne = false;\n            qq.each(limits, function(limit, value) {\n                if (value > 0) {\n                    atLeastOne = true;\n                    return false;\n                }\n            });\n            return atLeastOne;\n        }\n        function getWidthHeight() {\n            var sizeDetermination = new qq.Promise();\n            new qq.Identify(blob, log).isPreviewable().then(function() {\n                var image = new Image(), url = window.URL && window.URL.createObjectURL ? window.URL : window.webkitURL && window.webkitURL.createObjectURL ? window.webkitURL : null;\n                if (url) {\n                    image.onerror = function() {\n                        log(\"Cannot determine dimensions for image.  May be too large.\", \"error\");\n                        sizeDetermination.failure();\n                    };\n                    image.onload = function() {\n                        sizeDetermination.success({\n                            width: this.width,\n                            height: this.height\n                        });\n                    };\n                    image.src = url.createObjectURL(blob);\n                } else {\n                    log(\"No createObjectURL function available to generate image URL!\", \"error\");\n                    sizeDetermination.failure();\n                }\n            }, sizeDetermination.failure);\n            return sizeDetermination;\n        }\n        function getFailingLimit(limits, dimensions) {\n            var failingLimit;\n            qq.each(limits, function(limitName, limitValue) {\n                if (limitValue > 0) {\n                    var limitMatcher = /(max|min)(Width|Height)/.exec(limitName), dimensionPropName = limitMatcher[2].charAt(0).toLowerCase() + limitMatcher[2].slice(1), actualValue = dimensions[dimensionPropName];\n                    switch (limitMatcher[1]) {\n                      case \"min\":\n                        if (actualValue < limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n\n                      case \"max\":\n                        if (actualValue > limitValue) {\n                            failingLimit = limitName;\n                            return false;\n                        }\n                        break;\n                    }\n                }\n            });\n            return failingLimit;\n        }\n        this.validate = function(limits) {\n            var validationEffort = new qq.Promise();\n            log(\"Attempting to validate image.\");\n            if (hasNonZeroLimits(limits)) {\n                getWidthHeight().then(function(dimensions) {\n                    var failingLimit = getFailingLimit(limits, dimensions);\n                    if (failingLimit) {\n                        validationEffort.failure(failingLimit);\n                    } else {\n                        validationEffort.success();\n                    }\n                }, validationEffort.success);\n            } else {\n                validationEffort.success();\n            }\n            return validationEffort;\n        };\n    };\n    qq.Session = function(spec) {\n        \"use strict\";\n        var options = {\n            endpoint: null,\n            params: {},\n            customHeaders: {},\n            cors: {},\n            addFileRecord: function(sessionData) {},\n            log: function(message, level) {}\n        };\n        qq.extend(options, spec, true);\n        function isJsonResponseValid(response) {\n            if (qq.isArray(response)) {\n                return true;\n            }\n            options.log(\"Session response is not an array.\", \"error\");\n        }\n        function handleFileItems(fileItems, success, xhrOrXdr, promise) {\n            var someItemsIgnored = false;\n            success = success && isJsonResponseValid(fileItems);\n            if (success) {\n                qq.each(fileItems, function(idx, fileItem) {\n                    if (fileItem.uuid == null) {\n                        someItemsIgnored = true;\n                        options.log(qq.format(\"Session response item {} did not include a valid UUID - ignoring.\", idx), \"error\");\n                    } else if (fileItem.name == null) {\n                        someItemsIgnored = true;\n                        options.log(qq.format(\"Session response item {} did not include a valid name - ignoring.\", idx), \"error\");\n                    } else {\n                        try {\n                            options.addFileRecord(fileItem);\n                            return true;\n                        } catch (err) {\n                            someItemsIgnored = true;\n                            options.log(err.message, \"error\");\n                        }\n                    }\n                    return false;\n                });\n            }\n            promise[success && !someItemsIgnored ? \"success\" : \"failure\"](fileItems, xhrOrXdr);\n        }\n        this.refresh = function() {\n            var refreshEffort = new qq.Promise(), refreshCompleteCallback = function(response, success, xhrOrXdr) {\n                handleFileItems(response, success, xhrOrXdr, refreshEffort);\n            }, requesterOptions = qq.extend({}, options), requester = new qq.SessionAjaxRequester(qq.extend(requesterOptions, {\n                onComplete: refreshCompleteCallback\n            }));\n            requester.queryServer();\n            return refreshEffort;\n        };\n    };\n    qq.SessionAjaxRequester = function(spec) {\n        \"use strict\";\n        var requester, options = {\n            endpoint: null,\n            customHeaders: {},\n            params: {},\n            cors: {\n                expected: false,\n                sendCredentials: false\n            },\n            onComplete: function(response, success, xhrOrXdr) {},\n            log: function(str, level) {}\n        };\n        qq.extend(options, spec);\n        function onComplete(id, xhrOrXdr, isError) {\n            var response = null;\n            if (xhrOrXdr.responseText != null) {\n                try {\n                    response = qq.parseJson(xhrOrXdr.responseText);\n                } catch (err) {\n                    options.log(\"Problem parsing session response: \" + err.message, \"error\");\n                    isError = true;\n                }\n            }\n            options.onComplete(response, !isError, xhrOrXdr);\n        }\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            validMethods: [ \"GET\" ],\n            method: \"GET\",\n            endpointStore: {\n                get: function() {\n                    return options.endpoint;\n                }\n            },\n            customHeaders: options.customHeaders,\n            log: options.log,\n            onComplete: onComplete,\n            cors: options.cors\n        }));\n        qq.extend(this, {\n            queryServer: function() {\n                var params = qq.extend({}, options.params);\n                options.log(\"Session query request.\");\n                requester.initTransport(\"sessionRefresh\").withParams(params).withCacheBuster().send();\n            }\n        });\n    };\n    qq.Scaler = function(spec, log) {\n        \"use strict\";\n        var self = this, customResizeFunction = spec.customResizer, includeOriginal = spec.sendOriginal, orient = spec.orient, defaultType = spec.defaultType, defaultQuality = spec.defaultQuality / 100, failedToScaleText = spec.failureText, includeExif = spec.includeExif, sizes = this._getSortedSizes(spec.sizes);\n        qq.extend(this, {\n            enabled: qq.supportedFeatures.scaling && sizes.length > 0,\n            getFileRecords: function(originalFileUuid, originalFileName, originalBlobOrBlobData) {\n                var self = this, records = [], originalBlob = originalBlobOrBlobData.blob ? originalBlobOrBlobData.blob : originalBlobOrBlobData, identifier = new qq.Identify(originalBlob, log);\n                if (identifier.isPreviewableSync()) {\n                    qq.each(sizes, function(idx, sizeRecord) {\n                        var outputType = self._determineOutputType({\n                            defaultType: defaultType,\n                            requestedType: sizeRecord.type,\n                            refType: originalBlob.type\n                        });\n                        records.push({\n                            uuid: qq.getUniqueId(),\n                            name: self._getName(originalFileName, {\n                                name: sizeRecord.name,\n                                type: outputType,\n                                refType: originalBlob.type\n                            }),\n                            blob: new qq.BlobProxy(originalBlob, qq.bind(self._generateScaledImage, self, {\n                                customResizeFunction: customResizeFunction,\n                                maxSize: sizeRecord.maxSize,\n                                orient: orient,\n                                type: outputType,\n                                quality: defaultQuality,\n                                failedText: failedToScaleText,\n                                includeExif: includeExif,\n                                log: log\n                            }))\n                        });\n                    });\n                    records.push({\n                        uuid: originalFileUuid,\n                        name: originalFileName,\n                        size: originalBlob.size,\n                        blob: includeOriginal ? originalBlob : null\n                    });\n                } else {\n                    records.push({\n                        uuid: originalFileUuid,\n                        name: originalFileName,\n                        size: originalBlob.size,\n                        blob: originalBlob\n                    });\n                }\n                return records;\n            },\n            handleNewFile: function(file, name, uuid, size, fileList, batchId, uuidParamName, api) {\n                var self = this, buttonId = file.qqButtonId || file.blob && file.blob.qqButtonId, scaledIds = [], originalId = null, addFileToHandler = api.addFileToHandler, uploadData = api.uploadData, paramsStore = api.paramsStore, proxyGroupId = qq.getUniqueId();\n                qq.each(self.getFileRecords(uuid, name, file), function(idx, record) {\n                    var blobSize = record.size, id;\n                    if (record.blob instanceof qq.BlobProxy) {\n                        blobSize = -1;\n                    }\n                    id = uploadData.addFile({\n                        uuid: record.uuid,\n                        name: record.name,\n                        size: blobSize,\n                        batchId: batchId,\n                        proxyGroupId: proxyGroupId\n                    });\n                    if (record.blob instanceof qq.BlobProxy) {\n                        scaledIds.push(id);\n                    } else {\n                        originalId = id;\n                    }\n                    if (record.blob) {\n                        addFileToHandler(id, record.blob);\n                        fileList.push({\n                            id: id,\n                            file: record.blob\n                        });\n                    } else {\n                        uploadData.setStatus(id, qq.status.REJECTED);\n                    }\n                });\n                if (originalId !== null) {\n                    qq.each(scaledIds, function(idx, scaledId) {\n                        var params = {\n                            qqparentuuid: uploadData.retrieve({\n                                id: originalId\n                            }).uuid,\n                            qqparentsize: uploadData.retrieve({\n                                id: originalId\n                            }).size\n                        };\n                        params[uuidParamName] = uploadData.retrieve({\n                            id: scaledId\n                        }).uuid;\n                        uploadData.setParentId(scaledId, originalId);\n                        paramsStore.addReadOnly(scaledId, params);\n                    });\n                    if (scaledIds.length) {\n                        (function() {\n                            var param = {};\n                            param[uuidParamName] = uploadData.retrieve({\n                                id: originalId\n                            }).uuid;\n                            paramsStore.addReadOnly(originalId, param);\n                        })();\n                    }\n                }\n            }\n        });\n    };\n    qq.extend(qq.Scaler.prototype, {\n        scaleImage: function(id, specs, api) {\n            \"use strict\";\n            if (!qq.supportedFeatures.scaling) {\n                throw new qq.Error(\"Scaling is not supported in this browser!\");\n            }\n            var scalingEffort = new qq.Promise(), log = api.log, file = api.getFile(id), uploadData = api.uploadData.retrieve({\n                id: id\n            }), name = uploadData && uploadData.name, uuid = uploadData && uploadData.uuid, scalingOptions = {\n                customResizer: specs.customResizer,\n                sendOriginal: false,\n                orient: specs.orient,\n                defaultType: specs.type || null,\n                defaultQuality: specs.quality,\n                failedToScaleText: \"Unable to scale\",\n                sizes: [ {\n                    name: \"\",\n                    maxSize: specs.maxSize\n                } ]\n            }, scaler = new qq.Scaler(scalingOptions, log);\n            if (!qq.Scaler || !qq.supportedFeatures.imagePreviews || !file) {\n                scalingEffort.failure();\n                log(\"Could not generate requested scaled image for \" + id + \".  \" + \"Scaling is either not possible in this browser, or the file could not be located.\", \"error\");\n            } else {\n                qq.bind(function() {\n                    var record = scaler.getFileRecords(uuid, name, file)[0];\n                    if (record && record.blob instanceof qq.BlobProxy) {\n                        record.blob.create().then(scalingEffort.success, scalingEffort.failure);\n                    } else {\n                        log(id + \" is not a scalable image!\", \"error\");\n                        scalingEffort.failure();\n                    }\n                }, this)();\n            }\n            return scalingEffort;\n        },\n        _determineOutputType: function(spec) {\n            \"use strict\";\n            var requestedType = spec.requestedType, defaultType = spec.defaultType, referenceType = spec.refType;\n            if (!defaultType && !requestedType) {\n                if (referenceType !== \"image/jpeg\") {\n                    return \"image/png\";\n                }\n                return referenceType;\n            }\n            if (!requestedType) {\n                return defaultType;\n            }\n            if (qq.indexOf(Object.keys(qq.Identify.prototype.PREVIEWABLE_MIME_TYPES), requestedType) >= 0) {\n                if (requestedType === \"image/tiff\") {\n                    return qq.supportedFeatures.tiffPreviews ? requestedType : defaultType;\n                }\n                return requestedType;\n            }\n            return defaultType;\n        },\n        _getName: function(originalName, scaledVersionProperties) {\n            \"use strict\";\n            var startOfExt = originalName.lastIndexOf(\".\"), versionType = scaledVersionProperties.type || \"image/png\", referenceType = scaledVersionProperties.refType, scaledName = \"\", scaledExt = qq.getExtension(originalName), nameAppendage = \"\";\n            if (scaledVersionProperties.name && scaledVersionProperties.name.trim().length) {\n                nameAppendage = \" (\" + scaledVersionProperties.name + \")\";\n            }\n            if (startOfExt >= 0) {\n                scaledName = originalName.substr(0, startOfExt);\n                if (referenceType !== versionType) {\n                    scaledExt = versionType.split(\"/\")[1];\n                }\n                scaledName += nameAppendage + \".\" + scaledExt;\n            } else {\n                scaledName = originalName + nameAppendage;\n            }\n            return scaledName;\n        },\n        _getSortedSizes: function(sizes) {\n            \"use strict\";\n            sizes = qq.extend([], sizes);\n            return sizes.sort(function(a, b) {\n                if (a.maxSize > b.maxSize) {\n                    return 1;\n                }\n                if (a.maxSize < b.maxSize) {\n                    return -1;\n                }\n                return 0;\n            });\n        },\n        _generateScaledImage: function(spec, sourceFile) {\n            \"use strict\";\n            var self = this, customResizeFunction = spec.customResizeFunction, log = spec.log, maxSize = spec.maxSize, orient = spec.orient, type = spec.type, quality = spec.quality, failedText = spec.failedText, includeExif = spec.includeExif && sourceFile.type === \"image/jpeg\" && type === \"image/jpeg\", scalingEffort = new qq.Promise(), imageGenerator = new qq.ImageGenerator(log), canvas = document.createElement(\"canvas\");\n            log(\"Attempting to generate scaled version for \" + sourceFile.name);\n            imageGenerator.generate(sourceFile, canvas, {\n                maxSize: maxSize,\n                orient: orient,\n                customResizeFunction: customResizeFunction\n            }).then(function() {\n                var scaledImageDataUri = canvas.toDataURL(type, quality), signalSuccess = function() {\n                    log(\"Success generating scaled version for \" + sourceFile.name);\n                    var blob = qq.dataUriToBlob(scaledImageDataUri);\n                    scalingEffort.success(blob);\n                };\n                if (includeExif) {\n                    self._insertExifHeader(sourceFile, scaledImageDataUri, log).then(function(scaledImageDataUriWithExif) {\n                        scaledImageDataUri = scaledImageDataUriWithExif;\n                        signalSuccess();\n                    }, function() {\n                        log(\"Problem inserting EXIF header into scaled image.  Using scaled image w/out EXIF data.\", \"error\");\n                        signalSuccess();\n                    });\n                } else {\n                    signalSuccess();\n                }\n            }, function() {\n                log(\"Failed attempt to generate scaled version for \" + sourceFile.name, \"error\");\n                scalingEffort.failure(failedText);\n            });\n            return scalingEffort;\n        },\n        _insertExifHeader: function(originalImage, scaledImageDataUri, log) {\n            \"use strict\";\n            var reader = new FileReader(), insertionEffort = new qq.Promise(), originalImageDataUri = \"\";\n            reader.onload = function() {\n                originalImageDataUri = reader.result;\n                insertionEffort.success(qq.ExifRestorer.restore(originalImageDataUri, scaledImageDataUri));\n            };\n            reader.onerror = function() {\n                log(\"Problem reading \" + originalImage.name + \" during attempt to transfer EXIF data to scaled version.\", \"error\");\n                insertionEffort.failure();\n            };\n            reader.readAsDataURL(originalImage);\n            return insertionEffort;\n        },\n        _dataUriToBlob: function(dataUri) {\n            \"use strict\";\n            var byteString, mimeString, arrayBuffer, intArray;\n            if (dataUri.split(\",\")[0].indexOf(\"base64\") >= 0) {\n                byteString = atob(dataUri.split(\",\")[1]);\n            } else {\n                byteString = decodeURI(dataUri.split(\",\")[1]);\n            }\n            mimeString = dataUri.split(\",\")[0].split(\":\")[1].split(\";\")[0];\n            arrayBuffer = new ArrayBuffer(byteString.length);\n            intArray = new Uint8Array(arrayBuffer);\n            qq.each(byteString, function(idx, character) {\n                intArray[idx] = character.charCodeAt(0);\n            });\n            return this._createBlob(arrayBuffer, mimeString);\n        },\n        _createBlob: function(data, mime) {\n            \"use strict\";\n            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, blobBuilder = BlobBuilder && new BlobBuilder();\n            if (blobBuilder) {\n                blobBuilder.append(data);\n                return blobBuilder.getBlob(mime);\n            } else {\n                return new Blob([ data ], {\n                    type: mime\n                });\n            }\n        }\n    });\n    qq.ExifRestorer = function() {\n        var ExifRestorer = {};\n        ExifRestorer.KEY_STR = \"ABCDEFGHIJKLMNOP\" + \"QRSTUVWXYZabcdef\" + \"ghijklmnopqrstuv\" + \"wxyz0123456789+/\" + \"=\";\n        ExifRestorer.encode64 = function(input) {\n            var output = \"\", chr1, chr2, chr3 = \"\", enc1, enc2, enc3, enc4 = \"\", i = 0;\n            do {\n                chr1 = input[i++];\n                chr2 = input[i++];\n                chr3 = input[i++];\n                enc1 = chr1 >> 2;\n                enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n                enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n                enc4 = chr3 & 63;\n                if (isNaN(chr2)) {\n                    enc3 = enc4 = 64;\n                } else if (isNaN(chr3)) {\n                    enc4 = 64;\n                }\n                output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);\n                chr1 = chr2 = chr3 = \"\";\n                enc1 = enc2 = enc3 = enc4 = \"\";\n            } while (i < input.length);\n            return output;\n        };\n        ExifRestorer.restore = function(origFileBase64, resizedFileBase64) {\n            var expectedBase64Header = \"data:image/jpeg;base64,\";\n            if (!origFileBase64.match(expectedBase64Header)) {\n                return resizedFileBase64;\n            }\n            var rawImage = this.decode64(origFileBase64.replace(expectedBase64Header, \"\"));\n            var segments = this.slice2Segments(rawImage);\n            var image = this.exifManipulation(resizedFileBase64, segments);\n            return expectedBase64Header + this.encode64(image);\n        };\n        ExifRestorer.exifManipulation = function(resizedFileBase64, segments) {\n            var exifArray = this.getExifArray(segments), newImageArray = this.insertExif(resizedFileBase64, exifArray), aBuffer = new Uint8Array(newImageArray);\n            return aBuffer;\n        };\n        ExifRestorer.getExifArray = function(segments) {\n            var seg;\n            for (var x = 0; x < segments.length; x++) {\n                seg = segments[x];\n                if (seg[0] == 255 & seg[1] == 225) {\n                    return seg;\n                }\n            }\n            return [];\n        };\n        ExifRestorer.insertExif = function(resizedFileBase64, exifArray) {\n            var imageData = resizedFileBase64.replace(\"data:image/jpeg;base64,\", \"\"), buf = this.decode64(imageData), separatePoint = buf.indexOf(255, 3), mae = buf.slice(0, separatePoint), ato = buf.slice(separatePoint), array = mae;\n            array = array.concat(exifArray);\n            array = array.concat(ato);\n            return array;\n        };\n        ExifRestorer.slice2Segments = function(rawImageArray) {\n            var head = 0, segments = [];\n            while (1) {\n                if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 218) {\n                    break;\n                }\n                if (rawImageArray[head] == 255 & rawImageArray[head + 1] == 216) {\n                    head += 2;\n                } else {\n                    var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3], endPoint = head + length + 2, seg = rawImageArray.slice(head, endPoint);\n                    segments.push(seg);\n                    head = endPoint;\n                }\n                if (head > rawImageArray.length) {\n                    break;\n                }\n            }\n            return segments;\n        };\n        ExifRestorer.decode64 = function(input) {\n            var output = \"\", chr1, chr2, chr3 = \"\", enc1, enc2, enc3, enc4 = \"\", i = 0, buf = [];\n            var base64test = /[^A-Za-z0-9\\+\\/\\=]/g;\n            if (base64test.exec(input)) {\n                throw new Error(\"There were invalid base64 characters in the input text.  \" + \"Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\");\n            }\n            input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n            do {\n                enc1 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc2 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc3 = this.KEY_STR.indexOf(input.charAt(i++));\n                enc4 = this.KEY_STR.indexOf(input.charAt(i++));\n                chr1 = enc1 << 2 | enc2 >> 4;\n                chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n                chr3 = (enc3 & 3) << 6 | enc4;\n                buf.push(chr1);\n                if (enc3 != 64) {\n                    buf.push(chr2);\n                }\n                if (enc4 != 64) {\n                    buf.push(chr3);\n                }\n                chr1 = chr2 = chr3 = \"\";\n                enc1 = enc2 = enc3 = enc4 = \"\";\n            } while (i < input.length);\n            return buf;\n        };\n        return ExifRestorer;\n    }();\n    qq.TotalProgress = function(callback, getSize) {\n        \"use strict\";\n        var perFileProgress = {}, totalLoaded = 0, totalSize = 0, lastLoadedSent = -1, lastTotalSent = -1, callbackProxy = function(loaded, total) {\n            if (loaded !== lastLoadedSent || total !== lastTotalSent) {\n                callback(loaded, total);\n            }\n            lastLoadedSent = loaded;\n            lastTotalSent = total;\n        }, noRetryableFiles = function(failed, retryable) {\n            var none = true;\n            qq.each(failed, function(idx, failedId) {\n                if (qq.indexOf(retryable, failedId) >= 0) {\n                    none = false;\n                    return false;\n                }\n            });\n            return none;\n        }, onCancel = function(id) {\n            updateTotalProgress(id, -1, -1);\n            delete perFileProgress[id];\n        }, onAllComplete = function(successful, failed, retryable) {\n            if (failed.length === 0 || noRetryableFiles(failed, retryable)) {\n                callbackProxy(totalSize, totalSize);\n                this.reset();\n            }\n        }, onNew = function(id) {\n            var size = getSize(id);\n            if (size > 0) {\n                updateTotalProgress(id, 0, size);\n                perFileProgress[id] = {\n                    loaded: 0,\n                    total: size\n                };\n            }\n        }, updateTotalProgress = function(id, newLoaded, newTotal) {\n            var oldLoaded = perFileProgress[id] ? perFileProgress[id].loaded : 0, oldTotal = perFileProgress[id] ? perFileProgress[id].total : 0;\n            if (newLoaded === -1 && newTotal === -1) {\n                totalLoaded -= oldLoaded;\n                totalSize -= oldTotal;\n            } else {\n                if (newLoaded) {\n                    totalLoaded += newLoaded - oldLoaded;\n                }\n                if (newTotal) {\n                    totalSize += newTotal - oldTotal;\n                }\n            }\n            callbackProxy(totalLoaded, totalSize);\n        };\n        qq.extend(this, {\n            onAllComplete: onAllComplete,\n            onStatusChange: function(id, oldStatus, newStatus) {\n                if (newStatus === qq.status.CANCELED || newStatus === qq.status.REJECTED) {\n                    onCancel(id);\n                } else if (newStatus === qq.status.SUBMITTING) {\n                    onNew(id);\n                }\n            },\n            onIndividualProgress: function(id, loaded, total) {\n                updateTotalProgress(id, loaded, total);\n                perFileProgress[id] = {\n                    loaded: loaded,\n                    total: total\n                };\n            },\n            onNewSize: function(id) {\n                onNew(id);\n            },\n            reset: function() {\n                perFileProgress = {};\n                totalLoaded = 0;\n                totalSize = 0;\n            }\n        });\n    };\n    qq.PasteSupport = function(o) {\n        \"use strict\";\n        var options, detachPasteHandler;\n        options = {\n            targetElement: null,\n            callbacks: {\n                log: function(message, level) {},\n                pasteReceived: function(blob) {}\n            }\n        };\n        function isImage(item) {\n            return item.type && item.type.indexOf(\"image/\") === 0;\n        }\n        function registerPasteHandler() {\n            detachPasteHandler = qq(options.targetElement).attach(\"paste\", function(event) {\n                var clipboardData = event.clipboardData;\n                if (clipboardData) {\n                    qq.each(clipboardData.items, function(idx, item) {\n                        if (isImage(item)) {\n                            var blob = item.getAsFile();\n                            options.callbacks.pasteReceived(blob);\n                        }\n                    });\n                }\n            });\n        }\n        function unregisterPasteHandler() {\n            if (detachPasteHandler) {\n                detachPasteHandler();\n            }\n        }\n        qq.extend(options, o);\n        registerPasteHandler();\n        qq.extend(this, {\n            reset: function() {\n                unregisterPasteHandler();\n            }\n        });\n    };\n    qq.FormSupport = function(options, startUpload, log) {\n        \"use strict\";\n        var self = this, interceptSubmit = options.interceptSubmit, formEl = options.element, autoUpload = options.autoUpload;\n        qq.extend(this, {\n            newEndpoint: null,\n            newAutoUpload: autoUpload,\n            attachedToForm: false,\n            getFormInputsAsObject: function() {\n                if (formEl == null) {\n                    return null;\n                }\n                return self._form2Obj(formEl);\n            }\n        });\n        function determineNewEndpoint(formEl) {\n            if (formEl.getAttribute(\"action\")) {\n                self.newEndpoint = formEl.getAttribute(\"action\");\n            }\n        }\n        function validateForm(formEl, nativeSubmit) {\n            if (formEl.checkValidity && !formEl.checkValidity()) {\n                log(\"Form did not pass validation checks - will not upload.\", \"error\");\n                nativeSubmit();\n            } else {\n                return true;\n            }\n        }\n        function maybeUploadOnSubmit(formEl) {\n            var nativeSubmit = formEl.submit;\n            qq(formEl).attach(\"submit\", function(event) {\n                event = event || window.event;\n                if (event.preventDefault) {\n                    event.preventDefault();\n                } else {\n                    event.returnValue = false;\n                }\n                validateForm(formEl, nativeSubmit) && startUpload();\n            });\n            formEl.submit = function() {\n                validateForm(formEl, nativeSubmit) && startUpload();\n            };\n        }\n        function determineFormEl(formEl) {\n            if (formEl) {\n                if (qq.isString(formEl)) {\n                    formEl = document.getElementById(formEl);\n                }\n                if (formEl) {\n                    log(\"Attaching to form element.\");\n                    determineNewEndpoint(formEl);\n                    interceptSubmit && maybeUploadOnSubmit(formEl);\n                }\n            }\n            return formEl;\n        }\n        formEl = determineFormEl(formEl);\n        this.attachedToForm = !!formEl;\n    };\n    qq.extend(qq.FormSupport.prototype, {\n        _form2Obj: function(form) {\n            \"use strict\";\n            var obj = {}, notIrrelevantType = function(type) {\n                var irrelevantTypes = [ \"button\", \"image\", \"reset\", \"submit\" ];\n                return qq.indexOf(irrelevantTypes, type.toLowerCase()) < 0;\n            }, radioOrCheckbox = function(type) {\n                return qq.indexOf([ \"checkbox\", \"radio\" ], type.toLowerCase()) >= 0;\n            }, ignoreValue = function(el) {\n                if (radioOrCheckbox(el.type) && !el.checked) {\n                    return true;\n                }\n                return el.disabled && el.type.toLowerCase() !== \"hidden\";\n            }, selectValue = function(select) {\n                var value = null;\n                qq.each(qq(select).children(), function(idx, child) {\n                    if (child.tagName.toLowerCase() === \"option\" && child.selected) {\n                        value = child.value;\n                        return false;\n                    }\n                });\n                return value;\n            };\n            qq.each(form.elements, function(idx, el) {\n                if ((qq.isInput(el, true) || el.tagName.toLowerCase() === \"textarea\") && notIrrelevantType(el.type) && !ignoreValue(el)) {\n                    obj[el.name] = el.value;\n                } else if (el.tagName.toLowerCase() === \"select\" && !ignoreValue(el)) {\n                    var value = selectValue(el);\n                    if (value !== null) {\n                        obj[el.name] = value;\n                    }\n                }\n            });\n            return obj;\n        }\n    });\n    qq.traditional = qq.traditional || {};\n    qq.traditional.FormUploadHandler = function(options, proxy) {\n        \"use strict\";\n        var handler = this, getName = proxy.getName, getUuid = proxy.getUuid, log = proxy.log;\n        function getIframeContentJson(id, iframe) {\n            var response, doc, innerHtml;\n            try {\n                doc = iframe.contentDocument || iframe.contentWindow.document;\n                innerHtml = doc.body.innerHTML;\n                log(\"converting iframe's innerHTML to JSON\");\n                log(\"innerHTML = \" + innerHtml);\n                if (innerHtml && innerHtml.match(/^<pre/i)) {\n                    innerHtml = doc.body.firstChild.firstChild.nodeValue;\n                }\n                response = handler._parseJsonResponse(innerHtml);\n            } catch (error) {\n                log(\"Error when attempting to parse form upload response (\" + error.message + \")\", \"error\");\n                response = {\n                    success: false\n                };\n            }\n            return response;\n        }\n        function createForm(id, iframe) {\n            var params = options.paramsStore.get(id), method = options.method.toLowerCase() === \"get\" ? \"GET\" : \"POST\", endpoint = options.endpointStore.get(id), name = getName(id);\n            params[options.uuidName] = getUuid(id);\n            params[options.filenameParam] = name;\n            return handler._initFormForUpload({\n                method: method,\n                endpoint: endpoint,\n                params: params,\n                paramsInBody: options.paramsInBody,\n                targetName: iframe.name\n            });\n        }\n        this.uploadFile = function(id) {\n            var input = handler.getInput(id), iframe = handler._createIframe(id), promise = new qq.Promise(), form;\n            form = createForm(id, iframe);\n            form.appendChild(input);\n            handler._attachLoadEvent(iframe, function(responseFromMessage) {\n                log(\"iframe loaded\");\n                var response = responseFromMessage ? responseFromMessage : getIframeContentJson(id, iframe);\n                handler._detachLoadEvent(id);\n                if (!options.cors.expected) {\n                    qq(iframe).remove();\n                }\n                if (response.success) {\n                    promise.success(response);\n                } else {\n                    promise.failure(response);\n                }\n            });\n            log(\"Sending upload request for \" + id);\n            form.submit();\n            qq(form).remove();\n            return promise;\n        };\n        qq.extend(this, new qq.FormUploadHandler({\n            options: {\n                isCors: options.cors.expected,\n                inputName: options.inputName\n            },\n            proxy: {\n                onCancel: options.onCancel,\n                getName: getName,\n                getUuid: getUuid,\n                log: log\n            }\n        }));\n    };\n    qq.traditional = qq.traditional || {};\n    qq.traditional.XhrUploadHandler = function(spec, proxy) {\n        \"use strict\";\n        var handler = this, getName = proxy.getName, getSize = proxy.getSize, getUuid = proxy.getUuid, log = proxy.log, multipart = spec.forceMultipart || spec.paramsInBody, addChunkingSpecificParams = function(id, params, chunkData) {\n            var size = getSize(id), name = getName(id);\n            if (!spec.omitDefaultParams) {\n                params[spec.chunking.paramNames.partIndex] = chunkData.part;\n                params[spec.chunking.paramNames.partByteOffset] = chunkData.start;\n                params[spec.chunking.paramNames.chunkSize] = chunkData.size;\n                params[spec.chunking.paramNames.totalParts] = chunkData.count;\n                params[spec.totalFileSizeName] = size;\n            }\n            if (multipart && !spec.omitDefaultParams) {\n                params[spec.filenameParam] = name;\n            }\n        }, allChunksDoneRequester = new qq.traditional.AllChunksDoneAjaxRequester({\n            cors: spec.cors,\n            endpoint: spec.chunking.success.endpoint,\n            headers: spec.chunking.success.headers,\n            jsonPayload: spec.chunking.success.jsonPayload,\n            log: log,\n            method: spec.chunking.success.method,\n            params: spec.chunking.success.params\n        }), createReadyStateChangedHandler = function(id, xhr) {\n            var promise = new qq.Promise();\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                    var result = onUploadOrChunkComplete(id, xhr);\n                    if (result.success) {\n                        promise.success(result.response, xhr);\n                    } else {\n                        promise.failure(result.response, xhr);\n                    }\n                }\n            };\n            return promise;\n        }, getChunksCompleteParams = function(id) {\n            var params = spec.paramsStore.get(id), name = getName(id), size = getSize(id);\n            params[spec.uuidName] = getUuid(id);\n            params[spec.filenameParam] = name;\n            params[spec.totalFileSizeName] = size;\n            params[spec.chunking.paramNames.totalParts] = handler._getTotalChunks(id);\n            return params;\n        }, isErrorUploadResponse = function(xhr, response) {\n            return qq.indexOf([ 200, 201, 202, 203, 204 ], xhr.status) < 0 || spec.requireSuccessJson && !response.success || response.reset;\n        }, onUploadOrChunkComplete = function(id, xhr) {\n            var response;\n            log(\"xhr - server response received for \" + id);\n            log(\"responseText = \" + xhr.responseText);\n            response = parseResponse(true, xhr);\n            return {\n                success: !isErrorUploadResponse(xhr, response),\n                response: response\n            };\n        }, parseResponse = function(upload, xhr) {\n            var response = {};\n            try {\n                log(qq.format(\"Received response status {} with body: {}\", xhr.status, xhr.responseText));\n                response = qq.parseJson(xhr.responseText);\n            } catch (error) {\n                upload && spec.requireSuccessJson && log(\"Error when attempting to parse xhr response text (\" + error.message + \")\", \"error\");\n            }\n            return response;\n        }, sendChunksCompleteRequest = function(id) {\n            var promise = new qq.Promise();\n            allChunksDoneRequester.complete(id, handler._createXhr(id), getChunksCompleteParams(id), spec.customHeaders.get(id)).then(function(xhr) {\n                promise.success(parseResponse(false, xhr), xhr);\n            }, function(xhr) {\n                promise.failure(parseResponse(false, xhr), xhr);\n            });\n            return promise;\n        }, setParamsAndGetEntityToSend = function(entityToSendParams) {\n            var fileOrBlob = entityToSendParams.fileOrBlob;\n            var id = entityToSendParams.id;\n            var xhr = entityToSendParams.xhr;\n            var xhrOverrides = entityToSendParams.xhrOverrides || {};\n            var customParams = entityToSendParams.customParams || {};\n            var defaultParams = entityToSendParams.params || {};\n            var xhrOverrideParams = xhrOverrides.params || {};\n            var params;\n            var formData = multipart ? new FormData() : null, method = xhrOverrides.method || spec.method, endpoint = xhrOverrides.endpoint || spec.endpointStore.get(id), name = getName(id), size = getSize(id);\n            if (spec.omitDefaultParams) {\n                params = qq.extend({}, customParams);\n                qq.extend(params, xhrOverrideParams);\n            } else {\n                params = qq.extend({}, customParams);\n                qq.extend(params, xhrOverrideParams);\n                qq.extend(params, defaultParams);\n                params[spec.uuidName] = getUuid(id);\n                params[spec.filenameParam] = name;\n                if (multipart) {\n                    params[spec.totalFileSizeName] = size;\n                } else if (!spec.paramsInBody) {\n                    params[spec.inputName] = name;\n                }\n            }\n            if (!spec.paramsInBody) {\n                endpoint = qq.obj2url(params, endpoint);\n            }\n            xhr.open(method, endpoint, true);\n            if (spec.cors.expected && spec.cors.sendCredentials) {\n                xhr.withCredentials = true;\n            }\n            if (multipart) {\n                if (spec.paramsInBody) {\n                    qq.obj2FormData(params, formData);\n                }\n                formData.append(spec.inputName, fileOrBlob);\n                return formData;\n            }\n            return fileOrBlob;\n        }, setUploadHeaders = function(headersOptions) {\n            var headerOverrides = headersOptions.headerOverrides;\n            var id = headersOptions.id;\n            var xhr = headersOptions.xhr;\n            if (headerOverrides) {\n                qq.each(headerOverrides, function(headerName, headerValue) {\n                    xhr.setRequestHeader(headerName, headerValue);\n                });\n            } else {\n                var extraHeaders = spec.customHeaders.get(id), fileOrBlob = handler.getFile(id);\n                xhr.setRequestHeader(\"Accept\", \"application/json\");\n                xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n                xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n                if (!multipart) {\n                    xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\n                    xhr.setRequestHeader(\"X-Mime-Type\", fileOrBlob.type);\n                }\n                qq.each(extraHeaders, function(name, val) {\n                    xhr.setRequestHeader(name, val);\n                });\n            }\n        };\n        qq.extend(this, {\n            uploadChunk: function(uploadChunkParams) {\n                var id = uploadChunkParams.id;\n                var chunkIdx = uploadChunkParams.chunkIdx;\n                var overrides = uploadChunkParams.overrides || {};\n                var resuming = uploadChunkParams.resuming;\n                var chunkData = handler._getChunkData(id, chunkIdx), xhr = handler._createXhr(id, chunkIdx), promise, toSend, customParams, params = {};\n                promise = createReadyStateChangedHandler(id, xhr);\n                handler._registerProgressHandler(id, chunkIdx, chunkData.size);\n                customParams = spec.paramsStore.get(id);\n                addChunkingSpecificParams(id, params, chunkData);\n                if (resuming) {\n                    params[spec.resume.paramNames.resuming] = true;\n                }\n                toSend = setParamsAndGetEntityToSend({\n                    fileOrBlob: chunkData.blob,\n                    id: id,\n                    customParams: customParams,\n                    params: params,\n                    xhr: xhr,\n                    xhrOverrides: overrides\n                });\n                setUploadHeaders({\n                    headerOverrides: overrides.headers,\n                    id: id,\n                    xhr: xhr\n                });\n                xhr.send(toSend);\n                return promise;\n            },\n            uploadFile: function(id) {\n                var fileOrBlob = handler.getFile(id), promise, xhr, customParams, toSend;\n                xhr = handler._createXhr(id);\n                handler._registerProgressHandler(id);\n                promise = createReadyStateChangedHandler(id, xhr);\n                customParams = spec.paramsStore.get(id);\n                toSend = setParamsAndGetEntityToSend({\n                    fileOrBlob: fileOrBlob,\n                    id: id,\n                    customParams: customParams,\n                    xhr: xhr\n                });\n                setUploadHeaders({\n                    id: id,\n                    xhr: xhr\n                });\n                xhr.send(toSend);\n                return promise;\n            }\n        });\n        qq.extend(this, new qq.XhrUploadHandler({\n            options: qq.extend({\n                namespace: \"traditional\"\n            }, spec),\n            proxy: qq.extend({\n                getEndpoint: spec.endpointStore.get\n            }, proxy)\n        }));\n        qq.override(this, function(super_) {\n            return {\n                finalizeChunks: function(id) {\n                    proxy.onFinalizing(id);\n                    if (spec.chunking.success.endpoint) {\n                        return sendChunksCompleteRequest(id);\n                    } else {\n                        return super_.finalizeChunks(id, qq.bind(parseResponse, this, true));\n                    }\n                }\n            };\n        });\n    };\n    qq.traditional.AllChunksDoneAjaxRequester = function(o) {\n        \"use strict\";\n        var requester, options = {\n            cors: {\n                allowXdr: false,\n                expected: false,\n                sendCredentials: false\n            },\n            endpoint: null,\n            log: function(str, level) {},\n            method: \"POST\"\n        }, promises = {}, endpointHandler = {\n            get: function(id) {\n                if (qq.isFunction(options.endpoint)) {\n                    return options.endpoint(id);\n                }\n                return options.endpoint;\n            }\n        };\n        qq.extend(options, o);\n        requester = qq.extend(this, new qq.AjaxRequester({\n            acceptHeader: \"application/json\",\n            contentType: options.jsonPayload ? \"application/json\" : \"application/x-www-form-urlencoded\",\n            validMethods: [ options.method ],\n            method: options.method,\n            endpointStore: endpointHandler,\n            allowXRequestedWithAndCacheControl: false,\n            cors: options.cors,\n            log: options.log,\n            onComplete: function(id, xhr, isError) {\n                var promise = promises[id];\n                delete promises[id];\n                if (isError) {\n                    promise.failure(xhr);\n                } else {\n                    promise.success(xhr);\n                }\n            }\n        }));\n        qq.extend(this, {\n            complete: function(id, xhr, params, headers) {\n                var promise = new qq.Promise();\n                options.log(\"Submitting All Chunks Done request for \" + id);\n                promises[id] = promise;\n                requester.initTransport(id).withParams(options.params(id) || params).withHeaders(options.headers(id) || headers).send(xhr);\n                return promise;\n            }\n        });\n    };\n    qq.DragAndDrop = function(o) {\n        \"use strict\";\n        var options, HIDE_ZONES_EVENT_NAME = \"qq-hidezones\", HIDE_BEFORE_ENTER_ATTR = \"qq-hide-dropzone\", uploadDropZones = [], droppedFiles = [], disposeSupport = new qq.DisposeSupport();\n        options = {\n            dropZoneElements: [],\n            allowMultipleItems: true,\n            classes: {\n                dropActive: null\n            },\n            callbacks: new qq.DragAndDrop.callbacks()\n        };\n        qq.extend(options, o, true);\n        function uploadDroppedFiles(files, uploadDropZone) {\n            var filesAsArray = Array.prototype.slice.call(files);\n            options.callbacks.dropLog(\"Grabbed \" + files.length + \" dropped files.\");\n            uploadDropZone.dropDisabled(false);\n            options.callbacks.processingDroppedFilesComplete(filesAsArray, uploadDropZone.getElement());\n        }\n        function traverseFileTree(entry) {\n            var parseEntryPromise = new qq.Promise();\n            if (entry.isFile) {\n                entry.file(function(file) {\n                    file.qqPath = extractDirectoryPath(entry);\n                    droppedFiles.push(file);\n                    parseEntryPromise.success();\n                }, function(fileError) {\n                    options.callbacks.dropLog(\"Problem parsing '\" + entry.fullPath + \"'.  FileError code \" + fileError.code + \".\", \"error\");\n                    parseEntryPromise.failure();\n                });\n            } else if (entry.isDirectory) {\n                getFilesInDirectory(entry).then(function allEntriesRead(entries) {\n                    var entriesLeft = entries.length;\n                    qq.each(entries, function(idx, entry) {\n                        traverseFileTree(entry).done(function() {\n                            entriesLeft -= 1;\n                            if (entriesLeft === 0) {\n                                parseEntryPromise.success();\n                            }\n                        });\n                    });\n                    if (!entries.length) {\n                        parseEntryPromise.success();\n                    }\n                }, function readFailure(fileError) {\n                    options.callbacks.dropLog(\"Problem parsing '\" + entry.fullPath + \"'.  FileError code \" + fileError.code + \".\", \"error\");\n                    parseEntryPromise.failure();\n                });\n            }\n            return parseEntryPromise;\n        }\n        function extractDirectoryPath(entry) {\n            var name = entry.name, fullPath = entry.fullPath, indexOfNameInFullPath = fullPath.lastIndexOf(name);\n            fullPath = fullPath.substr(0, indexOfNameInFullPath);\n            if (fullPath.charAt(0) === \"/\") {\n                fullPath = fullPath.substr(1);\n            }\n            return fullPath;\n        }\n        function getFilesInDirectory(entry, reader, accumEntries, existingPromise) {\n            var promise = existingPromise || new qq.Promise(), dirReader = reader || entry.createReader();\n            dirReader.readEntries(function readSuccess(entries) {\n                var newEntries = accumEntries ? accumEntries.concat(entries) : entries;\n                if (entries.length) {\n                    setTimeout(function() {\n                        getFilesInDirectory(entry, dirReader, newEntries, promise);\n                    }, 0);\n                } else {\n                    promise.success(newEntries);\n                }\n            }, promise.failure);\n            return promise;\n        }\n        function handleDataTransfer(dataTransfer, uploadDropZone) {\n            var pendingFolderPromises = [], handleDataTransferPromise = new qq.Promise();\n            options.callbacks.processingDroppedFiles();\n            uploadDropZone.dropDisabled(true);\n            if (dataTransfer.files.length > 1 && !options.allowMultipleItems) {\n                options.callbacks.processingDroppedFilesComplete([]);\n                options.callbacks.dropError(\"tooManyFilesError\", \"\");\n                uploadDropZone.dropDisabled(false);\n                handleDataTransferPromise.failure();\n            } else {\n                droppedFiles = [];\n                if (qq.isFolderDropSupported(dataTransfer)) {\n                    qq.each(dataTransfer.items, function(idx, item) {\n                        var entry = item.webkitGetAsEntry();\n                        if (entry) {\n                            if (entry.isFile) {\n                                droppedFiles.push(item.getAsFile());\n                            } else {\n                                pendingFolderPromises.push(traverseFileTree(entry).done(function() {\n                                    pendingFolderPromises.pop();\n                                    if (pendingFolderPromises.length === 0) {\n                                        handleDataTransferPromise.success();\n                                    }\n                                }));\n                            }\n                        }\n                    });\n                } else {\n                    droppedFiles = dataTransfer.files;\n                }\n                if (pendingFolderPromises.length === 0) {\n                    handleDataTransferPromise.success();\n                }\n            }\n            return handleDataTransferPromise;\n        }\n        function setupDropzone(dropArea) {\n            var dropZone = new qq.UploadDropZone({\n                HIDE_ZONES_EVENT_NAME: HIDE_ZONES_EVENT_NAME,\n                element: dropArea,\n                onEnter: function(e) {\n                    qq(dropArea).addClass(options.classes.dropActive);\n                    e.stopPropagation();\n                },\n                onLeaveNotDescendants: function(e) {\n                    qq(dropArea).removeClass(options.classes.dropActive);\n                },\n                onDrop: function(e) {\n                    handleDataTransfer(e.dataTransfer, dropZone).then(function() {\n                        uploadDroppedFiles(droppedFiles, dropZone);\n                    }, function() {\n                        options.callbacks.dropLog(\"Drop event DataTransfer parsing failed.  No files will be uploaded.\", \"error\");\n                    });\n                }\n            });\n            disposeSupport.addDisposer(function() {\n                dropZone.dispose();\n            });\n            qq(dropArea).hasAttribute(HIDE_BEFORE_ENTER_ATTR) && qq(dropArea).hide();\n            uploadDropZones.push(dropZone);\n            return dropZone;\n        }\n        function isFileDrag(dragEvent) {\n            var fileDrag;\n            qq.each(dragEvent.dataTransfer.types, function(key, val) {\n                if (val === \"Files\") {\n                    fileDrag = true;\n                    return false;\n                }\n            });\n            return fileDrag;\n        }\n        function leavingDocumentOut(e) {\n            if (qq.safari()) {\n                return e.x < 0 || e.y < 0;\n            }\n            return e.x === 0 && e.y === 0;\n        }\n        function setupDragDrop() {\n            var dropZones = options.dropZoneElements, maybeHideDropZones = function() {\n                setTimeout(function() {\n                    qq.each(dropZones, function(idx, dropZone) {\n                        qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR) && qq(dropZone).hide();\n                        qq(dropZone).removeClass(options.classes.dropActive);\n                    });\n                }, 10);\n            };\n            qq.each(dropZones, function(idx, dropZone) {\n                var uploadDropZone = setupDropzone(dropZone);\n                if (dropZones.length && qq.supportedFeatures.fileDrop) {\n                    disposeSupport.attach(document, \"dragenter\", function(e) {\n                        if (!uploadDropZone.dropDisabled() && isFileDrag(e)) {\n                            qq.each(dropZones, function(idx, dropZone) {\n                                if (dropZone instanceof HTMLElement && qq(dropZone).hasAttribute(HIDE_BEFORE_ENTER_ATTR)) {\n                                    qq(dropZone).css({\n                                        display: \"block\"\n                                    });\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n            disposeSupport.attach(document, \"dragleave\", function(e) {\n                if (leavingDocumentOut(e)) {\n                    maybeHideDropZones();\n                }\n            });\n            disposeSupport.attach(qq(document).children()[0], \"mouseenter\", function(e) {\n                maybeHideDropZones();\n            });\n            disposeSupport.attach(document, \"drop\", function(e) {\n                if (isFileDrag(e)) {\n                    e.preventDefault();\n                    maybeHideDropZones();\n                }\n            });\n            disposeSupport.attach(document, HIDE_ZONES_EVENT_NAME, maybeHideDropZones);\n        }\n        setupDragDrop();\n        qq.extend(this, {\n            setupExtraDropzone: function(element) {\n                options.dropZoneElements.push(element);\n                setupDropzone(element);\n            },\n            removeDropzone: function(element) {\n                var i, dzs = options.dropZoneElements;\n                for (i in dzs) {\n                    if (dzs[i] === element) {\n                        return dzs.splice(i, 1);\n                    }\n                }\n            },\n            dispose: function() {\n                disposeSupport.dispose();\n                qq.each(uploadDropZones, function(idx, dropZone) {\n                    dropZone.dispose();\n                });\n            }\n        });\n        this._testing = {};\n        this._testing.extractDirectoryPath = extractDirectoryPath;\n    };\n    qq.DragAndDrop.callbacks = function() {\n        \"use strict\";\n        return {\n            processingDroppedFiles: function() {},\n            processingDroppedFilesComplete: function(files, targetEl) {},\n            dropError: function(code, errorSpecifics) {\n                qq.log(\"Drag & drop error code '\" + code + \" with these specifics: '\" + errorSpecifics + \"'\", \"error\");\n            },\n            dropLog: function(message, level) {\n                qq.log(message, level);\n            }\n        };\n    };\n    qq.UploadDropZone = function(o) {\n        \"use strict\";\n        var disposeSupport = new qq.DisposeSupport(), options, element, preventDrop, dropOutsideDisabled;\n        options = {\n            element: null,\n            onEnter: function(e) {},\n            onLeave: function(e) {},\n            onLeaveNotDescendants: function(e) {},\n            onDrop: function(e) {}\n        };\n        qq.extend(options, o);\n        element = options.element;\n        function dragoverShouldBeCanceled() {\n            return qq.safari() || qq.firefox() && qq.windows();\n        }\n        function disableDropOutside(e) {\n            if (!dropOutsideDisabled) {\n                if (dragoverShouldBeCanceled) {\n                    disposeSupport.attach(document, \"dragover\", function(e) {\n                        e.preventDefault();\n                    });\n                } else {\n                    disposeSupport.attach(document, \"dragover\", function(e) {\n                        if (e.dataTransfer) {\n                            e.dataTransfer.dropEffect = \"none\";\n                            e.preventDefault();\n                        }\n                    });\n                }\n                dropOutsideDisabled = true;\n            }\n        }\n        function isValidFileDrag(e) {\n            if (!qq.supportedFeatures.fileDrop) {\n                return false;\n            }\n            var effectTest, dt = e.dataTransfer, isSafari = qq.safari();\n            effectTest = qq.ie() && qq.supportedFeatures.fileDrop ? true : dt.effectAllowed !== \"none\";\n            return dt && effectTest && (dt.files && dt.files.length || !isSafari && dt.types.contains && dt.types.contains(\"Files\") || dt.types.includes && dt.types.includes(\"Files\"));\n        }\n        function isOrSetDropDisabled(isDisabled) {\n            if (isDisabled !== undefined) {\n                preventDrop = isDisabled;\n            }\n            return preventDrop;\n        }\n        function triggerHidezonesEvent() {\n            var hideZonesEvent;\n            function triggerUsingOldApi() {\n                hideZonesEvent = document.createEvent(\"Event\");\n                hideZonesEvent.initEvent(options.HIDE_ZONES_EVENT_NAME, true, true);\n            }\n            if (window.CustomEvent) {\n                try {\n                    hideZonesEvent = new CustomEvent(options.HIDE_ZONES_EVENT_NAME);\n                } catch (err) {\n                    triggerUsingOldApi();\n                }\n            } else {\n                triggerUsingOldApi();\n            }\n            document.dispatchEvent(hideZonesEvent);\n        }\n        function attachEvents() {\n            disposeSupport.attach(element, \"dragover\", function(e) {\n                if (!isValidFileDrag(e)) {\n                    return;\n                }\n                var effect = qq.ie() && qq.supportedFeatures.fileDrop ? null : e.dataTransfer.effectAllowed;\n                if (effect === \"move\" || effect === \"linkMove\") {\n                    e.dataTransfer.dropEffect = \"move\";\n                } else {\n                    e.dataTransfer.dropEffect = \"copy\";\n                }\n                e.stopPropagation();\n                e.preventDefault();\n            });\n            disposeSupport.attach(element, \"dragenter\", function(e) {\n                if (!isOrSetDropDisabled()) {\n                    if (!isValidFileDrag(e)) {\n                        return;\n                    }\n                    options.onEnter(e);\n                }\n            });\n            disposeSupport.attach(element, \"dragleave\", function(e) {\n                if (!isValidFileDrag(e)) {\n                    return;\n                }\n                options.onLeave(e);\n                var relatedTarget = document.elementFromPoint(e.clientX, e.clientY);\n                if (qq(this).contains(relatedTarget)) {\n                    return;\n                }\n                options.onLeaveNotDescendants(e);\n            });\n            disposeSupport.attach(element, \"drop\", function(e) {\n                if (!isOrSetDropDisabled()) {\n                    if (!isValidFileDrag(e)) {\n                        return;\n                    }\n                    e.preventDefault();\n                    e.stopPropagation();\n                    options.onDrop(e);\n                    triggerHidezonesEvent();\n                }\n            });\n        }\n        disableDropOutside();\n        attachEvents();\n        qq.extend(this, {\n            dropDisabled: function(isDisabled) {\n                return isOrSetDropDisabled(isDisabled);\n            },\n            dispose: function() {\n                disposeSupport.dispose();\n            },\n            getElement: function() {\n                return element;\n            }\n        });\n        this._testing = {};\n        this._testing.isValidFileDrag = isValidFileDrag;\n    };\n    (function() {\n        \"use strict\";\n        qq.uiPublicApi = {\n            addInitialFiles: function(cannedFileList) {\n                this._parent.prototype.addInitialFiles.apply(this, arguments);\n                this._templating.addCacheToDom();\n            },\n            clearStoredFiles: function() {\n                this._parent.prototype.clearStoredFiles.apply(this, arguments);\n                this._templating.clearFiles();\n            },\n            addExtraDropzone: function(element) {\n                this._dnd && this._dnd.setupExtraDropzone(element);\n            },\n            removeExtraDropzone: function(element) {\n                if (this._dnd) {\n                    return this._dnd.removeDropzone(element);\n                }\n            },\n            getItemByFileId: function(id) {\n                if (!this._templating.isHiddenForever(id)) {\n                    return this._templating.getFileContainer(id);\n                }\n            },\n            reset: function() {\n                this._parent.prototype.reset.apply(this, arguments);\n                this._templating.reset();\n                if (!this._options.button && this._templating.getButton()) {\n                    this._defaultButtonId = this._createUploadButton({\n                        element: this._templating.getButton(),\n                        title: this._options.text.fileInputTitle\n                    }).getButtonId();\n                }\n                if (this._dnd) {\n                    this._dnd.dispose();\n                    this._dnd = this._setupDragAndDrop();\n                }\n                this._totalFilesInBatch = 0;\n                this._filesInBatchAddedToUi = 0;\n                this._setupClickAndEditEventHandlers();\n            },\n            setName: function(id, newName) {\n                var formattedFilename = this._options.formatFileName(newName);\n                this._parent.prototype.setName.apply(this, arguments);\n                this._templating.updateFilename(id, formattedFilename);\n            },\n            pauseUpload: function(id) {\n                var paused = this._parent.prototype.pauseUpload.apply(this, arguments);\n                paused && this._templating.uploadPaused(id);\n                return paused;\n            },\n            continueUpload: function(id) {\n                var continued = this._parent.prototype.continueUpload.apply(this, arguments);\n                continued && this._templating.uploadContinued(id);\n                return continued;\n            },\n            getId: function(fileContainerOrChildEl) {\n                return this._templating.getFileId(fileContainerOrChildEl);\n            },\n            getDropTarget: function(fileId) {\n                var file = this.getFile(fileId);\n                return file.qqDropTarget;\n            }\n        };\n        qq.uiPrivateApi = {\n            _getButton: function(buttonId) {\n                var button = this._parent.prototype._getButton.apply(this, arguments);\n                if (!button) {\n                    if (buttonId === this._defaultButtonId) {\n                        button = this._templating.getButton();\n                    }\n                }\n                return button;\n            },\n            _removeFileItem: function(fileId) {\n                this._templating.removeFile(fileId);\n            },\n            _setupClickAndEditEventHandlers: function() {\n                this._fileButtonsClickHandler = qq.FileButtonsClickHandler && this._bindFileButtonsClickEvent();\n                this._focusinEventSupported = !qq.firefox();\n                if (this._isEditFilenameEnabled()) {\n                    this._filenameClickHandler = this._bindFilenameClickEvent();\n                    this._filenameInputFocusInHandler = this._bindFilenameInputFocusInEvent();\n                    this._filenameInputFocusHandler = this._bindFilenameInputFocusEvent();\n                }\n            },\n            _setupDragAndDrop: function() {\n                var self = this, dropZoneElements = this._options.dragAndDrop.extraDropzones, templating = this._templating, defaultDropZone = templating.getDropZone();\n                defaultDropZone && dropZoneElements.push(defaultDropZone);\n                return new qq.DragAndDrop({\n                    dropZoneElements: dropZoneElements,\n                    allowMultipleItems: this._options.multiple,\n                    classes: {\n                        dropActive: this._options.classes.dropActive\n                    },\n                    callbacks: {\n                        processingDroppedFiles: function() {\n                            templating.showDropProcessing();\n                        },\n                        processingDroppedFilesComplete: function(files, targetEl) {\n                            templating.hideDropProcessing();\n                            qq.each(files, function(idx, file) {\n                                file.qqDropTarget = targetEl;\n                            });\n                            if (files.length) {\n                                self.addFiles(files, null, null);\n                            }\n                        },\n                        dropError: function(code, errorData) {\n                            self._itemError(code, errorData);\n                        },\n                        dropLog: function(message, level) {\n                            self.log(message, level);\n                        }\n                    }\n                });\n            },\n            _bindFileButtonsClickEvent: function() {\n                var self = this;\n                return new qq.FileButtonsClickHandler({\n                    templating: this._templating,\n                    log: function(message, lvl) {\n                        self.log(message, lvl);\n                    },\n                    onDeleteFile: function(fileId) {\n                        self.deleteFile(fileId);\n                    },\n                    onCancel: function(fileId) {\n                        self.cancel(fileId);\n                    },\n                    onRetry: function(fileId) {\n                        self.retry(fileId);\n                    },\n                    onPause: function(fileId) {\n                        self.pauseUpload(fileId);\n                    },\n                    onContinue: function(fileId) {\n                        self.continueUpload(fileId);\n                    },\n                    onGetName: function(fileId) {\n                        return self.getName(fileId);\n                    }\n                });\n            },\n            _isEditFilenameEnabled: function() {\n                return this._templating.isEditFilenamePossible() && !this._options.autoUpload && qq.FilenameClickHandler && qq.FilenameInputFocusHandler && qq.FilenameInputFocusHandler;\n            },\n            _filenameEditHandler: function() {\n                var self = this, templating = this._templating;\n                return {\n                    templating: templating,\n                    log: function(message, lvl) {\n                        self.log(message, lvl);\n                    },\n                    onGetUploadStatus: function(fileId) {\n                        return self.getUploads({\n                            id: fileId\n                        }).status;\n                    },\n                    onGetName: function(fileId) {\n                        return self.getName(fileId);\n                    },\n                    onSetName: function(id, newName) {\n                        self.setName(id, newName);\n                    },\n                    onEditingStatusChange: function(id, isEditing) {\n                        var qqInput = qq(templating.getEditInput(id)), qqFileContainer = qq(templating.getFileContainer(id));\n                        if (isEditing) {\n                            qqInput.addClass(\"qq-editing\");\n                            templating.hideFilename(id);\n                            templating.hideEditIcon(id);\n                        } else {\n                            qqInput.removeClass(\"qq-editing\");\n                            templating.showFilename(id);\n                            templating.showEditIcon(id);\n                        }\n                        qqFileContainer.addClass(\"qq-temp\").removeClass(\"qq-temp\");\n                    }\n                };\n            },\n            _onUploadStatusChange: function(id, oldStatus, newStatus) {\n                this._parent.prototype._onUploadStatusChange.apply(this, arguments);\n                if (this._isEditFilenameEnabled()) {\n                    if (this._templating.getFileContainer(id) && newStatus !== qq.status.SUBMITTED) {\n                        this._templating.markFilenameEditable(id);\n                        this._templating.hideEditIcon(id);\n                    }\n                }\n                if (oldStatus === qq.status.UPLOAD_RETRYING && newStatus === qq.status.UPLOADING) {\n                    this._templating.hideRetry(id);\n                    this._templating.setStatusText(id);\n                    qq(this._templating.getFileContainer(id)).removeClass(this._classes.retrying);\n                } else if (newStatus === qq.status.UPLOAD_FAILED) {\n                    this._templating.hidePause(id);\n                }\n            },\n            _bindFilenameInputFocusInEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameInputFocusInHandler(spec);\n            },\n            _bindFilenameInputFocusEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameInputFocusHandler(spec);\n            },\n            _bindFilenameClickEvent: function() {\n                var spec = qq.extend({}, this._filenameEditHandler());\n                return new qq.FilenameClickHandler(spec);\n            },\n            _storeForLater: function(id) {\n                this._parent.prototype._storeForLater.apply(this, arguments);\n                this._templating.hideSpinner(id);\n            },\n            _onAllComplete: function(successful, failed) {\n                this._parent.prototype._onAllComplete.apply(this, arguments);\n                this._templating.resetTotalProgress();\n            },\n            _onSubmit: function(id, name) {\n                var file = this.getFile(id);\n                if (file && file.qqPath && this._options.dragAndDrop.reportDirectoryPaths) {\n                    this._paramsStore.addReadOnly(id, {\n                        qqpath: file.qqPath\n                    });\n                }\n                this._parent.prototype._onSubmit.apply(this, arguments);\n                this._addToList(id, name);\n            },\n            _onSubmitted: function(id) {\n                if (this._isEditFilenameEnabled()) {\n                    this._templating.markFilenameEditable(id);\n                    this._templating.showEditIcon(id);\n                    if (!this._focusinEventSupported) {\n                        this._filenameInputFocusHandler.addHandler(this._templating.getEditInput(id));\n                    }\n                }\n            },\n            _onProgress: function(id, name, loaded, total) {\n                this._parent.prototype._onProgress.apply(this, arguments);\n                this._templating.updateProgress(id, loaded, total);\n                if (total === 0 || Math.round(loaded / total * 100) === 100) {\n                    this._templating.hideCancel(id);\n                    this._templating.hidePause(id);\n                    this._templating.hideProgress(id);\n                    this._templating.setStatusText(id, this._options.text.waitingForResponse);\n                    this._displayFileSize(id);\n                } else {\n                    this._displayFileSize(id, loaded, total);\n                }\n            },\n            _onTotalProgress: function(loaded, total) {\n                this._parent.prototype._onTotalProgress.apply(this, arguments);\n                this._templating.updateTotalProgress(loaded, total);\n            },\n            _onComplete: function(id, name, result, xhr) {\n                var parentRetVal = this._parent.prototype._onComplete.apply(this, arguments), templating = this._templating, fileContainer = templating.getFileContainer(id), self = this;\n                function completeUpload(result) {\n                    if (!fileContainer) {\n                        return;\n                    }\n                    templating.setStatusText(id);\n                    qq(fileContainer).removeClass(self._classes.retrying);\n                    templating.hideProgress(id);\n                    if (self.getUploads({\n                        id: id\n                    }).status !== qq.status.UPLOAD_FAILED) {\n                        templating.hideCancel(id);\n                    }\n                    templating.hideSpinner(id);\n                    if (result.success) {\n                        self._markFileAsSuccessful(id);\n                    } else {\n                        qq(fileContainer).addClass(self._classes.fail);\n                        templating.showCancel(id);\n                        if (templating.isRetryPossible() && !self._preventRetries[id]) {\n                            qq(fileContainer).addClass(self._classes.retryable);\n                            templating.showRetry(id);\n                        }\n                        self._controlFailureTextDisplay(id, result);\n                    }\n                }\n                if (parentRetVal instanceof qq.Promise) {\n                    parentRetVal.done(function(newResult) {\n                        completeUpload(newResult);\n                    });\n                } else {\n                    completeUpload(result);\n                }\n                return parentRetVal;\n            },\n            _markFileAsSuccessful: function(id) {\n                var templating = this._templating;\n                if (this._isDeletePossible()) {\n                    templating.showDeleteButton(id);\n                }\n                qq(templating.getFileContainer(id)).addClass(this._classes.success);\n                this._maybeUpdateThumbnail(id);\n            },\n            _onUploadPrep: function(id) {\n                this._parent.prototype._onUploadPrep.apply(this, arguments);\n                this._templating.showSpinner(id);\n            },\n            _onUpload: function(id, name) {\n                var parentRetVal = this._parent.prototype._onUpload.apply(this, arguments);\n                this._templating.showSpinner(id);\n                return parentRetVal;\n            },\n            _onUploadChunk: function(id, chunkData) {\n                this._parent.prototype._onUploadChunk.apply(this, arguments);\n                if (chunkData.partIndex > 0 && this._handler.isResumable(id)) {\n                    this._templating.allowPause(id);\n                }\n            },\n            _onCancel: function(id, name) {\n                this._parent.prototype._onCancel.apply(this, arguments);\n                this._removeFileItem(id);\n                if (this._getNotFinished() === 0) {\n                    this._templating.resetTotalProgress();\n                }\n            },\n            _onBeforeAutoRetry: function(id) {\n                var retryNumForDisplay, maxAuto, retryNote;\n                this._parent.prototype._onBeforeAutoRetry.apply(this, arguments);\n                this._showCancelLink(id);\n                if (this._options.retry.showAutoRetryNote) {\n                    retryNumForDisplay = this._autoRetries[id];\n                    maxAuto = this._options.retry.maxAutoAttempts;\n                    retryNote = this._options.retry.autoRetryNote.replace(/\\{retryNum\\}/g, retryNumForDisplay);\n                    retryNote = retryNote.replace(/\\{maxAuto\\}/g, maxAuto);\n                    this._templating.setStatusText(id, retryNote);\n                    qq(this._templating.getFileContainer(id)).addClass(this._classes.retrying);\n                }\n            },\n            _onBeforeManualRetry: function(id) {\n                if (this._parent.prototype._onBeforeManualRetry.apply(this, arguments)) {\n                    this._templating.resetProgress(id);\n                    qq(this._templating.getFileContainer(id)).removeClass(this._classes.fail);\n                    this._templating.setStatusText(id);\n                    this._templating.showSpinner(id);\n                    this._showCancelLink(id);\n                    return true;\n                } else {\n                    qq(this._templating.getFileContainer(id)).addClass(this._classes.retryable);\n                    this._templating.showRetry(id);\n                    return false;\n                }\n            },\n            _onSubmitDelete: function(id) {\n                var onSuccessCallback = qq.bind(this._onSubmitDeleteSuccess, this);\n                this._parent.prototype._onSubmitDelete.call(this, id, onSuccessCallback);\n            },\n            _onSubmitDeleteSuccess: function(id, uuid, additionalMandatedParams) {\n                if (this._options.deleteFile.forceConfirm) {\n                    this._showDeleteConfirm.apply(this, arguments);\n                } else {\n                    this._sendDeleteRequest.apply(this, arguments);\n                }\n            },\n            _onDeleteComplete: function(id, xhr, isError) {\n                this._parent.prototype._onDeleteComplete.apply(this, arguments);\n                this._templating.hideSpinner(id);\n                if (isError) {\n                    this._templating.setStatusText(id, this._options.deleteFile.deletingFailedText);\n                    this._templating.showDeleteButton(id);\n                } else {\n                    this._removeFileItem(id);\n                }\n            },\n            _sendDeleteRequest: function(id, uuid, additionalMandatedParams) {\n                this._templating.hideDeleteButton(id);\n                this._templating.showSpinner(id);\n                this._templating.setStatusText(id, this._options.deleteFile.deletingStatusText);\n                this._deleteHandler.sendDelete.apply(this, arguments);\n            },\n            _showDeleteConfirm: function(id, uuid, mandatedParams) {\n                var fileName = this.getName(id), confirmMessage = this._options.deleteFile.confirmMessage.replace(/\\{filename\\}/g, fileName), uuid = this.getUuid(id), deleteRequestArgs = arguments, self = this, retVal;\n                retVal = this._options.showConfirm(confirmMessage);\n                if (qq.isGenericPromise(retVal)) {\n                    retVal.then(function() {\n                        self._sendDeleteRequest.apply(self, deleteRequestArgs);\n                    });\n                } else if (retVal !== false) {\n                    self._sendDeleteRequest.apply(self, deleteRequestArgs);\n                }\n            },\n            _addToList: function(id, name, canned) {\n                var prependData, prependIndex = 0, dontDisplay = this._handler.isProxied(id) && this._options.scaling.hideScaled, record;\n                if (this._options.display.prependFiles) {\n                    if (this._totalFilesInBatch > 1 && this._filesInBatchAddedToUi > 0) {\n                        prependIndex = this._filesInBatchAddedToUi - 1;\n                    }\n                    prependData = {\n                        index: prependIndex\n                    };\n                }\n                if (!canned) {\n                    if (this._options.disableCancelForFormUploads && !qq.supportedFeatures.ajaxUploading) {\n                        this._templating.disableCancel();\n                    }\n                    if (!this._options.multiple) {\n                        record = this.getUploads({\n                            id: id\n                        });\n                        this._handledProxyGroup = this._handledProxyGroup || record.proxyGroupId;\n                        if (record.proxyGroupId !== this._handledProxyGroup || !record.proxyGroupId) {\n                            this._handler.cancelAll();\n                            this._clearList();\n                            this._handledProxyGroup = null;\n                        }\n                    }\n                }\n                if (canned) {\n                    this._templating.addFileToCache(id, this._options.formatFileName(name), prependData, dontDisplay);\n                    this._templating.updateThumbnail(id, this._thumbnailUrls[id], true, this._options.thumbnails.customResizer);\n                } else {\n                    this._templating.addFile(id, this._options.formatFileName(name), prependData, dontDisplay);\n                    this._templating.generatePreview(id, this.getFile(id), this._options.thumbnails.customResizer);\n                }\n                this._filesInBatchAddedToUi += 1;\n                if (canned || this._options.display.fileSizeOnSubmit && qq.supportedFeatures.ajaxUploading) {\n                    this._displayFileSize(id);\n                }\n            },\n            _clearList: function() {\n                this._templating.clearFiles();\n                this.clearStoredFiles();\n            },\n            _displayFileSize: function(id, loadedSize, totalSize) {\n                var size = this.getSize(id), sizeForDisplay = this._formatSize(size);\n                if (size >= 0) {\n                    if (loadedSize !== undefined && totalSize !== undefined) {\n                        sizeForDisplay = this._formatProgress(loadedSize, totalSize);\n                    }\n                    this._templating.updateSize(id, sizeForDisplay);\n                }\n            },\n            _formatProgress: function(uploadedSize, totalSize) {\n                var message = this._options.text.formatProgress;\n                function r(name, replacement) {\n                    message = message.replace(name, replacement);\n                }\n                r(\"{percent}\", Math.round(uploadedSize / totalSize * 100));\n                r(\"{total_size}\", this._formatSize(totalSize));\n                return message;\n            },\n            _controlFailureTextDisplay: function(id, response) {\n                var mode, responseProperty, failureReason;\n                mode = this._options.failedUploadTextDisplay.mode;\n                responseProperty = this._options.failedUploadTextDisplay.responseProperty;\n                if (mode === \"custom\") {\n                    failureReason = response[responseProperty];\n                    if (!failureReason) {\n                        failureReason = this._options.text.failUpload;\n                    }\n                    this._templating.setStatusText(id, failureReason);\n                    if (this._options.failedUploadTextDisplay.enableTooltip) {\n                        this._showTooltip(id, failureReason);\n                    }\n                } else if (mode === \"default\") {\n                    this._templating.setStatusText(id, this._options.text.failUpload);\n                } else if (mode !== \"none\") {\n                    this.log(\"failedUploadTextDisplay.mode value of '\" + mode + \"' is not valid\", \"warn\");\n                }\n            },\n            _showTooltip: function(id, text) {\n                this._templating.getFileContainer(id).title = text;\n            },\n            _showCancelLink: function(id) {\n                if (!this._options.disableCancelForFormUploads || qq.supportedFeatures.ajaxUploading) {\n                    this._templating.showCancel(id);\n                }\n            },\n            _itemError: function(code, name, item) {\n                var message = this._parent.prototype._itemError.apply(this, arguments);\n                this._options.showMessage(message);\n            },\n            _batchError: function(message) {\n                this._parent.prototype._batchError.apply(this, arguments);\n                this._options.showMessage(message);\n            },\n            _setupPastePrompt: function() {\n                var self = this;\n                this._options.callbacks.onPasteReceived = function() {\n                    var message = self._options.paste.namePromptMessage, defaultVal = self._options.paste.defaultName;\n                    return self._options.showPrompt(message, defaultVal);\n                };\n            },\n            _fileOrBlobRejected: function(id, name) {\n                this._totalFilesInBatch -= 1;\n                this._parent.prototype._fileOrBlobRejected.apply(this, arguments);\n            },\n            _prepareItemsForUpload: function(items, params, endpoint) {\n                this._totalFilesInBatch = items.length;\n                this._filesInBatchAddedToUi = 0;\n                this._parent.prototype._prepareItemsForUpload.apply(this, arguments);\n            },\n            _maybeUpdateThumbnail: function(fileId) {\n                var thumbnailUrl = this._thumbnailUrls[fileId], fileStatus = this.getUploads({\n                    id: fileId\n                }).status;\n                if (fileStatus !== qq.status.DELETED && (thumbnailUrl || this._options.thumbnails.placeholders.waitUntilResponse || !qq.supportedFeatures.imagePreviews)) {\n                    this._templating.updateThumbnail(fileId, thumbnailUrl, this._options.thumbnails.customResizer);\n                }\n            },\n            _addCannedFile: function(sessionData) {\n                var id = this._parent.prototype._addCannedFile.apply(this, arguments);\n                this._addToList(id, this.getName(id), true);\n                this._templating.hideSpinner(id);\n                this._templating.hideCancel(id);\n                this._markFileAsSuccessful(id);\n                return id;\n            },\n            _setSize: function(id, newSize) {\n                this._parent.prototype._setSize.apply(this, arguments);\n                this._templating.updateSize(id, this._formatSize(newSize));\n            },\n            _sessionRequestComplete: function() {\n                this._templating.addCacheToDom();\n                this._parent.prototype._sessionRequestComplete.apply(this, arguments);\n            }\n        };\n    })();\n    qq.FineUploader = function(o, namespace) {\n        \"use strict\";\n        var self = this;\n        this._parent = namespace ? qq[namespace].FineUploaderBasic : qq.FineUploaderBasic;\n        this._parent.apply(this, arguments);\n        qq.extend(this._options, {\n            element: null,\n            button: null,\n            listElement: null,\n            dragAndDrop: {\n                extraDropzones: [],\n                reportDirectoryPaths: false\n            },\n            text: {\n                formatProgress: \"{percent}% of {total_size}\",\n                failUpload: \"Upload failed\",\n                waitingForResponse: \"Processing...\",\n                paused: \"Paused\"\n            },\n            template: \"qq-template\",\n            classes: {\n                retrying: \"qq-upload-retrying\",\n                retryable: \"qq-upload-retryable\",\n                success: \"qq-upload-success\",\n                fail: \"qq-upload-fail\",\n                editable: \"qq-editable\",\n                hide: \"qq-hide\",\n                dropActive: \"qq-upload-drop-area-active\"\n            },\n            failedUploadTextDisplay: {\n                mode: \"default\",\n                responseProperty: \"error\",\n                enableTooltip: true\n            },\n            messages: {\n                tooManyFilesError: \"You may only drop one file\",\n                unsupportedBrowser: \"Unrecoverable error - this browser does not permit file uploading of any kind.\"\n            },\n            retry: {\n                showAutoRetryNote: true,\n                autoRetryNote: \"Retrying {retryNum}/{maxAuto}...\"\n            },\n            deleteFile: {\n                forceConfirm: false,\n                confirmMessage: \"Are you sure you want to delete {filename}?\",\n                deletingStatusText: \"Deleting...\",\n                deletingFailedText: \"Delete failed\"\n            },\n            display: {\n                fileSizeOnSubmit: false,\n                prependFiles: false\n            },\n            paste: {\n                promptForName: false,\n                namePromptMessage: \"Please name this image\"\n            },\n            thumbnails: {\n                customResizer: null,\n                maxCount: 0,\n                placeholders: {\n                    waitUntilResponse: false,\n                    notAvailablePath: null,\n                    waitingPath: null\n                },\n                timeBetweenThumbs: 750\n            },\n            scaling: {\n                hideScaled: false\n            },\n            showMessage: function(message) {\n                if (self._templating.hasDialog(\"alert\")) {\n                    return self._templating.showDialog(\"alert\", message);\n                } else {\n                    setTimeout(function() {\n                        window.alert(message);\n                    }, 0);\n                }\n            },\n            showConfirm: function(message) {\n                if (self._templating.hasDialog(\"confirm\")) {\n                    return self._templating.showDialog(\"confirm\", message);\n                } else {\n                    return window.confirm(message);\n                }\n            },\n            showPrompt: function(message, defaultValue) {\n                if (self._templating.hasDialog(\"prompt\")) {\n                    return self._templating.showDialog(\"prompt\", message, defaultValue);\n                } else {\n                    return window.prompt(message, defaultValue);\n                }\n            }\n        }, true);\n        qq.extend(this._options, o, true);\n        this._templating = new qq.Templating({\n            log: qq.bind(this.log, this),\n            templateIdOrEl: this._options.template,\n            containerEl: this._options.element,\n            fileContainerEl: this._options.listElement,\n            button: this._options.button,\n            imageGenerator: this._imageGenerator,\n            classes: {\n                hide: this._options.classes.hide,\n                editable: this._options.classes.editable\n            },\n            limits: {\n                maxThumbs: this._options.thumbnails.maxCount,\n                timeBetweenThumbs: this._options.thumbnails.timeBetweenThumbs\n            },\n            placeholders: {\n                waitUntilUpdate: this._options.thumbnails.placeholders.waitUntilResponse,\n                thumbnailNotAvailable: this._options.thumbnails.placeholders.notAvailablePath,\n                waitingForThumbnail: this._options.thumbnails.placeholders.waitingPath\n            },\n            text: this._options.text\n        });\n        if (this._options.workarounds.ios8SafariUploads && qq.ios800() && qq.iosSafari()) {\n            this._templating.renderFailure(this._options.messages.unsupportedBrowserIos8Safari);\n        } else if (!qq.supportedFeatures.uploading || this._options.cors.expected && !qq.supportedFeatures.uploadCors) {\n            this._templating.renderFailure(this._options.messages.unsupportedBrowser);\n        } else {\n            this._wrapCallbacks();\n            this._templating.render();\n            this._classes = this._options.classes;\n            if (!this._options.button && this._templating.getButton()) {\n                this._defaultButtonId = this._createUploadButton({\n                    element: this._templating.getButton(),\n                    title: this._options.text.fileInputTitle\n                }).getButtonId();\n            }\n            this._setupClickAndEditEventHandlers();\n            if (qq.DragAndDrop && qq.supportedFeatures.fileDrop) {\n                this._dnd = this._setupDragAndDrop();\n            }\n            if (this._options.paste.targetElement && this._options.paste.promptForName) {\n                if (qq.PasteSupport) {\n                    this._setupPastePrompt();\n                } else {\n                    this.log(\"Paste support module not found.\", \"error\");\n                }\n            }\n            this._totalFilesInBatch = 0;\n            this._filesInBatchAddedToUi = 0;\n        }\n    };\n    qq.extend(qq.FineUploader.prototype, qq.basePublicApi);\n    qq.extend(qq.FineUploader.prototype, qq.basePrivateApi);\n    qq.extend(qq.FineUploader.prototype, qq.uiPublicApi);\n    qq.extend(qq.FineUploader.prototype, qq.uiPrivateApi);\n    qq.Templating = function(spec) {\n        \"use strict\";\n        var FILE_ID_ATTR = \"qq-file-id\", FILE_CLASS_PREFIX = \"qq-file-id-\", THUMBNAIL_MAX_SIZE_ATTR = \"qq-max-size\", THUMBNAIL_SERVER_SCALE_ATTR = \"qq-server-scale\", HIDE_DROPZONE_ATTR = \"qq-hide-dropzone\", DROPZPONE_TEXT_ATTR = \"qq-drop-area-text\", IN_PROGRESS_CLASS = \"qq-in-progress\", HIDDEN_FOREVER_CLASS = \"qq-hidden-forever\", fileBatch = {\n            content: document.createDocumentFragment(),\n            map: {}\n        }, isCancelDisabled = false, generatedThumbnails = 0, thumbnailQueueMonitorRunning = false, thumbGenerationQueue = [], thumbnailMaxSize = -1, options = {\n            log: null,\n            limits: {\n                maxThumbs: 0,\n                timeBetweenThumbs: 750\n            },\n            templateIdOrEl: \"qq-template\",\n            containerEl: null,\n            fileContainerEl: null,\n            button: null,\n            imageGenerator: null,\n            classes: {\n                hide: \"qq-hide\",\n                editable: \"qq-editable\"\n            },\n            placeholders: {\n                waitUntilUpdate: false,\n                thumbnailNotAvailable: null,\n                waitingForThumbnail: null\n            },\n            text: {\n                paused: \"Paused\"\n            }\n        }, selectorClasses = {\n            button: \"qq-upload-button-selector\",\n            alertDialog: \"qq-alert-dialog-selector\",\n            dialogCancelButton: \"qq-cancel-button-selector\",\n            confirmDialog: \"qq-confirm-dialog-selector\",\n            dialogMessage: \"qq-dialog-message-selector\",\n            dialogOkButton: \"qq-ok-button-selector\",\n            promptDialog: \"qq-prompt-dialog-selector\",\n            uploader: \"qq-uploader-selector\",\n            drop: \"qq-upload-drop-area-selector\",\n            list: \"qq-upload-list-selector\",\n            progressBarContainer: \"qq-progress-bar-container-selector\",\n            progressBar: \"qq-progress-bar-selector\",\n            totalProgressBarContainer: \"qq-total-progress-bar-container-selector\",\n            totalProgressBar: \"qq-total-progress-bar-selector\",\n            file: \"qq-upload-file-selector\",\n            spinner: \"qq-upload-spinner-selector\",\n            size: \"qq-upload-size-selector\",\n            cancel: \"qq-upload-cancel-selector\",\n            pause: \"qq-upload-pause-selector\",\n            continueButton: \"qq-upload-continue-selector\",\n            deleteButton: \"qq-upload-delete-selector\",\n            retry: \"qq-upload-retry-selector\",\n            statusText: \"qq-upload-status-text-selector\",\n            editFilenameInput: \"qq-edit-filename-selector\",\n            editNameIcon: \"qq-edit-filename-icon-selector\",\n            dropText: \"qq-upload-drop-area-text-selector\",\n            dropProcessing: \"qq-drop-processing-selector\",\n            dropProcessingSpinner: \"qq-drop-processing-spinner-selector\",\n            thumbnail: \"qq-thumbnail-selector\"\n        }, previewGeneration = {}, cachedThumbnailNotAvailableImg = new qq.Promise(), cachedWaitingForThumbnailImg = new qq.Promise(), log, isEditElementsExist, isRetryElementExist, templateDom, container, fileList, showThumbnails, serverScale, cacheThumbnailPlaceholders = function() {\n            var notAvailableUrl = options.placeholders.thumbnailNotAvailable, waitingUrl = options.placeholders.waitingForThumbnail, spec = {\n                maxSize: thumbnailMaxSize,\n                scale: serverScale\n            };\n            if (showThumbnails) {\n                if (notAvailableUrl) {\n                    options.imageGenerator.generate(notAvailableUrl, new Image(), spec).then(function(updatedImg) {\n                        cachedThumbnailNotAvailableImg.success(updatedImg);\n                    }, function() {\n                        cachedThumbnailNotAvailableImg.failure();\n                        log(\"Problem loading 'not available' placeholder image at \" + notAvailableUrl, \"error\");\n                    });\n                } else {\n                    cachedThumbnailNotAvailableImg.failure();\n                }\n                if (waitingUrl) {\n                    options.imageGenerator.generate(waitingUrl, new Image(), spec).then(function(updatedImg) {\n                        cachedWaitingForThumbnailImg.success(updatedImg);\n                    }, function() {\n                        cachedWaitingForThumbnailImg.failure();\n                        log(\"Problem loading 'waiting for thumbnail' placeholder image at \" + waitingUrl, \"error\");\n                    });\n                } else {\n                    cachedWaitingForThumbnailImg.failure();\n                }\n            }\n        }, displayWaitingImg = function(thumbnail) {\n            var waitingImgPlacement = new qq.Promise();\n            cachedWaitingForThumbnailImg.then(function(img) {\n                maybeScalePlaceholderViaCss(img, thumbnail);\n                if (!thumbnail.src) {\n                    thumbnail.src = img.src;\n                    thumbnail.onload = function() {\n                        thumbnail.onload = null;\n                        show(thumbnail);\n                        waitingImgPlacement.success();\n                    };\n                } else {\n                    waitingImgPlacement.success();\n                }\n            }, function() {\n                hide(thumbnail);\n                waitingImgPlacement.success();\n            });\n            return waitingImgPlacement;\n        }, generateNewPreview = function(id, blob, spec) {\n            var thumbnail = getThumbnail(id);\n            log(\"Generating new thumbnail for \" + id);\n            blob.qqThumbnailId = id;\n            return options.imageGenerator.generate(blob, thumbnail, spec).then(function() {\n                generatedThumbnails++;\n                show(thumbnail);\n                previewGeneration[id].success();\n            }, function() {\n                previewGeneration[id].failure();\n                if (!options.placeholders.waitUntilUpdate) {\n                    maybeSetDisplayNotAvailableImg(id, thumbnail);\n                }\n            });\n        }, generateNextQueuedPreview = function() {\n            if (thumbGenerationQueue.length) {\n                thumbnailQueueMonitorRunning = true;\n                var queuedThumbRequest = thumbGenerationQueue.shift();\n                if (queuedThumbRequest.update) {\n                    processUpdateQueuedPreviewRequest(queuedThumbRequest);\n                } else {\n                    processNewQueuedPreviewRequest(queuedThumbRequest);\n                }\n            } else {\n                thumbnailQueueMonitorRunning = false;\n            }\n        }, getCancel = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.cancel);\n        }, getContinue = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.continueButton);\n        }, getDialog = function(type) {\n            return getTemplateEl(container, selectorClasses[type + \"Dialog\"]);\n        }, getDelete = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.deleteButton);\n        }, getDropProcessing = function() {\n            return getTemplateEl(container, selectorClasses.dropProcessing);\n        }, getEditIcon = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.editNameIcon);\n        }, getFile = function(id) {\n            return fileBatch.map[id] || qq(fileList).getFirstByClass(FILE_CLASS_PREFIX + id);\n        }, getFilename = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.file);\n        }, getPause = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.pause);\n        }, getProgress = function(id) {\n            if (id == null) {\n                return getTemplateEl(container, selectorClasses.totalProgressBarContainer) || getTemplateEl(container, selectorClasses.totalProgressBar);\n            }\n            return getTemplateEl(getFile(id), selectorClasses.progressBarContainer) || getTemplateEl(getFile(id), selectorClasses.progressBar);\n        }, getRetry = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.retry);\n        }, getSize = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.size);\n        }, getSpinner = function(id) {\n            return getTemplateEl(getFile(id), selectorClasses.spinner);\n        }, getTemplateEl = function(context, cssClass) {\n            return context && qq(context).getFirstByClass(cssClass);\n        }, getThumbnail = function(id) {\n            return showThumbnails && getTemplateEl(getFile(id), selectorClasses.thumbnail);\n        }, hide = function(el) {\n            el && qq(el).addClass(options.classes.hide);\n        }, maybeScalePlaceholderViaCss = function(placeholder, thumbnail) {\n            var maxWidth = placeholder.style.maxWidth, maxHeight = placeholder.style.maxHeight;\n            if (maxHeight && maxWidth && !thumbnail.style.maxWidth && !thumbnail.style.maxHeight) {\n                qq(thumbnail).css({\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight\n                });\n            }\n        }, maybeSetDisplayNotAvailableImg = function(id, thumbnail) {\n            var previewing = previewGeneration[id] || new qq.Promise().failure(), notAvailableImgPlacement = new qq.Promise();\n            cachedThumbnailNotAvailableImg.then(function(img) {\n                previewing.then(function() {\n                    notAvailableImgPlacement.success();\n                }, function() {\n                    maybeScalePlaceholderViaCss(img, thumbnail);\n                    thumbnail.onload = function() {\n                        thumbnail.onload = null;\n                        notAvailableImgPlacement.success();\n                    };\n                    thumbnail.src = img.src;\n                    show(thumbnail);\n                });\n            });\n            return notAvailableImgPlacement;\n        }, parseAndGetTemplate = function() {\n            var scriptEl, scriptHtml, fileListNode, tempTemplateEl, fileListEl, defaultButton, dropArea, thumbnail, dropProcessing, dropTextEl, uploaderEl;\n            log(\"Parsing template\");\n            if (options.templateIdOrEl == null) {\n                throw new Error(\"You MUST specify either a template element or ID!\");\n            }\n            if (qq.isString(options.templateIdOrEl)) {\n                scriptEl = document.getElementById(options.templateIdOrEl);\n                if (scriptEl === null) {\n                    throw new Error(qq.format(\"Cannot find template script at ID '{}'!\", options.templateIdOrEl));\n                }\n                scriptHtml = scriptEl.innerHTML;\n            } else {\n                if (options.templateIdOrEl.innerHTML === undefined) {\n                    throw new Error(\"You have specified an invalid value for the template option!  \" + \"It must be an ID or an Element.\");\n                }\n                scriptHtml = options.templateIdOrEl.innerHTML;\n            }\n            scriptHtml = qq.trimStr(scriptHtml);\n            tempTemplateEl = document.createElement(\"div\");\n            tempTemplateEl.appendChild(qq.toElement(scriptHtml));\n            uploaderEl = qq(tempTemplateEl).getFirstByClass(selectorClasses.uploader);\n            if (options.button) {\n                defaultButton = qq(tempTemplateEl).getFirstByClass(selectorClasses.button);\n                if (defaultButton) {\n                    qq(defaultButton).remove();\n                }\n            }\n            if (!qq.DragAndDrop || !qq.supportedFeatures.fileDrop) {\n                dropProcessing = qq(tempTemplateEl).getFirstByClass(selectorClasses.dropProcessing);\n                if (dropProcessing) {\n                    qq(dropProcessing).remove();\n                }\n            }\n            dropArea = qq(tempTemplateEl).getFirstByClass(selectorClasses.drop);\n            if (dropArea && !qq.DragAndDrop) {\n                log(\"DnD module unavailable.\", \"info\");\n                qq(dropArea).remove();\n            }\n            if (!qq.supportedFeatures.fileDrop) {\n                uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);\n                if (dropArea && qq(dropArea).hasAttribute(HIDE_DROPZONE_ATTR)) {\n                    qq(dropArea).css({\n                        display: \"none\"\n                    });\n                }\n            } else if (qq(uploaderEl).hasAttribute(DROPZPONE_TEXT_ATTR) && dropArea) {\n                dropTextEl = qq(dropArea).getFirstByClass(selectorClasses.dropText);\n                dropTextEl && qq(dropTextEl).remove();\n            }\n            thumbnail = qq(tempTemplateEl).getFirstByClass(selectorClasses.thumbnail);\n            if (!showThumbnails) {\n                thumbnail && qq(thumbnail).remove();\n            } else if (thumbnail) {\n                thumbnailMaxSize = parseInt(thumbnail.getAttribute(THUMBNAIL_MAX_SIZE_ATTR));\n                thumbnailMaxSize = thumbnailMaxSize > 0 ? thumbnailMaxSize : null;\n                serverScale = qq(thumbnail).hasAttribute(THUMBNAIL_SERVER_SCALE_ATTR);\n            }\n            showThumbnails = showThumbnails && thumbnail;\n            isEditElementsExist = qq(tempTemplateEl).getByClass(selectorClasses.editFilenameInput).length > 0;\n            isRetryElementExist = qq(tempTemplateEl).getByClass(selectorClasses.retry).length > 0;\n            fileListNode = qq(tempTemplateEl).getFirstByClass(selectorClasses.list);\n            if (fileListNode == null) {\n                throw new Error(\"Could not find the file list container in the template!\");\n            }\n            fileListEl = fileListNode.children[0].cloneNode(true);\n            fileListNode.innerHTML = \"\";\n            if (tempTemplateEl.getElementsByTagName(\"DIALOG\").length) {\n                document.createElement(\"dialog\");\n            }\n            log(\"Template parsing complete\");\n            return {\n                template: tempTemplateEl,\n                fileTemplate: fileListEl\n            };\n        }, prependFile = function(el, index, fileList) {\n            var parentEl = fileList, beforeEl = parentEl.firstChild;\n            if (index > 0) {\n                beforeEl = qq(parentEl).children()[index].nextSibling;\n            }\n            parentEl.insertBefore(el, beforeEl);\n        }, processNewQueuedPreviewRequest = function(queuedThumbRequest) {\n            var id = queuedThumbRequest.id, optFileOrBlob = queuedThumbRequest.optFileOrBlob, relatedThumbnailId = optFileOrBlob && optFileOrBlob.qqThumbnailId, thumbnail = getThumbnail(id), spec = {\n                customResizeFunction: queuedThumbRequest.customResizeFunction,\n                maxSize: thumbnailMaxSize,\n                orient: true,\n                scale: true\n            };\n            if (qq.supportedFeatures.imagePreviews) {\n                if (thumbnail) {\n                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {\n                        maybeSetDisplayNotAvailableImg(id, thumbnail);\n                        generateNextQueuedPreview();\n                    } else {\n                        displayWaitingImg(thumbnail).done(function() {\n                            previewGeneration[id] = new qq.Promise();\n                            previewGeneration[id].done(function() {\n                                setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                            });\n                            if (relatedThumbnailId != null) {\n                                useCachedPreview(id, relatedThumbnailId);\n                            } else {\n                                generateNewPreview(id, optFileOrBlob, spec);\n                            }\n                        });\n                    }\n                } else {\n                    generateNextQueuedPreview();\n                }\n            } else if (thumbnail) {\n                displayWaitingImg(thumbnail);\n                generateNextQueuedPreview();\n            }\n        }, processUpdateQueuedPreviewRequest = function(queuedThumbRequest) {\n            var id = queuedThumbRequest.id, thumbnailUrl = queuedThumbRequest.thumbnailUrl, showWaitingImg = queuedThumbRequest.showWaitingImg, thumbnail = getThumbnail(id), spec = {\n                customResizeFunction: queuedThumbRequest.customResizeFunction,\n                scale: serverScale,\n                maxSize: thumbnailMaxSize\n            };\n            if (thumbnail) {\n                if (thumbnailUrl) {\n                    if (options.limits.maxThumbs && options.limits.maxThumbs <= generatedThumbnails) {\n                        maybeSetDisplayNotAvailableImg(id, thumbnail);\n                        generateNextQueuedPreview();\n                    } else {\n                        if (showWaitingImg) {\n                            displayWaitingImg(thumbnail);\n                        }\n                        return options.imageGenerator.generate(thumbnailUrl, thumbnail, spec).then(function() {\n                            show(thumbnail);\n                            generatedThumbnails++;\n                            setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                        }, function() {\n                            maybeSetDisplayNotAvailableImg(id, thumbnail);\n                            setTimeout(generateNextQueuedPreview, options.limits.timeBetweenThumbs);\n                        });\n                    }\n                } else {\n                    maybeSetDisplayNotAvailableImg(id, thumbnail);\n                    generateNextQueuedPreview();\n                }\n            }\n        }, setProgressBarWidth = function(id, percent) {\n            var bar = getProgress(id), progressBarSelector = id == null ? selectorClasses.totalProgressBar : selectorClasses.progressBar;\n            if (bar && !qq(bar).hasClass(progressBarSelector)) {\n                bar = qq(bar).getFirstByClass(progressBarSelector);\n            }\n            if (bar) {\n                qq(bar).css({\n                    width: percent + \"%\"\n                });\n                bar.setAttribute(\"aria-valuenow\", percent);\n            }\n        }, show = function(el) {\n            el && qq(el).removeClass(options.classes.hide);\n        }, useCachedPreview = function(targetThumbnailId, cachedThumbnailId) {\n            var targetThumbnail = getThumbnail(targetThumbnailId), cachedThumbnail = getThumbnail(cachedThumbnailId);\n            log(qq.format(\"ID {} is the same file as ID {}.  Will use generated thumbnail from ID {} instead.\", targetThumbnailId, cachedThumbnailId, cachedThumbnailId));\n            previewGeneration[cachedThumbnailId].then(function() {\n                generatedThumbnails++;\n                previewGeneration[targetThumbnailId].success();\n                log(qq.format(\"Now using previously generated thumbnail created for ID {} on ID {}.\", cachedThumbnailId, targetThumbnailId));\n                targetThumbnail.src = cachedThumbnail.src;\n                show(targetThumbnail);\n            }, function() {\n                previewGeneration[targetThumbnailId].failure();\n                if (!options.placeholders.waitUntilUpdate) {\n                    maybeSetDisplayNotAvailableImg(targetThumbnailId, targetThumbnail);\n                }\n            });\n        };\n        qq.extend(options, spec);\n        log = options.log;\n        if (!qq.supportedFeatures.imagePreviews) {\n            options.limits.timeBetweenThumbs = 0;\n            options.limits.maxThumbs = 0;\n        }\n        container = options.containerEl;\n        showThumbnails = options.imageGenerator !== undefined;\n        templateDom = parseAndGetTemplate();\n        cacheThumbnailPlaceholders();\n        qq.extend(this, {\n            render: function() {\n                log(\"Rendering template in DOM.\");\n                generatedThumbnails = 0;\n                container.appendChild(templateDom.template.cloneNode(true));\n                hide(getDropProcessing());\n                this.hideTotalProgress();\n                fileList = options.fileContainerEl || getTemplateEl(container, selectorClasses.list);\n                log(\"Template rendering complete\");\n            },\n            renderFailure: function(message) {\n                var cantRenderEl = qq.toElement(message);\n                container.innerHTML = \"\";\n                container.appendChild(cantRenderEl);\n            },\n            reset: function() {\n                container.innerHTML = \"\";\n                this.render();\n            },\n            clearFiles: function() {\n                fileList.innerHTML = \"\";\n            },\n            disableCancel: function() {\n                isCancelDisabled = true;\n            },\n            addFile: function(id, name, prependInfo, hideForever, batch) {\n                var fileEl = templateDom.fileTemplate.cloneNode(true), fileNameEl = getTemplateEl(fileEl, selectorClasses.file), uploaderEl = getTemplateEl(container, selectorClasses.uploader), fileContainer = batch ? fileBatch.content : fileList, thumb;\n                if (batch) {\n                    fileBatch.map[id] = fileEl;\n                }\n                qq(fileEl).addClass(FILE_CLASS_PREFIX + id);\n                uploaderEl.removeAttribute(DROPZPONE_TEXT_ATTR);\n                if (fileNameEl) {\n                    qq(fileNameEl).setText(name);\n                    fileNameEl.setAttribute(\"title\", name);\n                }\n                fileEl.setAttribute(FILE_ID_ATTR, id);\n                if (prependInfo) {\n                    prependFile(fileEl, prependInfo.index, fileContainer);\n                } else {\n                    fileContainer.appendChild(fileEl);\n                }\n                if (hideForever) {\n                    fileEl.style.display = \"none\";\n                    qq(fileEl).addClass(HIDDEN_FOREVER_CLASS);\n                } else {\n                    hide(getProgress(id));\n                    hide(getSize(id));\n                    hide(getDelete(id));\n                    hide(getRetry(id));\n                    hide(getPause(id));\n                    hide(getContinue(id));\n                    if (isCancelDisabled) {\n                        this.hideCancel(id);\n                    }\n                    thumb = getThumbnail(id);\n                    if (thumb && !thumb.src) {\n                        cachedWaitingForThumbnailImg.then(function(waitingImg) {\n                            thumb.src = waitingImg.src;\n                            if (waitingImg.style.maxHeight && waitingImg.style.maxWidth) {\n                                qq(thumb).css({\n                                    maxHeight: waitingImg.style.maxHeight,\n                                    maxWidth: waitingImg.style.maxWidth\n                                });\n                            }\n                            show(thumb);\n                        });\n                    }\n                }\n            },\n            addFileToCache: function(id, name, prependInfo, hideForever) {\n                this.addFile(id, name, prependInfo, hideForever, true);\n            },\n            addCacheToDom: function() {\n                fileList.appendChild(fileBatch.content);\n                fileBatch.content = document.createDocumentFragment();\n                fileBatch.map = {};\n            },\n            removeFile: function(id) {\n                qq(getFile(id)).remove();\n            },\n            getFileId: function(el) {\n                var currentNode = el;\n                if (currentNode) {\n                    while (currentNode.getAttribute(FILE_ID_ATTR) == null) {\n                        currentNode = currentNode.parentNode;\n                    }\n                    return parseInt(currentNode.getAttribute(FILE_ID_ATTR));\n                }\n            },\n            getFileList: function() {\n                return fileList;\n            },\n            markFilenameEditable: function(id) {\n                var filename = getFilename(id);\n                filename && qq(filename).addClass(options.classes.editable);\n            },\n            updateFilename: function(id, name) {\n                var filenameEl = getFilename(id);\n                if (filenameEl) {\n                    qq(filenameEl).setText(name);\n                    filenameEl.setAttribute(\"title\", name);\n                }\n            },\n            hideFilename: function(id) {\n                hide(getFilename(id));\n            },\n            showFilename: function(id) {\n                show(getFilename(id));\n            },\n            isFileName: function(el) {\n                return qq(el).hasClass(selectorClasses.file);\n            },\n            getButton: function() {\n                return options.button || getTemplateEl(container, selectorClasses.button);\n            },\n            hideDropProcessing: function() {\n                hide(getDropProcessing());\n            },\n            showDropProcessing: function() {\n                show(getDropProcessing());\n            },\n            getDropZone: function() {\n                return getTemplateEl(container, selectorClasses.drop);\n            },\n            isEditFilenamePossible: function() {\n                return isEditElementsExist;\n            },\n            hideRetry: function(id) {\n                hide(getRetry(id));\n            },\n            isRetryPossible: function() {\n                return isRetryElementExist;\n            },\n            showRetry: function(id) {\n                show(getRetry(id));\n            },\n            getFileContainer: function(id) {\n                return getFile(id);\n            },\n            showEditIcon: function(id) {\n                var icon = getEditIcon(id);\n                icon && qq(icon).addClass(options.classes.editable);\n            },\n            isHiddenForever: function(id) {\n                return qq(getFile(id)).hasClass(HIDDEN_FOREVER_CLASS);\n            },\n            hideEditIcon: function(id) {\n                var icon = getEditIcon(id);\n                icon && qq(icon).removeClass(options.classes.editable);\n            },\n            isEditIcon: function(el) {\n                return qq(el).hasClass(selectorClasses.editNameIcon, true);\n            },\n            getEditInput: function(id) {\n                return getTemplateEl(getFile(id), selectorClasses.editFilenameInput);\n            },\n            isEditInput: function(el) {\n                return qq(el).hasClass(selectorClasses.editFilenameInput, true);\n            },\n            updateProgress: function(id, loaded, total) {\n                var bar = getProgress(id), percent;\n                if (bar && total > 0) {\n                    percent = Math.round(loaded / total * 100);\n                    if (percent === 100) {\n                        hide(bar);\n                    } else {\n                        show(bar);\n                    }\n                    setProgressBarWidth(id, percent);\n                }\n            },\n            updateTotalProgress: function(loaded, total) {\n                this.updateProgress(null, loaded, total);\n            },\n            hideProgress: function(id) {\n                var bar = getProgress(id);\n                bar && hide(bar);\n            },\n            hideTotalProgress: function() {\n                this.hideProgress();\n            },\n            resetProgress: function(id) {\n                setProgressBarWidth(id, 0);\n                this.hideTotalProgress(id);\n            },\n            resetTotalProgress: function() {\n                this.resetProgress();\n            },\n            showCancel: function(id) {\n                if (!isCancelDisabled) {\n                    var cancel = getCancel(id);\n                    cancel && qq(cancel).removeClass(options.classes.hide);\n                }\n            },\n            hideCancel: function(id) {\n                hide(getCancel(id));\n            },\n            isCancel: function(el) {\n                return qq(el).hasClass(selectorClasses.cancel, true);\n            },\n            allowPause: function(id) {\n                show(getPause(id));\n                hide(getContinue(id));\n            },\n            uploadPaused: function(id) {\n                this.setStatusText(id, options.text.paused);\n                this.allowContinueButton(id);\n                hide(getSpinner(id));\n            },\n            hidePause: function(id) {\n                hide(getPause(id));\n            },\n            isPause: function(el) {\n                return qq(el).hasClass(selectorClasses.pause, true);\n            },\n            isContinueButton: function(el) {\n                return qq(el).hasClass(selectorClasses.continueButton, true);\n            },\n            allowContinueButton: function(id) {\n                show(getContinue(id));\n                hide(getPause(id));\n            },\n            uploadContinued: function(id) {\n                this.setStatusText(id, \"\");\n                this.allowPause(id);\n                show(getSpinner(id));\n            },\n            showDeleteButton: function(id) {\n                show(getDelete(id));\n            },\n            hideDeleteButton: function(id) {\n                hide(getDelete(id));\n            },\n            isDeleteButton: function(el) {\n                return qq(el).hasClass(selectorClasses.deleteButton, true);\n            },\n            isRetry: function(el) {\n                return qq(el).hasClass(selectorClasses.retry, true);\n            },\n            updateSize: function(id, text) {\n                var size = getSize(id);\n                if (size) {\n                    show(size);\n                    qq(size).setText(text);\n                }\n            },\n            setStatusText: function(id, text) {\n                var textEl = getTemplateEl(getFile(id), selectorClasses.statusText);\n                if (textEl) {\n                    if (text == null) {\n                        qq(textEl).clearText();\n                    } else {\n                        qq(textEl).setText(text);\n                    }\n                }\n            },\n            hideSpinner: function(id) {\n                qq(getFile(id)).removeClass(IN_PROGRESS_CLASS);\n                hide(getSpinner(id));\n            },\n            showSpinner: function(id) {\n                qq(getFile(id)).addClass(IN_PROGRESS_CLASS);\n                show(getSpinner(id));\n            },\n            generatePreview: function(id, optFileOrBlob, customResizeFunction) {\n                if (!this.isHiddenForever(id)) {\n                    thumbGenerationQueue.push({\n                        id: id,\n                        customResizeFunction: customResizeFunction,\n                        optFileOrBlob: optFileOrBlob\n                    });\n                    !thumbnailQueueMonitorRunning && generateNextQueuedPreview();\n                }\n            },\n            updateThumbnail: function(id, thumbnailUrl, showWaitingImg, customResizeFunction) {\n                if (!this.isHiddenForever(id)) {\n                    thumbGenerationQueue.push({\n                        customResizeFunction: customResizeFunction,\n                        update: true,\n                        id: id,\n                        thumbnailUrl: thumbnailUrl,\n                        showWaitingImg: showWaitingImg\n                    });\n                    !thumbnailQueueMonitorRunning && generateNextQueuedPreview();\n                }\n            },\n            hasDialog: function(type) {\n                return qq.supportedFeatures.dialogElement && !!getDialog(type);\n            },\n            showDialog: function(type, message, defaultValue) {\n                var dialog = getDialog(type), messageEl = getTemplateEl(dialog, selectorClasses.dialogMessage), inputEl = dialog.getElementsByTagName(\"INPUT\")[0], cancelBtn = getTemplateEl(dialog, selectorClasses.dialogCancelButton), okBtn = getTemplateEl(dialog, selectorClasses.dialogOkButton), promise = new qq.Promise(), closeHandler = function() {\n                    cancelBtn.removeEventListener(\"click\", cancelClickHandler);\n                    okBtn && okBtn.removeEventListener(\"click\", okClickHandler);\n                    promise.failure();\n                }, cancelClickHandler = function() {\n                    cancelBtn.removeEventListener(\"click\", cancelClickHandler);\n                    dialog.close();\n                }, okClickHandler = function() {\n                    dialog.removeEventListener(\"close\", closeHandler);\n                    okBtn.removeEventListener(\"click\", okClickHandler);\n                    dialog.close();\n                    promise.success(inputEl && inputEl.value);\n                };\n                dialog.addEventListener(\"close\", closeHandler);\n                cancelBtn.addEventListener(\"click\", cancelClickHandler);\n                okBtn && okBtn.addEventListener(\"click\", okClickHandler);\n                if (inputEl) {\n                    inputEl.value = defaultValue;\n                }\n                messageEl.textContent = message;\n                dialog.showModal();\n                return promise;\n            }\n        });\n    };\n    qq.UiEventHandler = function(s, protectedApi) {\n        \"use strict\";\n        var disposer = new qq.DisposeSupport(), spec = {\n            eventType: \"click\",\n            attachTo: null,\n            onHandled: function(target, event) {}\n        };\n        qq.extend(this, {\n            addHandler: function(element) {\n                addHandler(element);\n            },\n            dispose: function() {\n                disposer.dispose();\n            }\n        });\n        function addHandler(element) {\n            disposer.attach(element, spec.eventType, function(event) {\n                event = event || window.event;\n                var target = event.target || event.srcElement;\n                spec.onHandled(target, event);\n            });\n        }\n        qq.extend(protectedApi, {\n            getFileIdFromItem: function(item) {\n                return item.qqFileId;\n            },\n            getDisposeSupport: function() {\n                return disposer;\n            }\n        });\n        qq.extend(spec, s);\n        if (spec.attachTo) {\n            addHandler(spec.attachTo);\n        }\n    };\n    qq.FileButtonsClickHandler = function(s) {\n        \"use strict\";\n        var inheritedInternalApi = {}, spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            onDeleteFile: function(fileId) {},\n            onCancel: function(fileId) {},\n            onRetry: function(fileId) {},\n            onPause: function(fileId) {},\n            onContinue: function(fileId) {},\n            onGetName: function(fileId) {}\n        }, buttonHandlers = {\n            cancel: function(id) {\n                spec.onCancel(id);\n            },\n            retry: function(id) {\n                spec.onRetry(id);\n            },\n            deleteButton: function(id) {\n                spec.onDeleteFile(id);\n            },\n            pause: function(id) {\n                spec.onPause(id);\n            },\n            continueButton: function(id) {\n                spec.onContinue(id);\n            }\n        };\n        function examineEvent(target, event) {\n            qq.each(buttonHandlers, function(buttonType, handler) {\n                var firstLetterCapButtonType = buttonType.charAt(0).toUpperCase() + buttonType.slice(1), fileId;\n                if (spec.templating[\"is\" + firstLetterCapButtonType](target)) {\n                    fileId = spec.templating.getFileId(target);\n                    qq.preventDefault(event);\n                    spec.log(qq.format(\"Detected valid file button click event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    handler(fileId);\n                    return false;\n                }\n            });\n        }\n        qq.extend(spec, s);\n        spec.eventType = \"click\";\n        spec.onHandled = examineEvent;\n        spec.attachTo = spec.templating.getFileList();\n        qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameClickHandler = function(s) {\n        \"use strict\";\n        var inheritedInternalApi = {}, spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            classes: {\n                file: \"qq-upload-file\",\n                editNameIcon: \"qq-edit-filename-icon\"\n            },\n            onGetUploadStatus: function(fileId) {},\n            onGetName: function(fileId) {}\n        };\n        qq.extend(spec, s);\n        function examineEvent(target, event) {\n            if (spec.templating.isFileName(target) || spec.templating.isEditIcon(target)) {\n                var fileId = spec.templating.getFileId(target), status = spec.onGetUploadStatus(fileId);\n                if (status === qq.status.SUBMITTED) {\n                    spec.log(qq.format(\"Detected valid filename click event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    qq.preventDefault(event);\n                    inheritedInternalApi.handleFilenameEdit(fileId, target, true);\n                }\n            }\n        }\n        spec.eventType = \"click\";\n        spec.onHandled = examineEvent;\n        qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameInputFocusInHandler = function(s, inheritedInternalApi) {\n        \"use strict\";\n        var spec = {\n            templating: null,\n            onGetUploadStatus: function(fileId) {},\n            log: function(message, lvl) {}\n        };\n        if (!inheritedInternalApi) {\n            inheritedInternalApi = {};\n        }\n        function handleInputFocus(target, event) {\n            if (spec.templating.isEditInput(target)) {\n                var fileId = spec.templating.getFileId(target), status = spec.onGetUploadStatus(fileId);\n                if (status === qq.status.SUBMITTED) {\n                    spec.log(qq.format(\"Detected valid filename input focus event on file '{}', ID: {}.\", spec.onGetName(fileId), fileId));\n                    inheritedInternalApi.handleFilenameEdit(fileId, target);\n                }\n            }\n        }\n        spec.eventType = \"focusin\";\n        spec.onHandled = handleInputFocus;\n        qq.extend(spec, s);\n        qq.extend(this, new qq.FilenameEditHandler(spec, inheritedInternalApi));\n    };\n    qq.FilenameInputFocusHandler = function(spec) {\n        \"use strict\";\n        spec.eventType = \"focus\";\n        spec.attachTo = null;\n        qq.extend(this, new qq.FilenameInputFocusInHandler(spec, {}));\n    };\n    qq.FilenameEditHandler = function(s, inheritedInternalApi) {\n        \"use strict\";\n        var spec = {\n            templating: null,\n            log: function(message, lvl) {},\n            onGetUploadStatus: function(fileId) {},\n            onGetName: function(fileId) {},\n            onSetName: function(fileId, newName) {},\n            onEditingStatusChange: function(fileId, isEditing) {}\n        };\n        function getFilenameSansExtension(fileId) {\n            var filenameSansExt = spec.onGetName(fileId), extIdx = filenameSansExt.lastIndexOf(\".\");\n            if (extIdx > 0) {\n                filenameSansExt = filenameSansExt.substr(0, extIdx);\n            }\n            return filenameSansExt;\n        }\n        function getOriginalExtension(fileId) {\n            var origName = spec.onGetName(fileId);\n            return qq.getExtension(origName);\n        }\n        function handleNameUpdate(newFilenameInputEl, fileId) {\n            var newName = newFilenameInputEl.value, origExtension;\n            if (newName !== undefined && qq.trimStr(newName).length > 0) {\n                origExtension = getOriginalExtension(fileId);\n                if (origExtension !== undefined) {\n                    newName = newName + \".\" + origExtension;\n                }\n                spec.onSetName(fileId, newName);\n            }\n            spec.onEditingStatusChange(fileId, false);\n        }\n        function registerInputBlurHandler(inputEl, fileId) {\n            inheritedInternalApi.getDisposeSupport().attach(inputEl, \"blur\", function() {\n                handleNameUpdate(inputEl, fileId);\n            });\n        }\n        function registerInputEnterKeyHandler(inputEl, fileId) {\n            inheritedInternalApi.getDisposeSupport().attach(inputEl, \"keyup\", function(event) {\n                var code = event.keyCode || event.which;\n                if (code === 13) {\n                    handleNameUpdate(inputEl, fileId);\n                }\n            });\n        }\n        qq.extend(spec, s);\n        spec.attachTo = spec.templating.getFileList();\n        qq.extend(this, new qq.UiEventHandler(spec, inheritedInternalApi));\n        qq.extend(inheritedInternalApi, {\n            handleFilenameEdit: function(id, target, focusInput) {\n                var newFilenameInputEl = spec.templating.getEditInput(id);\n                spec.onEditingStatusChange(id, true);\n                newFilenameInputEl.value = getFilenameSansExtension(id);\n                if (focusInput) {\n                    newFilenameInputEl.focus();\n                }\n                registerInputBlurHandler(newFilenameInputEl, id);\n                registerInputEnterKeyHandler(newFilenameInputEl, id);\n            }\n        });\n    };\n})(window);\n//# sourceMappingURL=fine-uploader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmluZS11cGxvYWRlci9maW5lLXVwbG9hZGVyL2ZpbmUtdXBsb2FkZXIuanM/YjkwNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWUscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxzRUFBc0UsSUFBSTtBQUMxRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELElBQUk7QUFDN0Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix3RUFBd0UsSUFBSTtBQUM1RTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHNFQUFzRSxJQUFJO0FBQzFFO0FBQ0EsaUJBQWlCO0FBQ2pCLHFFQUFxRSxJQUFJO0FBQ3pFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLGFBQWE7QUFDYixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsU0FBUyxlQUFlO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNi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Q1Q7QUFDQSxDQUFDO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmluZS11cGxvYWRlci9maW5lLXVwbG9hZGVyL2ZpbmUtdXBsb2FkZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaW5lIFVwbG9hZGVyIDUuMTYuMiAtIE1JVCBsaWNlbnNlZC4gaHR0cDovL2ZpbmV1cGxvYWRlci5jb21cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgICB2YXIgcXEgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXR0YWNoOiBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgZm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxKGVsZW1lbnQpLmRldGFjaCh0eXBlLCBmbik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKHR5cGUsIGZuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5kZXRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBmdW5jdGlvbihkZXNjZW5kYW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXNjZW5kYW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IGRlc2NlbmRhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNvbnRhaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNvbnRhaW5zKGRlc2NlbmRhbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIShkZXNjZW5kYW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQpICYgOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24oZWxlbWVudEIpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Qi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBlbGVtZW50Qik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3NzOiBmdW5jdGlvbihzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdHlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBxcS5FcnJvcihcIkNhbid0IGFwcGx5IHN0eWxlIHRvIG5vZGUgYXMgaXQgaXMgbm90IG9uIHRoZSBIVE1MRWxlbWVudCBwcm90b3R5cGUgY2hhaW4hXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVzLm9wYWNpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQuc3R5bGUub3BhY2l0eSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZWxlbWVudC5maWx0ZXJzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMuZmlsdGVyID0gXCJhbHBoYShvcGFjaXR5PVwiICsgTWF0aC5yb3VuZCgxMDAgKiBzdHlsZXMub3BhY2l0eSkgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxcS5leHRlbmQoZWxlbWVudC5zdHlsZSwgc3R5bGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24obmFtZSwgY29uc2lkZXJQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiKF58IClcIiArIG5hbWUgKyBcIiggfCQpXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZS50ZXN0KGVsZW1lbnQuY2xhc3NOYW1lKSB8fCAhIShjb25zaWRlclBhcmVudCAmJiByZS50ZXN0KGVsZW1lbnQucGFyZW50Tm9kZS5jbGFzc05hbWUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghcXEoZWxlbWVudCkuaGFzQ2xhc3MobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gXCIgXCIgKyBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCIoXnwgKVwiICsgbmFtZSArIFwiKCB8JClcIik7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKHJlLCBcIiBcIikucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnlDbGFzczogZnVuY3Rpb24oY2xhc3NOYW1lLCBmaXJzdCkge1xuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVzLCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QgJiYgZWxlbWVudC5xdWVyeVNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuXCIgKyBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIik7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChjYW5kaWRhdGVzLCBmdW5jdGlvbihpZHgsIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEodmFsKS5oYXNDbGFzcyhjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEZpcnN0QnlDbGFzczogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxKGVsZW1lbnQpLmdldEJ5Q2xhc3MoY2xhc3NOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW10sIGNoaWxkID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRUZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbm5lclRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFyVGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxKGVsZW1lbnQpLnNldFRleHQoXCJcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzQXR0cmlidXRlOiBmdW5jdGlvbihhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvXmZhbHNlJC9pLmV4ZWMoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKSA9PSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJWYWwgPSBlbGVtZW50W2F0dHJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJWYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvXmZhbHNlJC9pLmV4ZWMoYXR0clZhbCkgPT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBxcS5jYW52YXNUb0Jsb2IgPSBmdW5jdGlvbihjYW52YXMsIG1pbWUsIHF1YWxpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBxcS5kYXRhVXJpVG9CbG9iKGNhbnZhcy50b0RhdGFVUkwobWltZSwgcXVhbGl0eSkpO1xuICAgICAgICB9O1xuICAgICAgICBxcS5kYXRhVXJpVG9CbG9iID0gZnVuY3Rpb24oZGF0YVVyaSkge1xuICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyLCBieXRlU3RyaW5nLCBjcmVhdGVCbG9iID0gZnVuY3Rpb24oZGF0YSwgbWltZSkge1xuICAgICAgICAgICAgICAgIHZhciBCbG9iQnVpbGRlciA9IHdpbmRvdy5CbG9iQnVpbGRlciB8fCB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8IHdpbmRvdy5NU0Jsb2JCdWlsZGVyLCBibG9iQnVpbGRlciA9IEJsb2JCdWlsZGVyICYmIG5ldyBCbG9iQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgIGlmIChibG9iQnVpbGRlcikge1xuICAgICAgICAgICAgICAgICAgICBibG9iQnVpbGRlci5hcHBlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9iQnVpbGRlci5nZXRCbG9iKG1pbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihbIGRhdGEgXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbWltZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBpbnRBcnJheSwgbWltZVN0cmluZztcbiAgICAgICAgICAgIGlmIChkYXRhVXJpLnNwbGl0KFwiLFwiKVswXS5pbmRleE9mKFwiYmFzZTY0XCIpID49IDApIHtcbiAgICAgICAgICAgICAgICBieXRlU3RyaW5nID0gYXRvYihkYXRhVXJpLnNwbGl0KFwiLFwiKVsxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ5dGVTdHJpbmcgPSBkZWNvZGVVUkkoZGF0YVVyaS5zcGxpdChcIixcIilbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWltZVN0cmluZyA9IGRhdGFVcmkuc3BsaXQoXCIsXCIpWzBdLnNwbGl0KFwiOlwiKVsxXS5zcGxpdChcIjtcIilbMF07XG4gICAgICAgICAgICBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgIHFxLmVhY2goYnl0ZVN0cmluZywgZnVuY3Rpb24oaWR4LCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICBpbnRBcnJheVtpZHhdID0gY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVCbG9iKGFycmF5QnVmZmVyLCBtaW1lU3RyaW5nKTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEubG9nID0gZnVuY3Rpb24obWVzc2FnZSwgbGV2ZWwpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGV2ZWwgfHwgbGV2ZWwgPT09IFwiaW5mb1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmNvbnNvbGVbbGV2ZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZVtsZXZlbF0obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coXCI8XCIgKyBsZXZlbCArIFwiPiBcIiArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBxcS5pc09iamVjdCA9IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFyaWFibGUgJiYgIXZhcmlhYmxlLm5vZGVUeXBlICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YXJpYWJsZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YXJpYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YXJpYWJsZSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICB9O1xuICAgICAgICBxcS5pc0FycmF5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgQXJyYXldXCIgfHwgdmFsdWUgJiYgd2luZG93LkFycmF5QnVmZmVyICYmIHZhbHVlLmJ1ZmZlciAmJiB2YWx1ZS5idWZmZXIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyO1xuICAgICAgICB9O1xuICAgICAgICBxcS5pc0l0ZW1MaXN0ID0gZnVuY3Rpb24obWF5YmVJdGVtTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXliZUl0ZW1MaXN0KSA9PT0gXCJbb2JqZWN0IERhdGFUcmFuc2Zlckl0ZW1MaXN0XVwiO1xuICAgICAgICB9O1xuICAgICAgICBxcS5pc05vZGVMaXN0ID0gZnVuY3Rpb24obWF5YmVOb2RlTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXliZU5vZGVMaXN0KSA9PT0gXCJbb2JqZWN0IE5vZGVMaXN0XVwiIHx8IG1heWJlTm9kZUxpc3QuaXRlbSAmJiBtYXliZU5vZGVMaXN0Lm5hbWVkSXRlbTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaXNTdHJpbmcgPSBmdW5jdGlvbihtYXliZVN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXliZVN0cmluZykgPT09IFwiW29iamVjdCBTdHJpbmddXCI7XG4gICAgICAgIH07XG4gICAgICAgIHFxLnRyaW1TdHIgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChTdHJpbmcucHJvdG90eXBlLnRyaW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmZvcm1hdCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBuZXdTdHIgPSBzdHIsIG5leHRJZHhUb1JlcGxhY2UgPSBuZXdTdHIuaW5kZXhPZihcInt9XCIpO1xuICAgICAgICAgICAgcXEuZWFjaChhcmdzLCBmdW5jdGlvbihpZHgsIHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJCZWZvcmUgPSBuZXdTdHIuc3Vic3RyaW5nKDAsIG5leHRJZHhUb1JlcGxhY2UpLCBzdHJBZnRlciA9IG5ld1N0ci5zdWJzdHJpbmcobmV4dElkeFRvUmVwbGFjZSArIDIpO1xuICAgICAgICAgICAgICAgIG5ld1N0ciA9IHN0ckJlZm9yZSArIHZhbCArIHN0ckFmdGVyO1xuICAgICAgICAgICAgICAgIG5leHRJZHhUb1JlcGxhY2UgPSBuZXdTdHIuaW5kZXhPZihcInt9XCIsIG5leHRJZHhUb1JlcGxhY2UgKyB2YWwubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dElkeFRvUmVwbGFjZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0cjtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaXNGaWxlID0gZnVuY3Rpb24obWF5YmVGaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LkZpbGUgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1heWJlRmlsZSkgPT09IFwiW29iamVjdCBGaWxlXVwiO1xuICAgICAgICB9O1xuICAgICAgICBxcS5pc0ZpbGVMaXN0ID0gZnVuY3Rpb24obWF5YmVGaWxlTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5GaWxlTGlzdCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWF5YmVGaWxlTGlzdCkgPT09IFwiW29iamVjdCBGaWxlTGlzdF1cIjtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaXNGaWxlT3JJbnB1dCA9IGZ1bmN0aW9uKG1heWJlRmlsZU9ySW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBxcS5pc0ZpbGUobWF5YmVGaWxlT3JJbnB1dCkgfHwgcXEuaXNJbnB1dChtYXliZUZpbGVPcklucHV0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaXNJbnB1dCA9IGZ1bmN0aW9uKG1heWJlSW5wdXQsIG5vdEZpbGUpIHtcbiAgICAgICAgICAgIHZhciBldmFsdWF0ZVR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRUeXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub3RGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkVHlwZSAhPT0gXCJmaWxlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkVHlwZSA9PT0gXCJmaWxlXCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5IVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXliZUlucHV0KSA9PT0gXCJbb2JqZWN0IEhUTUxJbnB1dEVsZW1lbnRdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlSW5wdXQudHlwZSAmJiBldmFsdWF0ZVR5cGUobWF5YmVJbnB1dC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF5YmVJbnB1dC50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlSW5wdXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlSW5wdXQudHlwZSAmJiBldmFsdWF0ZVR5cGUobWF5YmVJbnB1dC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlzQmxvYiA9IGZ1bmN0aW9uKG1heWJlQmxvYikge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5CbG9iICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXliZUJsb2IpID09PSBcIltvYmplY3QgQmxvYl1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBxcS5pc1hoclVwbG9hZFN1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgaW5wdXQudHlwZSA9IFwiZmlsZVwiO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm11bHRpcGxlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBxcS5jcmVhdGVYaHJJbnN0YW5jZSgpLnVwbG9hZCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuY3JlYXRlWGhySW5zdGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1TWE1MMi5YTUxIVFRQLjMuMFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcXEubG9nKFwiTmVpdGhlciBYSFIgb3IgQWN0aXZlWCBhcmUgc3VwcG9ydGVkIVwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBxcS5pc0ZvbGRlckRyb3BTdXBwb3J0ZWQgPSBmdW5jdGlvbihkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhVHJhbnNmZXIuaXRlbXMgJiYgZGF0YVRyYW5zZmVyLml0ZW1zLmxlbmd0aCA+IDAgJiYgZGF0YVRyYW5zZmVyLml0ZW1zWzBdLndlYmtpdEdldEFzRW50cnk7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlzRmlsZUNodW5raW5nU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gIXFxLmFuZHJvaWRTdG9jaygpICYmIHFxLmlzWGhyVXBsb2FkU3VwcG9ydGVkKCkgJiYgKEZpbGUucHJvdG90eXBlLnNsaWNlICE9PSB1bmRlZmluZWQgfHwgRmlsZS5wcm90b3R5cGUud2Via2l0U2xpY2UgIT09IHVuZGVmaW5lZCB8fCBGaWxlLnByb3RvdHlwZS5tb3pTbGljZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuc2xpY2VCbG9iID0gZnVuY3Rpb24oZmlsZU9yQmxvYiwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgdmFyIHNsaWNlciA9IGZpbGVPckJsb2Iuc2xpY2UgfHwgZmlsZU9yQmxvYi5tb3pTbGljZSB8fCBmaWxlT3JCbG9iLndlYmtpdFNsaWNlO1xuICAgICAgICAgICAgcmV0dXJuIHNsaWNlci5jYWxsKGZpbGVPckJsb2IsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9O1xuICAgICAgICBxcS5hcnJheUJ1ZmZlclRvSGV4ID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZXNBc0hleCA9IFwiXCIsIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIHFxLmVhY2goYnl0ZXMsIGZ1bmN0aW9uKGlkeCwgYnl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGVBc0hleFN0ciA9IGJ5dC50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVBc0hleFN0ci5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVBc0hleFN0ciA9IFwiMFwiICsgYnl0ZUFzSGV4U3RyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieXRlc0FzSGV4ICs9IGJ5dGVBc0hleFN0cjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzQXNIZXg7XG4gICAgICAgIH07XG4gICAgICAgIHFxLnJlYWRCbG9iVG9IZXggPSBmdW5jdGlvbihibG9iLCBzdGFydE9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbEJsb2IgPSBxcS5zbGljZUJsb2IoYmxvYiwgc3RhcnRPZmZzZXQsIHN0YXJ0T2Zmc2V0ICsgbGVuZ3RoKSwgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCksIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MocXEuYXJyYXlCdWZmZXJUb0hleChmaWxlUmVhZGVyLnJlc3VsdCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IHByb21pc2UuZmFpbHVyZTtcbiAgICAgICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoaW5pdGlhbEJsb2IpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZCA9IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQsIGV4dGVuZE5lc3RlZCkge1xuICAgICAgICAgICAgcXEuZWFjaChzZWNvbmQsIGZ1bmN0aW9uKHByb3AsIHZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChleHRlbmROZXN0ZWQgJiYgcXEuaXNPYmplY3QodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBxcS5leHRlbmQoZmlyc3RbcHJvcF0sIHZhbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3Q7XG4gICAgICAgIH07XG4gICAgICAgIHFxLm92ZXJyaWRlID0gZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2VGbikge1xuICAgICAgICAgICAgdmFyIHN1cGVyXyA9IHt9LCBzb3VyY2UgPSBzb3VyY2VGbihzdXBlcl8pO1xuICAgICAgICAgICAgcXEuZWFjaChzb3VyY2UsIGZ1bmN0aW9uKHNyY1Byb3BOYW1lLCBzcmNQcm9wVmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFtzcmNQcm9wTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcl9bc3JjUHJvcE5hbWVdID0gdGFyZ2V0W3NyY1Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3NyY1Byb3BOYW1lXSA9IHNyY1Byb3BWYWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmluZGV4T2YgPSBmdW5jdGlvbihhcnIsIGVsdCwgZnJvbSkge1xuICAgICAgICAgICAgaWYgKGFyci5pbmRleE9mKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKGVsdCwgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tID0gZnJvbSB8fCAwO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgICAgICAgICBmcm9tICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoO2Zyb20gPCBsZW47IGZyb20gKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChhcnIuaGFzT3duUHJvcGVydHkoZnJvbSkgJiYgYXJyW2Zyb21dID09PSBlbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgICAgICBxcS5nZXRVbmlxdWVJZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLCB2ID0gYyA9PSBcInhcIiA/IHIgOiByICYgMyB8IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmllID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSAhPT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiVHJpZGVudFwiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmllNyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUUgN1wiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmllOCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUUgOFwiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmllMTAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFIDEwXCIpICE9PSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaWUxMSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHFxLmllKCkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwicnY6MTFcIikgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgICBxcS5lZGdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiRWRnZVwiKSA+PSAwO1xuICAgICAgICB9O1xuICAgICAgICBxcS5zYWZhcmkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IudmVuZG9yICE9PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnZlbmRvci5pbmRleE9mKFwiQXBwbGVcIikgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgICBxcS5jaHJvbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IudmVuZG9yICE9PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnZlbmRvci5pbmRleE9mKFwiR29vZ2xlXCIpICE9PSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEub3BlcmEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IudmVuZG9yICE9PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnZlbmRvci5pbmRleE9mKFwiT3BlcmFcIikgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgICBxcS5maXJlZm94ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gIXFxLmVkZ2UoKSAmJiAhcXEuaWUxMSgpICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1vemlsbGFcIikgIT09IC0xICYmIG5hdmlnYXRvci52ZW5kb3IgIT09IHVuZGVmaW5lZCAmJiBuYXZpZ2F0b3IudmVuZG9yID09PSBcIlwiO1xuICAgICAgICB9O1xuICAgICAgICBxcS53aW5kb3dzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLnBsYXRmb3JtID09PSBcIldpbjMyXCI7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmFuZHJvaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImFuZHJvaWRcIikgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgICBxcS5hbmRyb2lkU3RvY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBxcS5hbmRyb2lkKCkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJjaHJvbWVcIikgPCAwO1xuICAgICAgICB9O1xuICAgICAgICBxcS5pb3M2ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcXEuaW9zKCkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiIE9TIDZfXCIpICE9PSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaW9zNyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHFxLmlvcygpICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIiBPUyA3X1wiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlvczggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBxcS5pb3MoKSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCIgT1MgOF9cIikgIT09IC0xO1xuICAgICAgICB9O1xuICAgICAgICBxcS5pb3M4MDAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBxcS5pb3MoKSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCIgT1MgOF8wIFwiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlvcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcImlQYWRcIikgIT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcImlQb2RcIikgIT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcImlQaG9uZVwiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlvc0Nocm9tZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHFxLmlvcygpICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkNyaU9TXCIpICE9PSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuaW9zU2FmYXJpID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcXEuaW9zKCkgJiYgIXFxLmlvc0Nocm9tZSgpICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIlNhZmFyaVwiKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmlvc1NhZmFyaVdlYlZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBxcS5pb3MoKSAmJiAhcXEuaW9zQ2hyb21lKCkgJiYgIXFxLmlvc1NhZmFyaSgpO1xuICAgICAgICB9O1xuICAgICAgICBxcS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHFxLnRvRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZGl2LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpO1xuICAgICAgICBxcS5lYWNoID0gZnVuY3Rpb24oaXRlcmFibGVJdGVtLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGtleU9ySW5kZXgsIHJldFZhbDtcbiAgICAgICAgICAgIGlmIChpdGVyYWJsZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LlN0b3JhZ2UgJiYgaXRlcmFibGVJdGVtLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuU3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleU9ySW5kZXggPSAwOyBrZXlPckluZGV4IDwgaXRlcmFibGVJdGVtLmxlbmd0aDsga2V5T3JJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRWYWwgPSBjYWxsYmFjayhpdGVyYWJsZUl0ZW0ua2V5KGtleU9ySW5kZXgpLCBpdGVyYWJsZUl0ZW0uZ2V0SXRlbShpdGVyYWJsZUl0ZW0ua2V5KGtleU9ySW5kZXgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0VmFsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxcS5pc0FycmF5KGl0ZXJhYmxlSXRlbSkgfHwgcXEuaXNJdGVtTGlzdChpdGVyYWJsZUl0ZW0pIHx8IHFxLmlzTm9kZUxpc3QoaXRlcmFibGVJdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleU9ySW5kZXggPSAwOyBrZXlPckluZGV4IDwgaXRlcmFibGVJdGVtLmxlbmd0aDsga2V5T3JJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRWYWwgPSBjYWxsYmFjayhrZXlPckluZGV4LCBpdGVyYWJsZUl0ZW1ba2V5T3JJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldFZhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocXEuaXNTdHJpbmcoaXRlcmFibGVJdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleU9ySW5kZXggPSAwOyBrZXlPckluZGV4IDwgaXRlcmFibGVJdGVtLmxlbmd0aDsga2V5T3JJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRWYWwgPSBjYWxsYmFjayhrZXlPckluZGV4LCBpdGVyYWJsZUl0ZW0uY2hhckF0KGtleU9ySW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRWYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleU9ySW5kZXggaW4gaXRlcmFibGVJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZXJhYmxlSXRlbSwga2V5T3JJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRWYWwgPSBjYWxsYmFjayhrZXlPckluZGV4LCBpdGVyYWJsZUl0ZW1ba2V5T3JJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRWYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEuYmluZCA9IGZ1bmN0aW9uKG9sZEZ1bmMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChxcS5pc0Z1bmN0aW9uKG9sZEZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0FyZ3MgPSBxcS5leHRlbmQoW10sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QXJncyA9IG5ld0FyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRGdW5jLmFwcGx5KGNvbnRleHQsIG5ld0FyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uIVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEub2JqMnVybCA9IGZ1bmN0aW9uKG9iaiwgdGVtcCwgcHJlZml4RG9uZSkge1xuICAgICAgICAgICAgdmFyIHVyaXN0cmluZ3MgPSBbXSwgcHJlZml4ID0gXCImXCIsIGFkZCA9IGZ1bmN0aW9uKG5leHRPYmosIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFRlbXAgPSB0ZW1wID8gL1xcW1xcXSQvLnRlc3QodGVtcCkgPyB0ZW1wIDogdGVtcCArIFwiW1wiICsgaSArIFwiXVwiIDogaTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFRlbXAgIT09IFwidW5kZWZpbmVkXCIgJiYgaSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB1cmlzdHJpbmdzLnB1c2godHlwZW9mIG5leHRPYmogPT09IFwib2JqZWN0XCIgPyBxcS5vYmoydXJsKG5leHRPYmosIG5leHRUZW1wLCB0cnVlKSA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXh0T2JqKSA9PT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiID8gZW5jb2RlVVJJQ29tcG9uZW50KG5leHRUZW1wKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KG5leHRPYmooKSkgOiBlbmNvZGVVUklDb21wb25lbnQobmV4dFRlbXApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQobmV4dE9iaikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXByZWZpeERvbmUgJiYgdGVtcCkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IC9cXD8vLnRlc3QodGVtcCkgPyAvXFw/JC8udGVzdCh0ZW1wKSA/IFwiXCIgOiBcIiZcIiA6IFwiP1wiO1xuICAgICAgICAgICAgICAgIHVyaXN0cmluZ3MucHVzaCh0ZW1wKTtcbiAgICAgICAgICAgICAgICB1cmlzdHJpbmdzLnB1c2gocXEub2JqMnVybChvYmopKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIiAmJiB0eXBlb2Ygb2JqICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChvYmosIGZ1bmN0aW9uKGlkeCwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZCh2YWwsIGlkeCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKG9iaiwgZnVuY3Rpb24ocHJvcCwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZCh2YWwsIHByb3ApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmlzdHJpbmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHRlbXApICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQob2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVtcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmlzdHJpbmdzLmpvaW4ocHJlZml4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVyaXN0cmluZ3Muam9pbihwcmVmaXgpLnJlcGxhY2UoL14mLywgXCJcIikucmVwbGFjZSgvJTIwL2csIFwiK1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEub2JqMkZvcm1EYXRhID0gZnVuY3Rpb24ob2JqLCBmb3JtRGF0YSwgYXJyYXlLZXlOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFxLmVhY2gob2JqLCBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgIGtleSA9IGFycmF5S2V5TmFtZSA/IGFycmF5S2V5TmFtZSArIFwiW1wiICsga2V5ICsgXCJdXCIgOiBrZXk7XG4gICAgICAgICAgICAgICAgaWYgKHFxLmlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEub2JqMkZvcm1EYXRhKHZhbCwgZm9ybURhdGEsIGtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChxcS5pc0Z1bmN0aW9uKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsKCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm9ybURhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHFxLm9iajJJbnB1dHMgPSBmdW5jdGlvbihvYmosIGZvcm0pIHtcbiAgICAgICAgICAgIHZhciBpbnB1dDtcbiAgICAgICAgICAgIGlmICghZm9ybSkge1xuICAgICAgICAgICAgICAgIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFxLm9iajJGb3JtRGF0YShvYmosIHtcbiAgICAgICAgICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm07XG4gICAgICAgIH07XG4gICAgICAgIHFxLnBhcnNlSnNvbiA9IGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuSlNPTiAmJiBxcS5pc0Z1bmN0aW9uKEpTT04ucGFyc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmFsKFwiKFwiICsganNvbiArIFwiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEuZ2V0RXh0ZW5zaW9uID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIHZhciBleHRJZHggPSBmaWxlbmFtZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxO1xuICAgICAgICAgICAgaWYgKGV4dElkeCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZW5hbWUuc3Vic3RyKGV4dElkeCwgZmlsZW5hbWUubGVuZ3RoIC0gZXh0SWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEuZ2V0RmlsZW5hbWUgPSBmdW5jdGlvbihibG9iT3JGaWxlSW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChxcS5pc0lucHV0KGJsb2JPckZpbGVJbnB1dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvYk9yRmlsZUlucHV0LnZhbHVlLnJlcGxhY2UoLy4qKFxcL3xcXFxcKS8sIFwiXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChxcS5pc0ZpbGUoYmxvYk9yRmlsZUlucHV0KSkge1xuICAgICAgICAgICAgICAgIGlmIChibG9iT3JGaWxlSW5wdXQuZmlsZU5hbWUgIT09IG51bGwgJiYgYmxvYk9yRmlsZUlucHV0LmZpbGVOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2JPckZpbGVJbnB1dC5maWxlTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmxvYk9yRmlsZUlucHV0Lm5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIHFxLkRpc3Bvc2VTdXBwb3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGlzcG9zZXJzID0gW107XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzcG9zZXI7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VyID0gZGlzcG9zZXJzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcG9zZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwb3NlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChkaXNwb3Nlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhdHRhY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGREaXNwb3NlcihxcShhcmdzWzBdKS5hdHRhY2guYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWRkRGlzcG9zZXI6IGZ1bmN0aW9uKGRpc3Bvc2VGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlcnMucHVzaChkaXNwb3NlRnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHFxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLnFxID0gcXE7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHFxLkVycm9yID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJbRmluZSBVcGxvYWRlciBcIiArIHFxLnZlcnNpb24gKyBcIl0gXCIgKyBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBxcS5FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICB9KSgpO1xuICAgIHFxLnZlcnNpb24gPSBcIjUuMTYuMlwiO1xuICAgIHFxLnN1cHBvcnRlZEZlYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgc3VwcG9ydHNVcGxvYWRpbmcsIHN1cHBvcnRzVXBsb2FkaW5nQmxvYnMsIHN1cHBvcnRzRmlsZURyb3AsIHN1cHBvcnRzQWpheEZpbGVVcGxvYWRpbmcsIHN1cHBvcnRzRm9sZGVyRHJvcCwgc3VwcG9ydHNDaHVua2luZywgc3VwcG9ydHNSZXN1bWUsIHN1cHBvcnRzVXBsb2FkVmlhUGFzdGUsIHN1cHBvcnRzVXBsb2FkQ29ycywgc3VwcG9ydHNEZWxldGVGaWxlWGRyLCBzdXBwb3J0c0RlbGV0ZUZpbGVDb3JzWGhyLCBzdXBwb3J0c0RlbGV0ZUZpbGVDb3JzLCBzdXBwb3J0c0ZvbGRlclNlbGVjdGlvbiwgc3VwcG9ydHNJbWFnZVByZXZpZXdzLCBzdXBwb3J0c1VwbG9hZFByb2dyZXNzO1xuICAgICAgICBmdW5jdGlvbiB0ZXN0U3VwcG9ydHNGaWxlSW5wdXRFbGVtZW50KCkge1xuICAgICAgICAgICAgdmFyIHN1cHBvcnRlZCA9IHRydWUsIHRlbXBJbnB1dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGVtcElucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgICAgIHRlbXBJbnB1dC50eXBlID0gXCJmaWxlXCI7XG4gICAgICAgICAgICAgICAgcXEodGVtcElucHV0KS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBJbnB1dC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0Nocm9tZTE0T3JIaWdoZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHFxLmNocm9tZSgpIHx8IHFxLm9wZXJhKCkpICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcL1sxXVs0LTldfENocm9tZVxcL1syLTldWzAtOV0vKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQ3Jvc3NPcmlnaW5YaHJTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHhociA9IHFxLmNyZWF0ZVhockluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhoci53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1hkclN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuWERvbWFpblJlcXVlc3QgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0Nyb3NzT3JpZ2luQWpheFN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIGlmIChpc0Nyb3NzT3JpZ2luWGhyU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1hkclN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRm9sZGVyU2VsZWN0aW9uU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKS53ZWJraXRkaXJlY3RvcnkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0xvY2FsU3RvcmFnZVN1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhd2luZG93LmxvY2FsU3RvcmFnZSAmJiBxcS5pc0Z1bmN0aW9uKHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0RyYWdBbmREcm9wU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIHJldHVybiAoXCJkcmFnZ2FibGVcIiBpbiBzcGFuIHx8IFwib25kcmFnc3RhcnRcIiBpbiBzcGFuICYmIFwib25kcm9wXCIgaW4gc3BhbikgJiYgIXFxLmFuZHJvaWQoKSAmJiAhcXEuaW9zKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwcG9ydHNVcGxvYWRpbmcgPSB0ZXN0U3VwcG9ydHNGaWxlSW5wdXRFbGVtZW50KCk7XG4gICAgICAgIHN1cHBvcnRzQWpheEZpbGVVcGxvYWRpbmcgPSBzdXBwb3J0c1VwbG9hZGluZyAmJiBxcS5pc1hoclVwbG9hZFN1cHBvcnRlZCgpO1xuICAgICAgICBzdXBwb3J0c1VwbG9hZGluZ0Jsb2JzID0gc3VwcG9ydHNBamF4RmlsZVVwbG9hZGluZyAmJiAhcXEuYW5kcm9pZFN0b2NrKCk7XG4gICAgICAgIHN1cHBvcnRzRmlsZURyb3AgPSBzdXBwb3J0c0FqYXhGaWxlVXBsb2FkaW5nICYmIGlzRHJhZ0FuZERyb3BTdXBwb3J0ZWQoKTtcbiAgICAgICAgc3VwcG9ydHNGb2xkZXJEcm9wID0gc3VwcG9ydHNGaWxlRHJvcCAmJiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgIGlucHV0LnR5cGUgPSBcImZpbGVcIjtcbiAgICAgICAgICAgIHJldHVybiAhIShcIndlYmtpdGRpcmVjdG9yeVwiIGluIChpbnB1dCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRbdHlwZT1maWxlXVwiKVswXSkpO1xuICAgICAgICB9KCk7XG4gICAgICAgIHN1cHBvcnRzQ2h1bmtpbmcgPSBzdXBwb3J0c0FqYXhGaWxlVXBsb2FkaW5nICYmIHFxLmlzRmlsZUNodW5raW5nU3VwcG9ydGVkKCk7XG4gICAgICAgIHN1cHBvcnRzUmVzdW1lID0gc3VwcG9ydHNBamF4RmlsZVVwbG9hZGluZyAmJiBzdXBwb3J0c0NodW5raW5nICYmIGlzTG9jYWxTdG9yYWdlU3VwcG9ydGVkKCk7XG4gICAgICAgIHN1cHBvcnRzVXBsb2FkVmlhUGFzdGUgPSBzdXBwb3J0c0FqYXhGaWxlVXBsb2FkaW5nICYmIGlzQ2hyb21lMTRPckhpZ2hlcigpO1xuICAgICAgICBzdXBwb3J0c1VwbG9hZENvcnMgPSBzdXBwb3J0c1VwbG9hZGluZyAmJiAod2luZG93LnBvc3RNZXNzYWdlICE9PSB1bmRlZmluZWQgfHwgc3VwcG9ydHNBamF4RmlsZVVwbG9hZGluZyk7XG4gICAgICAgIHN1cHBvcnRzRGVsZXRlRmlsZUNvcnNYaHIgPSBpc0Nyb3NzT3JpZ2luWGhyU3VwcG9ydGVkKCk7XG4gICAgICAgIHN1cHBvcnRzRGVsZXRlRmlsZVhkciA9IGlzWGRyU3VwcG9ydGVkKCk7XG4gICAgICAgIHN1cHBvcnRzRGVsZXRlRmlsZUNvcnMgPSBpc0Nyb3NzT3JpZ2luQWpheFN1cHBvcnRlZCgpO1xuICAgICAgICBzdXBwb3J0c0ZvbGRlclNlbGVjdGlvbiA9IGlzRm9sZGVyU2VsZWN0aW9uU3VwcG9ydGVkKCk7XG4gICAgICAgIHN1cHBvcnRzSW1hZ2VQcmV2aWV3cyA9IHN1cHBvcnRzQWpheEZpbGVVcGxvYWRpbmcgJiYgd2luZG93LkZpbGVSZWFkZXIgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzQWpheEZpbGVVcGxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXFxLmFuZHJvaWRTdG9jaygpICYmICFxcS5pb3NDaHJvbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWpheFVwbG9hZGluZzogc3VwcG9ydHNBamF4RmlsZVVwbG9hZGluZyxcbiAgICAgICAgICAgIGJsb2JVcGxvYWRpbmc6IHN1cHBvcnRzVXBsb2FkaW5nQmxvYnMsXG4gICAgICAgICAgICBjYW5EZXRlcm1pbmVTaXplOiBzdXBwb3J0c0FqYXhGaWxlVXBsb2FkaW5nLFxuICAgICAgICAgICAgY2h1bmtpbmc6IHN1cHBvcnRzQ2h1bmtpbmcsXG4gICAgICAgICAgICBkZWxldGVGaWxlQ29yczogc3VwcG9ydHNEZWxldGVGaWxlQ29ycyxcbiAgICAgICAgICAgIGRlbGV0ZUZpbGVDb3JzWGRyOiBzdXBwb3J0c0RlbGV0ZUZpbGVYZHIsXG4gICAgICAgICAgICBkZWxldGVGaWxlQ29yc1hocjogc3VwcG9ydHNEZWxldGVGaWxlQ29yc1hocixcbiAgICAgICAgICAgIGRpYWxvZ0VsZW1lbnQ6ICEhd2luZG93LkhUTUxEaWFsb2dFbGVtZW50LFxuICAgICAgICAgICAgZmlsZURyb3A6IHN1cHBvcnRzRmlsZURyb3AsXG4gICAgICAgICAgICBmb2xkZXJEcm9wOiBzdXBwb3J0c0ZvbGRlckRyb3AsXG4gICAgICAgICAgICBmb2xkZXJTZWxlY3Rpb246IHN1cHBvcnRzRm9sZGVyU2VsZWN0aW9uLFxuICAgICAgICAgICAgaW1hZ2VQcmV2aWV3czogc3VwcG9ydHNJbWFnZVByZXZpZXdzLFxuICAgICAgICAgICAgaW1hZ2VWYWxpZGF0aW9uOiBzdXBwb3J0c0ltYWdlUHJldmlld3MsXG4gICAgICAgICAgICBpdGVtU2l6ZVZhbGlkYXRpb246IHN1cHBvcnRzQWpheEZpbGVVcGxvYWRpbmcsXG4gICAgICAgICAgICBwYXVzZTogc3VwcG9ydHNDaHVua2luZyxcbiAgICAgICAgICAgIHByb2dyZXNzQmFyOiBzdXBwb3J0c1VwbG9hZFByb2dyZXNzLFxuICAgICAgICAgICAgcmVzdW1lOiBzdXBwb3J0c1Jlc3VtZSxcbiAgICAgICAgICAgIHNjYWxpbmc6IHN1cHBvcnRzSW1hZ2VQcmV2aWV3cyAmJiBzdXBwb3J0c1VwbG9hZGluZ0Jsb2JzLFxuICAgICAgICAgICAgdGlmZlByZXZpZXdzOiBxcS5zYWZhcmkoKSxcbiAgICAgICAgICAgIHVubGltaXRlZFNjYWxlZEltYWdlU2l6ZTogIXFxLmlvcygpLFxuICAgICAgICAgICAgdXBsb2FkaW5nOiBzdXBwb3J0c1VwbG9hZGluZyxcbiAgICAgICAgICAgIHVwbG9hZENvcnM6IHN1cHBvcnRzVXBsb2FkQ29ycyxcbiAgICAgICAgICAgIHVwbG9hZEN1c3RvbUhlYWRlcnM6IHN1cHBvcnRzQWpheEZpbGVVcGxvYWRpbmcsXG4gICAgICAgICAgICB1cGxvYWROb25NdWx0aXBhcnQ6IHN1cHBvcnRzQWpheEZpbGVVcGxvYWRpbmcsXG4gICAgICAgICAgICB1cGxvYWRWaWFQYXN0ZTogc3VwcG9ydHNVcGxvYWRWaWFQYXN0ZVxuICAgICAgICB9O1xuICAgIH0oKTtcbiAgICBxcS5pc0dlbmVyaWNQcm9taXNlID0gZnVuY3Rpb24obWF5YmVQcm9taXNlKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICByZXR1cm4gISEobWF5YmVQcm9taXNlICYmIG1heWJlUHJvbWlzZS50aGVuICYmIHFxLmlzRnVuY3Rpb24obWF5YmVQcm9taXNlLnRoZW4pKTtcbiAgICB9O1xuICAgIHFxLlByb21pc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBzdWNjZXNzQXJncywgZmFpbHVyZUFyZ3MsIHN1Y2Nlc3NDYWxsYmFja3MgPSBbXSwgZmFpbHVyZUNhbGxiYWNrcyA9IFtdLCBkb25lQ2FsbGJhY2tzID0gW10sIHN0YXRlID0gMDtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIHRoZW46IGZ1bmN0aW9uKG9uU3VjY2Vzcywgb25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFja3MucHVzaChvblN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVDYWxsYmFja3MucHVzaChvbkZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgb25GYWlsdXJlICYmIG9uRmFpbHVyZS5hcHBseShudWxsLCBmYWlsdXJlQXJncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzLmFwcGx5KG51bGwsIHN1Y2Nlc3NBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBmYWlsdXJlQXJncyA9PT0gdW5kZWZpbmVkID8gc3VjY2Vzc0FyZ3MgOiBmYWlsdXJlQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzQXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc0NhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChzdWNjZXNzQ2FsbGJhY2tzLCBmdW5jdGlvbihpZHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBzdWNjZXNzQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZG9uZUNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChkb25lQ2FsbGJhY2tzLCBmdW5jdGlvbihpZHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBzdWNjZXNzQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWlsdXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IC0xO1xuICAgICAgICAgICAgICAgIGZhaWx1cmVBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIGlmIChmYWlsdXJlQ2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBxcS5lYWNoKGZhaWx1cmVDYWxsYmFja3MsIGZ1bmN0aW9uKGlkeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGZhaWx1cmVBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkb25lQ2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBxcS5lYWNoKGRvbmVDYWxsYmFja3MsIGZ1bmN0aW9uKGlkeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGZhaWx1cmVBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLkJsb2JQcm94eSA9IGZ1bmN0aW9uKHJlZmVyZW5jZUJsb2IsIG9uQ3JlYXRlKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBxcS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgcmVmZXJlbmNlQmxvYjogcmVmZXJlbmNlQmxvYixcbiAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uQ3JlYXRlKHJlZmVyZW5jZUJsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLlVwbG9hZEJ1dHRvbiA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgZGlzcG9zZVN1cHBvcnQgPSBuZXcgcXEuRGlzcG9zZVN1cHBvcnQoKSwgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFjY2VwdEZpbGVzOiBudWxsLFxuICAgICAgICAgICAgZWxlbWVudDogbnVsbCxcbiAgICAgICAgICAgIGZvY3VzQ2xhc3M6IFwicXEtdXBsb2FkLWJ1dHRvbi1mb2N1c1wiLFxuICAgICAgICAgICAgZm9sZGVyczogZmFsc2UsXG4gICAgICAgICAgICBob3ZlckNsYXNzOiBcInFxLXVwbG9hZC1idXR0b24taG92ZXJcIixcbiAgICAgICAgICAgIGlvczhCcm93c2VyQ3Jhc2hXb3JrYXJvdW5kOiBmYWxzZSxcbiAgICAgICAgICAgIG11bHRpcGxlOiBmYWxzZSxcbiAgICAgICAgICAgIG5hbWU6IFwicXFmaWxlXCIsXG4gICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24oaW5wdXQpIHt9LFxuICAgICAgICAgICAgdGl0bGU6IG51bGxcbiAgICAgICAgfSwgaW5wdXQsIGJ1dHRvbklkO1xuICAgICAgICBxcS5leHRlbmQob3B0aW9ucywgbyk7XG4gICAgICAgIGJ1dHRvbklkID0gcXEuZ2V0VW5pcXVlSWQoKTtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlSW5wdXQoKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUocXEuVXBsb2FkQnV0dG9uLkJVVFRPTl9JRF9BVFRSX05BTUUsIGJ1dHRvbklkKTtcbiAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIG9wdGlvbnMudGl0bGUpO1xuICAgICAgICAgICAgc2VsZi5zZXRNdWx0aXBsZShvcHRpb25zLm11bHRpcGxlLCBpbnB1dCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mb2xkZXJzICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLmZvbGRlclNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcIndlYmtpdGRpcmVjdG9yeVwiLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFjY2VwdEZpbGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiYWNjZXB0XCIsIG9wdGlvbnMuYWNjZXB0RmlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImZpbGVcIik7XG4gICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIG9wdGlvbnMubmFtZSk7XG4gICAgICAgICAgICBxcShpbnB1dCkuY3NzKHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBcIkFyaWFsXCIsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IHFxLmllKCkgJiYgIXFxLmllOCgpID8gXCIzNTAwcHhcIiA6IFwiMTE4cHhcIixcbiAgICAgICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgIXFxLmllNygpICYmIHFxKGlucHV0KS5jc3Moe1xuICAgICAgICAgICAgICAgIGhlaWdodDogXCIxMDAlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3B0aW9ucy5lbGVtZW50LmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgICAgIGRpc3Bvc2VTdXBwb3J0LmF0dGFjaChpbnB1dCwgXCJjaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vbkNoYW5nZShpbnB1dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3Bvc2VTdXBwb3J0LmF0dGFjaChpbnB1dCwgXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcXEob3B0aW9ucy5lbGVtZW50KS5hZGRDbGFzcyhvcHRpb25zLmhvdmVyQ2xhc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goaW5wdXQsIFwibW91c2VvdXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcXEob3B0aW9ucy5lbGVtZW50KS5yZW1vdmVDbGFzcyhvcHRpb25zLmhvdmVyQ2xhc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goaW5wdXQsIFwiZm9jdXNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcXEob3B0aW9ucy5lbGVtZW50KS5hZGRDbGFzcyhvcHRpb25zLmZvY3VzQ2xhc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goaW5wdXQsIFwiYmx1clwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBxcShvcHRpb25zLmVsZW1lbnQpLnJlbW92ZUNsYXNzKG9wdGlvbnMuZm9jdXNDbGFzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBxcShvcHRpb25zLmVsZW1lbnQpLmNzcyh7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwibHRyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBnZXRJbnB1dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEJ1dHRvbklkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnV0dG9uSWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0TXVsdGlwbGU6IGZ1bmN0aW9uKGlzTXVsdGlwbGUsIG9wdElucHV0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gb3B0SW5wdXQgfHwgdGhpcy5nZXRJbnB1dCgpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmlvczhCcm93c2VyQ3Jhc2hXb3JrYXJvdW5kICYmIHFxLmlvczgoKSAmJiAocXEuaW9zQ2hyb21lKCkgfHwgcXEuaW9zU2FmYXJpV2ViVmlldygpKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRBY2NlcHRGaWxlczogZnVuY3Rpb24oYWNjZXB0RmlsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWNjZXB0RmlsZXMgIT09IG9wdGlvbnMuYWNjZXB0RmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiYWNjZXB0XCIsIGFjY2VwdEZpbGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxKGlucHV0KS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXEob3B0aW9ucy5lbGVtZW50KS5yZW1vdmVDbGFzcyhvcHRpb25zLmZvY3VzQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGlucHV0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGNyZWF0ZUlucHV0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dCA9IGNyZWF0ZUlucHV0KCk7XG4gICAgfTtcbiAgICBxcS5VcGxvYWRCdXR0b24uQlVUVE9OX0lEX0FUVFJfTkFNRSA9IFwicXEtYnV0dG9uLWlkXCI7XG4gICAgcXEuVXBsb2FkRGF0YSA9IGZ1bmN0aW9uKHVwbG9hZGVyUHJveHkpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBkYXRhID0gW10sIGJ5VXVpZCA9IHt9LCBieVN0YXR1cyA9IHt9LCBieVByb3h5R3JvdXBJZCA9IHt9LCBieUJhdGNoSWQgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0RGF0YUJ5SWRzKGlkT3JJZHMpIHtcbiAgICAgICAgICAgIGlmIChxcS5pc0FycmF5KGlkT3JJZHMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKGlkT3JJZHMsIGZ1bmN0aW9uKGlkeCwgaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKGRhdGFbaWRdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhW2lkT3JJZHNdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldERhdGFCeVV1aWRzKHV1aWRzKSB7XG4gICAgICAgICAgICBpZiAocXEuaXNBcnJheSh1dWlkcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICAgICAgICAgIHFxLmVhY2godXVpZHMsIGZ1bmN0aW9uKGlkeCwgdXVpZCkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goZGF0YVtieVV1aWRbdXVpZF1dKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhW2J5VXVpZFt1dWlkc11dO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldERhdGFCeVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgIHZhciBzdGF0dXNSZXN1bHRzID0gW10sIHN0YXR1c2VzID0gW10uY29uY2F0KHN0YXR1cyk7XG4gICAgICAgICAgICBxcS5lYWNoKHN0YXR1c2VzLCBmdW5jdGlvbihpbmRleCwgc3RhdHVzRW51bSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNSZXN1bHRJbmRleGVzID0gYnlTdGF0dXNbc3RhdHVzRW51bV07XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c1Jlc3VsdEluZGV4ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBxcS5lYWNoKHN0YXR1c1Jlc3VsdEluZGV4ZXMsIGZ1bmN0aW9uKGksIGRhdGFJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzUmVzdWx0cy5wdXNoKGRhdGFbZGF0YUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXR1c1Jlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIGFkZEZpbGU6IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gc3BlYy5zdGF0dXMgfHwgcXEuc3RhdHVzLlNVQk1JVFRJTkcsIGlkID0gZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc3BlYy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbE5hbWU6IHNwZWMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdXVpZDogc3BlYy51dWlkLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzcGVjLnNpemUgPT0gbnVsbCA/IC0xIDogc3BlYy5zaXplLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogc3BlYy5maWxlXG4gICAgICAgICAgICAgICAgfSkgLSAxO1xuICAgICAgICAgICAgICAgIGlmIChzcGVjLmJhdGNoSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpZF0uYmF0Y2hJZCA9IHNwZWMuYmF0Y2hJZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5QmF0Y2hJZFtzcGVjLmJhdGNoSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5QmF0Y2hJZFtzcGVjLmJhdGNoSWRdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnlCYXRjaElkW3NwZWMuYmF0Y2hJZF0ucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzcGVjLnByb3h5R3JvdXBJZCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2lkXS5wcm94eUdyb3VwSWQgPSBzcGVjLnByb3h5R3JvdXBJZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5UHJveHlHcm91cElkW3NwZWMucHJveHlHcm91cElkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBieVByb3h5R3JvdXBJZFtzcGVjLnByb3h5R3JvdXBJZF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBieVByb3h5R3JvdXBJZFtzcGVjLnByb3h5R3JvdXBJZF0ucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFbaWRdLmlkID0gaWQ7XG4gICAgICAgICAgICAgICAgYnlVdWlkW3NwZWMudXVpZF0gPSBpZDtcbiAgICAgICAgICAgICAgICBpZiAoYnlTdGF0dXNbc3RhdHVzXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5U3RhdHVzW3N0YXR1c10gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnlTdGF0dXNbc3RhdHVzXS5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICBzcGVjLm9uQmVmb3JlU3RhdHVzQ2hhbmdlICYmIHNwZWMub25CZWZvcmVTdGF0dXNDaGFuZ2UoaWQpO1xuICAgICAgICAgICAgICAgIHVwbG9hZGVyUHJveHkub25TdGF0dXNDaGFuZ2UoaWQsIG51bGwsIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHJpZXZlOiBmdW5jdGlvbihvcHRpb25hbEZpbHRlcikge1xuICAgICAgICAgICAgICAgIGlmIChxcS5pc09iamVjdChvcHRpb25hbEZpbHRlcikgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsRmlsdGVyLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXREYXRhQnlJZHMob3B0aW9uYWxGaWx0ZXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbmFsRmlsdGVyLnV1aWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldERhdGFCeVV1aWRzKG9wdGlvbmFsRmlsdGVyLnV1aWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbmFsRmlsdGVyLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldERhdGFCeVN0YXR1cyhvcHRpb25hbEZpbHRlci5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHFxLmV4dGVuZChbXSwgZGF0YSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZUZpbGVSZWY6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IGdldERhdGFCeUlkcyhpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVjb3JkLmZpbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgICAgICAgICAgYnlVdWlkID0ge307XG4gICAgICAgICAgICAgICAgYnlTdGF0dXMgPSB7fTtcbiAgICAgICAgICAgICAgICBieUJhdGNoSWQgPSB7fTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRTdGF0dXM6IGZ1bmN0aW9uKGlkLCBuZXdTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkU3RhdHVzID0gZGF0YVtpZF0uc3RhdHVzLCBieVN0YXR1c09sZFN0YXR1c0luZGV4ID0gcXEuaW5kZXhPZihieVN0YXR1c1tvbGRTdGF0dXNdLCBpZCk7XG4gICAgICAgICAgICAgICAgYnlTdGF0dXNbb2xkU3RhdHVzXS5zcGxpY2UoYnlTdGF0dXNPbGRTdGF0dXNJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgZGF0YVtpZF0uc3RhdHVzID0gbmV3U3RhdHVzO1xuICAgICAgICAgICAgICAgIGlmIChieVN0YXR1c1tuZXdTdGF0dXNdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnlTdGF0dXNbbmV3U3RhdHVzXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieVN0YXR1c1tuZXdTdGF0dXNdLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgIHVwbG9hZGVyUHJveHkub25TdGF0dXNDaGFuZ2UoaWQsIG9sZFN0YXR1cywgbmV3U3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1dWlkQ2hhbmdlZDogZnVuY3Rpb24oaWQsIG5ld1V1aWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVXVpZCA9IGRhdGFbaWRdLnV1aWQ7XG4gICAgICAgICAgICAgICAgZGF0YVtpZF0udXVpZCA9IG5ld1V1aWQ7XG4gICAgICAgICAgICAgICAgYnlVdWlkW25ld1V1aWRdID0gaWQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGJ5VXVpZFtvbGRVdWlkXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVOYW1lOiBmdW5jdGlvbihpZCwgbmV3TmFtZSkge1xuICAgICAgICAgICAgICAgIGRhdGFbaWRdLm5hbWUgPSBuZXdOYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVNpemU6IGZ1bmN0aW9uKGlkLCBuZXdTaXplKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtpZF0uc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0UGFyZW50SWQ6IGZ1bmN0aW9uKHRhcmdldElkLCBwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIGRhdGFbdGFyZ2V0SWRdLnBhcmVudElkID0gcGFyZW50SWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SWRzSW5Qcm94eUdyb3VwOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm94eUdyb3VwSWQgPSBkYXRhW2lkXS5wcm94eUdyb3VwSWQ7XG4gICAgICAgICAgICAgICAgaWYgKHByb3h5R3JvdXBJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnlQcm94eUdyb3VwSWRbcHJveHlHcm91cElkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldElkc0luQmF0Y2g6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoSWQgPSBkYXRhW2lkXS5iYXRjaElkO1xuICAgICAgICAgICAgICAgIHJldHVybiBieUJhdGNoSWRbYmF0Y2hJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuc3RhdHVzID0ge1xuICAgICAgICBTVUJNSVRUSU5HOiBcInN1Ym1pdHRpbmdcIixcbiAgICAgICAgU1VCTUlUVEVEOiBcInN1Ym1pdHRlZFwiLFxuICAgICAgICBSRUpFQ1RFRDogXCJyZWplY3RlZFwiLFxuICAgICAgICBRVUVVRUQ6IFwicXVldWVkXCIsXG4gICAgICAgIENBTkNFTEVEOiBcImNhbmNlbGVkXCIsXG4gICAgICAgIFBBVVNFRDogXCJwYXVzZWRcIixcbiAgICAgICAgVVBMT0FESU5HOiBcInVwbG9hZGluZ1wiLFxuICAgICAgICBVUExPQURfRklOQUxJWklORzogXCJ1cGxvYWQgZmluYWxpemluZ1wiLFxuICAgICAgICBVUExPQURfUkVUUllJTkc6IFwicmV0cnlpbmcgdXBsb2FkXCIsXG4gICAgICAgIFVQTE9BRF9TVUNDRVNTRlVMOiBcInVwbG9hZCBzdWNjZXNzZnVsXCIsXG4gICAgICAgIFVQTE9BRF9GQUlMRUQ6IFwidXBsb2FkIGZhaWxlZFwiLFxuICAgICAgICBERUxFVEVfRkFJTEVEOiBcImRlbGV0ZSBmYWlsZWRcIixcbiAgICAgICAgREVMRVRJTkc6IFwiZGVsZXRpbmdcIixcbiAgICAgICAgREVMRVRFRDogXCJkZWxldGVkXCJcbiAgICB9O1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHFxLmJhc2VQdWJsaWNBcGkgPSB7XG4gICAgICAgICAgICBhZGRCbG9iczogZnVuY3Rpb24oYmxvYkRhdGFPckFycmF5LCBwYXJhbXMsIGVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGaWxlcyhibG9iRGF0YU9yQXJyYXksIHBhcmFtcywgZW5kcG9pbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEluaXRpYWxGaWxlczogZnVuY3Rpb24oY2FubmVkRmlsZUxpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChjYW5uZWRGaWxlTGlzdCwgZnVuY3Rpb24oaW5kZXgsIGNhbm5lZEZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkQ2FubmVkRmlsZShjYW5uZWRGaWxlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRGaWxlczogZnVuY3Rpb24oZGF0YSwgcGFyYW1zLCBlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21heWJlSGFuZGxlSW9zOFNhZmFyaVdvcmthcm91bmQoKTtcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2hJZCA9IHRoaXMuX3N0b3JlZElkcy5sZW5ndGggPT09IDAgPyBxcS5nZXRVbmlxdWVJZCgpIDogdGhpcy5fY3VycmVudEJhdGNoSWQsIHByb2Nlc3NCbG9iID0gcXEuYmluZChmdW5jdGlvbihibG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZU5ld0ZpbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvYjogYmxvYixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX29wdGlvbnMuYmxvYnMuZGVmYXVsdE5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSwgYmF0Y2hJZCwgdmVyaWZpZWRGaWxlcyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyksIHByb2Nlc3NCbG9iRGF0YSA9IHFxLmJpbmQoZnVuY3Rpb24oYmxvYkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlTmV3RmlsZShibG9iRGF0YSwgYmF0Y2hJZCwgdmVyaWZpZWRGaWxlcyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyksIHByb2Nlc3NDYW52YXMgPSBxcS5iaW5kKGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IHFxLmNhbnZhc1RvQmxvYihjYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVOZXdGaWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2I6IGJsb2IsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9vcHRpb25zLmJsb2JzLmRlZmF1bHROYW1lICsgXCIucG5nXCJcbiAgICAgICAgICAgICAgICAgICAgfSwgYmF0Y2hJZCwgdmVyaWZpZWRGaWxlcyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyksIHByb2Nlc3NDYW52YXNEYXRhID0gcXEuYmluZChmdW5jdGlvbihjYW52YXNEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkUXVhbGl0eSA9IGNhbnZhc0RhdGEucXVhbGl0eSAmJiBjYW52YXNEYXRhLnF1YWxpdHkgLyAxMDAsIGJsb2IgPSBxcS5jYW52YXNUb0Jsb2IoY2FudmFzRGF0YS5jYW52YXMsIGNhbnZhc0RhdGEudHlwZSwgbm9ybWFsaXplZFF1YWxpdHkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVOZXdGaWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2I6IGJsb2IsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBjYW52YXNEYXRhLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSwgYmF0Y2hJZCwgdmVyaWZpZWRGaWxlcyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyksIHByb2Nlc3NGaWxlT3JJbnB1dCA9IHFxLmJpbmQoZnVuY3Rpb24oZmlsZU9ySW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFxLmlzSW5wdXQoZmlsZU9ySW5wdXQpICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLmFqYXhVcGxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZpbGVPcklucHV0LmZpbGVzKSwgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBxcS5lYWNoKGZpbGVzLCBmdW5jdGlvbihpZHgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9oYW5kbGVOZXdGaWxlKGZpbGUsIGJhdGNoSWQsIHZlcmlmaWVkRmlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVOZXdGaWxlKGZpbGVPcklucHV0LCBiYXRjaElkLCB2ZXJpZmllZEZpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpLCBub3JtYWxpemVEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxcS5pc0ZpbGVMaXN0KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtdLmNvbmNhdChkYXRhKTtcbiAgICAgICAgICAgICAgICB9LCBzZWxmID0gdGhpcywgdmVyaWZpZWRGaWxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRCYXRjaElkID0gYmF0Y2hJZDtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIHFxLmVhY2goZGF0YSwgZnVuY3Rpb24oaWR4LCBmaWxlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNGaWxlT3JJbnB1dChmaWxlQ29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NGaWxlT3JJbnB1dChmaWxlQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocXEuaXNCbG9iKGZpbGVDb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Jsb2IoZmlsZUNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHFxLmlzT2JqZWN0KGZpbGVDb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVDb250YWluZXIuYmxvYiAmJiBmaWxlQ29udGFpbmVyLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Jsb2JEYXRhKGZpbGVDb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZUNvbnRhaW5lci5jYW52YXMgJiYgZmlsZUNvbnRhaW5lci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDYW52YXNEYXRhKGZpbGVDb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZUNvbnRhaW5lci50YWdOYW1lICYmIGZpbGVDb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NhbnZhcyhmaWxlQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2coZmlsZUNvbnRhaW5lciArIFwiIGlzIG5vdCBhIHZhbGlkIGZpbGUgY29udGFpbmVyISAgSWdub3JpbmchXCIsIFwid2FyblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiUmVjZWl2ZWQgXCIgKyB2ZXJpZmllZEZpbGVzLmxlbmd0aCArIFwiIGZpbGVzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGFyZUl0ZW1zRm9yVXBsb2FkKHZlcmlmaWVkRmlsZXMsIHBhcmFtcywgZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwbG9hZERhdGEgPSB0aGlzLl91cGxvYWREYXRhLnJldHJpZXZlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHVwbG9hZERhdGEgJiYgdXBsb2FkRGF0YS5zdGF0dXMgPT09IHFxLnN0YXR1cy5VUExPQURfRklOQUxJWklORykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhxcS5mb3JtYXQoXCJJZ25vcmluZyBjYW5jZWwgZm9yIGZpbGUgSUQge30gKHt9KS4gIEZpbmFsaXppbmcgdXBsb2FkLlwiLCBpZCwgdGhpcy5nZXROYW1lKGlkKSksIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlci5jYW5jZWwoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWxBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZWRJZHNDb3B5ID0gW10sIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHFxLmV4dGVuZChzdG9yZWRJZHNDb3B5LCB0aGlzLl9zdG9yZWRJZHMpO1xuICAgICAgICAgICAgICAgIHFxLmVhY2goc3RvcmVkSWRzQ29weSwgZnVuY3Rpb24oaWR4LCBzdG9yZWRGaWxlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYW5jZWwoc3RvcmVkRmlsZUlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLmNhbmNlbEFsbCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFyU3RvcmVkRmlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3JlZElkcyA9IFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRpbnVlVXBsb2FkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciB1cGxvYWREYXRhID0gdGhpcy5fdXBsb2FkRGF0YS5yZXRyaWV2ZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghcXEuc3VwcG9ydGVkRmVhdHVyZXMucGF1c2UgfHwgIXRoaXMuX29wdGlvbnMuY2h1bmtpbmcuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1cGxvYWREYXRhLnN0YXR1cyA9PT0gcXEuc3RhdHVzLlBBVVNFRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhxcS5mb3JtYXQoXCJQYXVzZWQgZmlsZSBJRCB7fSAoe30pIHdpbGwgYmUgY29udGludWVkLiAgTm90IHBhdXNlZC5cIiwgaWQsIHRoaXMuZ2V0TmFtZShpZCkpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRmlsZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKHFxLmZvcm1hdChcIklnbm9yaW5nIGNvbnRpbnVlIGZvciBmaWxlIElEIHt9ICh7fSkuICBOb3QgcGF1c2VkLlwiLCBpZCwgdGhpcy5nZXROYW1lKGlkKSksIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVGaWxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vblN1Ym1pdERlbGV0ZShpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9lc0V4aXN0OiBmdW5jdGlvbihmaWxlT3JCbG9iSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlci5pc1ZhbGlkKGZpbGVPckJsb2JJZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHJhd1RodW1ibmFpbDogZnVuY3Rpb24oZmlsZUlkLCBpbWdPckNhbnZhcywgbWF4U2l6ZSwgZnJvbVNlcnZlciwgY3VzdG9tUmVzaXplRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZVRvUmV0dXJuID0gbmV3IHFxLlByb21pc2UoKSwgZmlsZU9yVXJsLCBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbWFnZUdlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBmaWxlT3JVcmwgPSB0aGlzLl90aHVtYm5haWxVcmxzW2ZpbGVJZF07XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21SZXNpemVGdW5jdGlvbjogY3VzdG9tUmVzaXplRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhTaXplOiBtYXhTaXplID4gMCA/IG1heFNpemUgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGU6IG1heFNpemUgPiAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICghZnJvbVNlcnZlciAmJiBxcS5zdXBwb3J0ZWRGZWF0dXJlcy5pbWFnZVByZXZpZXdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlT3JVcmwgPSB0aGlzLmdldEZpbGUoZmlsZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU9yVXJsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VUb1JldHVybi5mYWlsdXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGltZ09yQ2FudmFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBcIkZpbGUgb3IgVVJMIG5vdCBmb3VuZC5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZUdlbmVyYXRvci5nZW5lcmF0ZShmaWxlT3JVcmwsIGltZ09yQ2FudmFzLCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIHN1Y2Nlc3MobW9kaWZpZWRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlVG9SZXR1cm4uc3VjY2Vzcyhtb2RpZmllZENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiBmYWlsdXJlKGNvbnRhaW5lciwgcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVRvUmV0dXJuLmZhaWx1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHJlYXNvbiB8fCBcIlByb2JsZW0gZ2VuZXJhdGluZyB0aHVtYm5haWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlVG9SZXR1cm4uZmFpbHVyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGltZ09yQ2FudmFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFwiTWlzc2luZyBpbWFnZSBnZW5lcmF0b3IgbW9kdWxlXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlVG9SZXR1cm47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnV0dG9uOiBmdW5jdGlvbihmaWxlSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnV0dG9uKHRoaXMuX2J1dHRvbklkc0ZvckZpbGVJZHNbZmlsZUlkXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RW5kcG9pbnQ6IGZ1bmN0aW9uKGZpbGVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmRwb2ludFN0b3JlLmdldChmaWxlSWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEZpbGU6IGZ1bmN0aW9uKGZpbGVPckJsb2JJZCkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlID0gdGhpcy5faGFuZGxlci5nZXRGaWxlKGZpbGVPckJsb2JJZCk7XG4gICAgICAgICAgICAgICAgdmFyIHVwbG9hZERhdGFSZWNvcmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZERhdGFSZWNvcmQgPSB0aGlzLl91cGxvYWREYXRhLnJldHJpZXZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBmaWxlT3JCbG9iSWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGxvYWREYXRhUmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlID0gdXBsb2FkRGF0YVJlY29yZC5maWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlIHx8IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0SW5Qcm9ncmVzczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwbG9hZERhdGEucmV0cmlldmUoe1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFsgcXEuc3RhdHVzLlVQTE9BRElORywgcXEuc3RhdHVzLlVQTE9BRF9SRVRSWUlORywgcXEuc3RhdHVzLlFVRVVFRCBdXG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE5hbWU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwbG9hZERhdGEucmV0cmlldmUoe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICB9KS5uYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBhcmVudElkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciB1cGxvYWREYXRhRW50cnkgPSB0aGlzLmdldFVwbG9hZHMoe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICB9KSwgcGFyZW50SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh1cGxvYWREYXRhRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwbG9hZERhdGFFbnRyeS5wYXJlbnRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZCA9IHVwbG9hZERhdGFFbnRyeS5wYXJlbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50SWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UmVzdW1hYmxlRmlsZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlci5nZXRSZXN1bWFibGVGaWxlc0RhdGEoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRTaXplOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGxvYWREYXRhLnJldHJpZXZlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgfSkuc2l6ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXROZXRVcGxvYWRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0VXBsb2FkZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UmVtYWluaW5nQWxsb3dlZEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxsb3dlZEl0ZW1zID0gdGhpcy5fY3VycmVudEl0ZW1MaW1pdDtcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dlZEl0ZW1zID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3dlZEl0ZW1zIC0gdGhpcy5fbmV0VXBsb2FkZWRPclF1ZXVlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0VXBsb2FkczogZnVuY3Rpb24ob3B0aW9uYWxGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBsb2FkRGF0YS5yZXRyaWV2ZShvcHRpb25hbEZpbHRlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0VXVpZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBsb2FkRGF0YS5yZXRyaWV2ZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pLnV1aWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNSZXN1bWFibGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZXIuaGFzUmVzdW1lUmVjb3JkKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKHN0ciwgbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5kZWJ1ZyAmJiAoIWxldmVsIHx8IGxldmVsID09PSBcImluZm9cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEubG9nKFwiW0ZpbmUgVXBsb2FkZXIgXCIgKyBxcS52ZXJzaW9uICsgXCJdIFwiICsgc3RyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxldmVsICYmIGxldmVsICE9PSBcImluZm9cIikge1xuICAgICAgICAgICAgICAgICAgICBxcS5sb2coXCJbRmluZSBVcGxvYWRlciBcIiArIHFxLnZlcnNpb24gKyBcIl0gXCIgKyBzdHIsIGxldmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF1c2VVcGxvYWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwbG9hZERhdGEgPSB0aGlzLl91cGxvYWREYXRhLnJldHJpZXZlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFxcS5zdXBwb3J0ZWRGZWF0dXJlcy5wYXVzZSB8fCAhdGhpcy5fb3B0aW9ucy5jaHVua2luZy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHFxLmluZGV4T2YoWyBxcS5zdGF0dXMuVVBMT0FESU5HLCBxcS5zdGF0dXMuVVBMT0FEX1JFVFJZSU5HIF0sIHVwbG9hZERhdGEuc3RhdHVzKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyLnBhdXNlKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YS5zZXRTdGF0dXMoaWQsIHFxLnN0YXR1cy5QQVVTRUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhxcS5mb3JtYXQoXCJVbmFibGUgdG8gcGF1c2UgZmlsZSBJRCB7fSAoe30pLlwiLCBpZCwgdGhpcy5nZXROYW1lKGlkKSksIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhxcS5mb3JtYXQoXCJJZ25vcmluZyBwYXVzZSBmb3IgZmlsZSBJRCB7fSAoe30pLiAgTm90IGluIHByb2dyZXNzLlwiLCBpZCwgdGhpcy5nZXROYW1lKGlkKSksIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVGaWxlUmVmOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuZXhwdW5nZShpZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YS5yZW1vdmVGaWxlUmVmKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coXCJSZXNldHRpbmcgdXBsb2FkZXIuLi5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlci5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3JlZElkcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dG9SZXRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fcmV0cnlUaW1lb3V0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZlbnRSZXRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fdGh1bWJuYWlsVXJscyA9IFtdO1xuICAgICAgICAgICAgICAgIHFxLmVhY2godGhpcy5fYnV0dG9ucywgZnVuY3Rpb24oaWR4LCBidXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zU3RvcmUucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRwb2ludFN0b3JlLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV0VXBsb2FkZWRPclF1ZXVlZCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV0VXBsb2FkZWQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9idXR0b25JZHNGb3JGaWxlSWRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFzdGVIYW5kbGVyICYmIHRoaXMuX3Bhc3RlSGFuZGxlci5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuc2Vzc2lvbi5yZWZyZXNoT25SZXNldCAmJiB0aGlzLl9yZWZyZXNoU2Vzc2lvbkRhdGEoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWNjZWVkZWRTaW5jZUxhc3RBbGxDb21wbGV0ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZhaWxlZFNpbmNlTGFzdEFsbENvbXBsZXRlID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxQcm9ncmVzcyAmJiB0aGlzLl90b3RhbFByb2dyZXNzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VzdG9tUmVzdW1lRGF0YVN0b3JlLnJlc2V0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0cnk6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hbnVhbFJldHJ5KGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2FsZUltYWdlOiBmdW5jdGlvbihpZCwgc3BlY3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxLlNjYWxlci5wcm90b3R5cGUuc2NhbGVJbWFnZShpZCwgc3BlY3MsIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nOiBxcS5iaW5kKHNlbGYubG9nLCBzZWxmKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0RmlsZTogcXEuYmluZChzZWxmLmdldEZpbGUsIHNlbGYpLFxuICAgICAgICAgICAgICAgICAgICB1cGxvYWREYXRhOiBzZWxmLl91cGxvYWREYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0Q3VzdG9tSGVhZGVyczogZnVuY3Rpb24oaGVhZGVycywgaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXN0b21IZWFkZXJzU3RvcmUuc2V0KGhlYWRlcnMsIGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRDdXN0b21SZXN1bWVEYXRhOiBmdW5jdGlvbihpZCwgZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1c3RvbVJlc3VtZURhdGFTdG9yZS5zZXQoZGF0YSwgaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldERlbGV0ZUZpbGVDdXN0b21IZWFkZXJzOiBmdW5jdGlvbihoZWFkZXJzLCBpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlbGV0ZUZpbGVDdXN0b21IZWFkZXJzU3RvcmUuc2V0KGhlYWRlcnMsIGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXREZWxldGVGaWxlRW5kcG9pbnQ6IGZ1bmN0aW9uKGVuZHBvaW50LCBpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlbGV0ZUZpbGVFbmRwb2ludFN0b3JlLnNldChlbmRwb2ludCwgaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldERlbGV0ZUZpbGVQYXJhbXM6IGZ1bmN0aW9uKHBhcmFtcywgaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWxldGVGaWxlUGFyYW1zU3RvcmUuc2V0KHBhcmFtcywgaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldEVuZHBvaW50OiBmdW5jdGlvbihlbmRwb2ludCwgaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRwb2ludFN0b3JlLnNldChlbmRwb2ludCwgaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldEZvcm06IGZ1bmN0aW9uKGVsZW1lbnRPcklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9ybVN1cHBvcnRBbmRQYXJhbXMoZWxlbWVudE9ySWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldEl0ZW1MaW1pdDogZnVuY3Rpb24obmV3SXRlbUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEl0ZW1MaW1pdCA9IG5ld0l0ZW1MaW1pdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXROYW1lOiBmdW5jdGlvbihpZCwgbmV3TmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEudXBkYXRlTmFtZShpZCwgbmV3TmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0UGFyYW1zOiBmdW5jdGlvbihwYXJhbXMsIGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zU3RvcmUuc2V0KHBhcmFtcywgaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFV1aWQ6IGZ1bmN0aW9uKGlkLCBuZXdVdWlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwbG9hZERhdGEudXVpZENoYW5nZWQoaWQsIG5ld1V1aWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFN0YXR1czogZnVuY3Rpb24oaWQsIG5ld1N0YXR1cykge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlUmVjb3JkID0gdGhpcy5nZXRVcGxvYWRzKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlUmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBxcS5FcnJvcihpZCArIFwiIGlzIG5vdCBhIHZhbGlkIGZpbGUgSUQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5ld1N0YXR1cykge1xuICAgICAgICAgICAgICAgICAgY2FzZSBxcS5zdGF0dXMuREVMRVRFRDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25EZWxldGVDb21wbGV0ZShpZCwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSBxcS5zdGF0dXMuREVMRVRFX0ZBSUxFRDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25EZWxldGVDb21wbGV0ZShpZCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gXCJNZXRob2Qgc2V0U3RhdHVzIGNhbGxlZCBvbiAnXCIgKyBuYW1lICsgXCInIG5vdCBpbXBsZW1lbnRlZCB5ZXQgZm9yIFwiICsgbmV3U3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcXEuRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBsb2FkU3RvcmVkRmlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdG9yZWRJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1FcnJvcihcIm5vRmlsZXNFcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWRTdG9yZWRGaWxlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEuYmFzZVByaXZhdGVBcGkgPSB7XG4gICAgICAgICAgICBfYWRkQ2FubmVkRmlsZTogZnVuY3Rpb24oc2Vzc2lvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VwbG9hZERhdGEuYWRkRmlsZSh7XG4gICAgICAgICAgICAgICAgICAgIHV1aWQ6IHNlc3Npb25EYXRhLnV1aWQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHNlc3Npb25EYXRhLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHNlc3Npb25EYXRhLnNpemUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogcXEuc3RhdHVzLlVQTE9BRF9TVUNDRVNTRlVMLFxuICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZVN0YXR1c0NoYW5nZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25EYXRhLmRlbGV0ZUZpbGVFbmRwb2ludCAmJiBzZWxmLnNldERlbGV0ZUZpbGVFbmRwb2ludChzZXNzaW9uRGF0YS5kZWxldGVGaWxlRW5kcG9pbnQsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25EYXRhLmRlbGV0ZUZpbGVQYXJhbXMgJiYgc2VsZi5zZXREZWxldGVGaWxlUGFyYW1zKHNlc3Npb25EYXRhLmRlbGV0ZUZpbGVQYXJhbXMsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRGF0YS50aHVtYm5haWxVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90aHVtYm5haWxVcmxzW2lkXSA9IHNlc3Npb25EYXRhLnRodW1ibmFpbFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX25ldFVwbG9hZGVkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9uZXRVcGxvYWRlZE9yUXVldWVkKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYW5ub3RhdGVXaXRoQnV0dG9uSWQ6IGZ1bmN0aW9uKGZpbGUsIGFzc29jaWF0ZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChxcS5pc0ZpbGUoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5xcUJ1dHRvbklkID0gdGhpcy5fZ2V0QnV0dG9uSWQoYXNzb2NpYXRlZElucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2JhdGNoRXJyb3I6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vbkVycm9yKG51bGwsIG51bGwsIG1lc3NhZ2UsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NyZWF0ZURlbGV0ZUhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHFxLkRlbGV0ZUZpbGVBamF4UmVxdWVzdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB0aGlzLl9vcHRpb25zLmRlbGV0ZUZpbGUubWV0aG9kLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIG1heENvbm5lY3Rpb25zOiB0aGlzLl9vcHRpb25zLm1heENvbm5lY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICB1dWlkUGFyYW1OYW1lOiB0aGlzLl9vcHRpb25zLnJlcXVlc3QudXVpZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IHRoaXMuX2RlbGV0ZUZpbGVDdXN0b21IZWFkZXJzU3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1N0b3JlOiB0aGlzLl9kZWxldGVGaWxlUGFyYW1zU3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50U3RvcmU6IHRoaXMuX2RlbGV0ZUZpbGVFbmRwb2ludFN0b3JlLFxuICAgICAgICAgICAgICAgICAgICBjb3JzOiB0aGlzLl9vcHRpb25zLmNvcnMsXG4gICAgICAgICAgICAgICAgICAgIGxvZzogcXEuYmluZChzZWxmLmxvZywgc2VsZiksXG4gICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25EZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb3B0aW9ucy5jYWxsYmFja3Mub25EZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZUNvbXBsZXRlOiBmdW5jdGlvbihpZCwgeGhyT3JYZHIsIGlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uRGVsZXRlQ29tcGxldGUoaWQsIHhock9yWGRyLCBpc0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzLm9uRGVsZXRlQ29tcGxldGUoaWQsIHhock9yWGRyLCBpc0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jcmVhdGVQYXN0ZUhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHFxLlBhc3RlU3VwcG9ydCh7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQ6IHRoaXMuX29wdGlvbnMucGFzdGUudGFyZ2V0RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2c6IHFxLmJpbmQoc2VsZi5sb2csIHNlbGYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzdGVSZWNlaXZlZDogZnVuY3Rpb24oYmxvYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2hhbmRsZUNoZWNrZWRDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwib25QYXN0ZVJlY2VpdmVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBxcS5iaW5kKHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzLm9uUGFzdGVSZWNlaXZlZCwgc2VsZiwgYmxvYiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzczogcXEuYmluZChzZWxmLl9oYW5kbGVQYXN0ZVN1Y2Nlc3MsIHNlbGYsIGJsb2IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBcInBhc3RlZCBpbWFnZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY3JlYXRlU3RvcmU6IGZ1bmN0aW9uKGluaXRpYWxWYWx1ZSwgX3JlYWRPbmx5VmFsdWVzXykge1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHt9LCBjYXRjaGFsbCA9IGluaXRpYWxWYWx1ZSwgcGVySWRSZWFkT25seVZhbHVlcyA9IHt9LCByZWFkT25seVZhbHVlcyA9IF9yZWFkT25seVZhbHVlc18sIGNvcHkgPSBmdW5jdGlvbihvcmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxcS5pc09iamVjdChvcmlnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHFxLmV4dGVuZCh7fSwgb3JpZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWc7XG4gICAgICAgICAgICAgICAgfSwgZ2V0UmVhZE9ubHlWYWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFxLmlzRnVuY3Rpb24ocmVhZE9ubHlWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZE9ubHlWYWx1ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZE9ubHlWYWx1ZXM7XG4gICAgICAgICAgICAgICAgfSwgaW5jbHVkZVJlYWRPbmx5VmFsdWVzID0gZnVuY3Rpb24oaWQsIGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkT25seVZhbHVlcyAmJiBxcS5pc09iamVjdChleGlzdGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFxLmV4dGVuZChleGlzdGluZywgZ2V0UmVhZE9ubHlWYWx1ZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlcklkUmVhZE9ubHlWYWx1ZXNbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxcS5leHRlbmQoZXhpc3RpbmcsIHBlcklkUmVhZE9ubHlWYWx1ZXNbaWRdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwsIGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hhbGwgPSBjb3B5KHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlW2lkXSA9IGNvcHkodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZCAhPSBudWxsICYmIHN0b3JlW2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHN0b3JlW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gY29weShjYXRjaGFsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlUmVhZE9ubHlWYWx1ZXMoaWQsIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29weSh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhZGRSZWFkT25seTogZnVuY3Rpb24oaWQsIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHFxLmlzT2JqZWN0KHN0b3JlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNGdW5jdGlvbih2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkT25seVZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5VmFsdWVzID0gcmVhZE9ubHlWYWx1ZXMgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxcS5leHRlbmQocmVhZE9ubHlWYWx1ZXMsIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJJZFJlYWRPbmx5VmFsdWVzW2lkXSA9IHBlcklkUmVhZE9ubHlWYWx1ZXNbaWRdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxcS5leHRlbmQocGVySWRSZWFkT25seVZhbHVlc1tpZF0sIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGZpbGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBzdG9yZVtmaWxlSWRdO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVySWRSZWFkT25seVZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2hhbGwgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jcmVhdGVVcGxvYWREYXRhVHJhY2tlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcXEuVXBsb2FkRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGdldE5hbWU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXROYW1lKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VXVpZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFV1aWQoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRTaXplOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U2l6ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uU3RhdHVzQ2hhbmdlOiBmdW5jdGlvbihpZCwgb2xkU3RhdHVzLCBuZXdTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uVXBsb2FkU3RhdHVzQ2hhbmdlKGlkLCBvbGRTdGF0dXMsIG5ld1N0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vcHRpb25zLmNhbGxiYWNrcy5vblN0YXR1c0NoYW5nZShpZCwgb2xkU3RhdHVzLCBuZXdTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fbWF5YmVBbGxDb21wbGV0ZShpZCwgbmV3U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl90b3RhbFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fdG90YWxQcm9ncmVzcy5vblN0YXR1c0NoYW5nZShpZCwgb2xkU3RhdHVzLCBuZXdTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NyZWF0ZVVwbG9hZEJ1dHRvbjogZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgYWNjZXB0RmlsZXMgPSBzcGVjLmFjY2VwdCB8fCB0aGlzLl9vcHRpb25zLnZhbGlkYXRpb24uYWNjZXB0RmlsZXMsIGFsbG93ZWRFeHRlbnNpb25zID0gc3BlYy5hbGxvd2VkRXh0ZW5zaW9ucyB8fCB0aGlzLl9vcHRpb25zLnZhbGlkYXRpb24uYWxsb3dlZEV4dGVuc2lvbnMsIGJ1dHRvbjtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhbGxvd011bHRpcGxlKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEuc3VwcG9ydGVkRmVhdHVyZXMuYWpheFVwbG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX29wdGlvbnMud29ya2Fyb3VuZHMuaW9zRW1wdHlWaWRlb3MgJiYgcXEuaW9zKCkgJiYgIXFxLmlvczYoKSAmJiBzZWxmLl9pc0FsbG93ZWRFeHRlbnNpb24oYWxsb3dlZEV4dGVuc2lvbnMsIFwiLm1vdlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGVjLm11bHRpcGxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb3B0aW9ucy5tdWx0aXBsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGVjLm11bHRpcGxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnV0dG9uID0gbmV3IHFxLlVwbG9hZEJ1dHRvbih7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdEZpbGVzOiBhY2NlcHRGaWxlcyxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogc3BlYy5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBmb2N1c0NsYXNzOiB0aGlzLl9vcHRpb25zLmNsYXNzZXMuYnV0dG9uRm9jdXMsXG4gICAgICAgICAgICAgICAgICAgIGZvbGRlcnM6IHNwZWMuZm9sZGVycyxcbiAgICAgICAgICAgICAgICAgICAgaG92ZXJDbGFzczogdGhpcy5fb3B0aW9ucy5jbGFzc2VzLmJ1dHRvbkhvdmVyLFxuICAgICAgICAgICAgICAgICAgICBpb3M4QnJvd3NlckNyYXNoV29ya2Fyb3VuZDogdGhpcy5fb3B0aW9ucy53b3JrYXJvdW5kcy5pb3M4QnJvd3NlckNyYXNoLFxuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZTogYWxsb3dNdWx0aXBsZSgpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9vcHRpb25zLnJlcXVlc3QuaW5wdXROYW1lLFxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uSW5wdXRDaGFuZ2UoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogc3BlYy50aXRsZSA9PSBudWxsID8gdGhpcy5fb3B0aW9ucy50ZXh0LmZpbGVJbnB1dFRpdGxlIDogc3BlYy50aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VTdXBwb3J0LmFkZERpc3Bvc2VyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGYuX2J1dHRvbnMucHVzaChidXR0b24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBidXR0b247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NyZWF0ZVVwbG9hZEhhbmRsZXI6IGZ1bmN0aW9uKGFkZGl0aW9uYWxPcHRpb25zLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGxhc3RPblByb2dyZXNzID0ge30sIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnOiB0aGlzLl9vcHRpb25zLmRlYnVnLFxuICAgICAgICAgICAgICAgICAgICBtYXhDb25uZWN0aW9uczogdGhpcy5fb3B0aW9ucy5tYXhDb25uZWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgY29yczogdGhpcy5fb3B0aW9ucy5jb3JzLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNTdG9yZTogdGhpcy5fcGFyYW1zU3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50U3RvcmU6IHRoaXMuX2VuZHBvaW50U3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIGNodW5raW5nOiB0aGlzLl9vcHRpb25zLmNodW5raW5nLFxuICAgICAgICAgICAgICAgICAgICByZXN1bWU6IHRoaXMuX29wdGlvbnMucmVzdW1lLFxuICAgICAgICAgICAgICAgICAgICBibG9iczogdGhpcy5fb3B0aW9ucy5ibG9icyxcbiAgICAgICAgICAgICAgICAgICAgbG9nOiBxcS5iaW5kKHNlbGYubG9nLCBzZWxmKSxcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudFJldHJ5UGFyYW06IHRoaXMuX29wdGlvbnMucmV0cnkucHJldmVudFJldHJ5UmVzcG9uc2VQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24oaWQsIG5hbWUsIGxvYWRlZCwgdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2FkZWQgPCAwIHx8IHRvdGFsIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0T25Qcm9ncmVzc1tpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdE9uUHJvZ3Jlc3NbaWRdLmxvYWRlZCAhPT0gbG9hZGVkIHx8IGxhc3RPblByb2dyZXNzW2lkXS50b3RhbCAhPT0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25Qcm9ncmVzcyhpZCwgbmFtZSwgbG9hZGVkLCB0b3RhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzLm9uUHJvZ3Jlc3MoaWQsIG5hbWUsIGxvYWRlZCwgdG90YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25Qcm9ncmVzcyhpZCwgbmFtZSwgbG9hZGVkLCB0b3RhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb3B0aW9ucy5jYWxsYmFja3Mub25Qcm9ncmVzcyhpZCwgbmFtZSwgbG9hZGVkLCB0b3RhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0T25Qcm9ncmVzc1tpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiBsb2FkZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWw6IHRvdGFsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbihpZCwgbmFtZSwgcmVzdWx0LCB4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsYXN0T25Qcm9ncmVzc1tpZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gc2VsZi5nZXRVcGxvYWRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnN0YXR1cywgcmV0VmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gcXEuc3RhdHVzLlVQTE9BRF9TVUNDRVNTRlVMIHx8IHN0YXR1cyA9PT0gcXEuc3RhdHVzLlVQTE9BRF9GQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRWYWwgPSBzZWxmLl9vbkNvbXBsZXRlKGlkLCBuYW1lLCByZXN1bHQsIHhocik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0VmFsIGluc3RhbmNlb2YgcXEuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldFZhbC5kb25lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vcHRpb25zLmNhbGxiYWNrcy5vbkNvbXBsZXRlKGlkLCBuYW1lLCByZXN1bHQsIHhocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzLm9uQ29tcGxldGUoaWQsIG5hbWUsIHJlc3VsdCwgeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25DYW5jZWw6IGZ1bmN0aW9uKGlkLCBuYW1lLCBjYW5jZWxGaW5hbGl6YXRpb25FZmZvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2hhbmRsZUNoZWNrZWRDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJvbkNhbmNlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBxcS5iaW5kKHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzLm9uQ2FuY2VsLCBzZWxmLCBpZCwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25GYWlsdXJlOiBwcm9taXNlLmZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsRmluYWxpemF0aW9uRWZmb3J0LnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkNhbmNlbChpZCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblVwbG9hZFByZXA6IHFxLmJpbmQodGhpcy5fb25VcGxvYWRQcmVwLCB0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgb25VcGxvYWQ6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vblVwbG9hZChpZCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25VcGxvYWRSZXN1bHQgPSBzZWxmLl9vcHRpb25zLmNhbGxiYWNrcy5vblVwbG9hZChpZCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNHZW5lcmljUHJvbWlzZShvblVwbG9hZFJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhxcS5mb3JtYXQoXCJvblVwbG9hZCBmb3Ige30gcmV0dXJuZWQgYSBQcm9taXNlIC0gd2FpdGluZyBmb3IgcmVzb2x1dGlvbi5cIiwgaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb25VcGxvYWRSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHFxLlByb21pc2UoKS5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uVXBsb2FkQ2h1bms6IGZ1bmN0aW9uKGlkLCBuYW1lLCBjaHVua0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uVXBsb2FkQ2h1bmsoaWQsIGNodW5rRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25VcGxvYWRDaHVua1Jlc3VsdCA9IHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzLm9uVXBsb2FkQ2h1bmsoaWQsIG5hbWUsIGNodW5rRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNHZW5lcmljUHJvbWlzZShvblVwbG9hZENodW5rUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9nKHFxLmZvcm1hdChcIm9uVXBsb2FkQ2h1bmsgZm9yIHt9Lnt9IHJldHVybmVkIGEgUHJvbWlzZSAtIHdhaXRpbmcgZm9yIHJlc29sdXRpb24uXCIsIGlkLCBjaHVua0RhdGEucGFydEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uVXBsb2FkQ2h1bmtSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHFxLlByb21pc2UoKS5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uVXBsb2FkQ2h1bmtTdWNjZXNzOiBmdW5jdGlvbihpZCwgY2h1bmtEYXRhLCByZXN1bHQsIHhocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb25VcGxvYWRDaHVua1N1Y2Nlc3MoaWQsIGNodW5rRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vcHRpb25zLmNhbGxiYWNrcy5vblVwbG9hZENodW5rU3VjY2Vzcy5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblJlc3VtZTogZnVuY3Rpb24oaWQsIG5hbWUsIGNodW5rRGF0YSwgY3VzdG9tUmVzdW1lRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzLm9uUmVzdW1lKGlkLCBuYW1lLCBjaHVua0RhdGEsIGN1c3RvbVJlc3VtZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkF1dG9SZXRyeTogZnVuY3Rpb24oaWQsIG5hbWUsIHJlc3BvbnNlSlNPTiwgeGhyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb25BdXRvUmV0cnkuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25VdWlkQ2hhbmdlZDogZnVuY3Rpb24oaWQsIG5ld1V1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9nKFwiU2VydmVyIHJlcXVlc3RlZCBVVUlEIGNoYW5nZSBmcm9tICdcIiArIHNlbGYuZ2V0VXVpZChpZCkgKyBcIicgdG8gJ1wiICsgbmV3VXVpZCArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0VXVpZChpZCwgbmV3VXVpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldE5hbWU6IHFxLmJpbmQoc2VsZi5nZXROYW1lLCBzZWxmKSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VXVpZDogcXEuYmluZChzZWxmLmdldFV1aWQsIHNlbGYpLFxuICAgICAgICAgICAgICAgICAgICBnZXRTaXplOiBxcS5iaW5kKHNlbGYuZ2V0U2l6ZSwgc2VsZiksXG4gICAgICAgICAgICAgICAgICAgIHNldFNpemU6IHFxLmJpbmQoc2VsZi5fc2V0U2l6ZSwgc2VsZiksXG4gICAgICAgICAgICAgICAgICAgIGdldERhdGFCeVV1aWQ6IGZ1bmN0aW9uKHV1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFVwbG9hZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV1aWQ6IHV1aWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpc1F1ZXVlZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSBzZWxmLmdldFVwbG9hZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXR1cyA9PT0gcXEuc3RhdHVzLlFVRVVFRCB8fCBzdGF0dXMgPT09IHFxLnN0YXR1cy5TVUJNSVRURUQgfHwgc3RhdHVzID09PSBxcS5zdGF0dXMuVVBMT0FEX1JFVFJZSU5HIHx8IHN0YXR1cyA9PT0gcXEuc3RhdHVzLlBBVVNFRDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0SWRzSW5Qcm94eUdyb3VwOiBzZWxmLl91cGxvYWREYXRhLmdldElkc0luUHJveHlHcm91cCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0SWRzSW5CYXRjaDogc2VsZi5fdXBsb2FkRGF0YS5nZXRJZHNJbkJhdGNoLFxuICAgICAgICAgICAgICAgICAgICBpc0luUHJvZ3Jlc3M6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRVcGxvYWRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnN0YXR1cyA9PT0gcXEuc3RhdHVzLlVQTE9BRElORztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q3VzdG9tUmVzdW1lRGF0YTogcXEuYmluZChzZWxmLl9nZXRDdXN0b21SZXN1bWVEYXRhLCBzZWxmKSxcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzOiBmdW5jdGlvbihpZCwgc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl91cGxvYWREYXRhLnNldFN0YXR1cyhpZCwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcXEuZWFjaCh0aGlzLl9vcHRpb25zLnJlcXVlc3QsIGZ1bmN0aW9uKHByb3AsIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY3VzdG9tSGVhZGVycyA9IHRoaXMuX2N1c3RvbUhlYWRlcnNTdG9yZTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChhZGRpdGlvbmFsT3B0aW9ucywgZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcXEuVXBsb2FkSGFuZGxlckNvbnRyb2xsZXIob3B0aW9ucywgbmFtZXNwYWNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZmlsZU9yQmxvYlJlamVjdGVkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25ldFVwbG9hZGVkT3JRdWV1ZWQtLTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWREYXRhLnNldFN0YXR1cyhpZCwgcXEuc3RhdHVzLlJFSkVDVEVEKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZm9ybWF0U2l6ZTogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ5dGVzICsgdGhpcy5fb3B0aW9ucy50ZXh0LnNpemVTeW1ib2xzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlcyAvIDFlMztcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGJ5dGVzID4gOTk5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoYnl0ZXMsIC4xKS50b0ZpeGVkKDEpICsgdGhpcy5fb3B0aW9ucy50ZXh0LnNpemVTeW1ib2xzW2ldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZW5lcmF0ZUV4dHJhQnV0dG9uU3BlY3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLl9leHRyYUJ1dHRvblNwZWNzID0ge307XG4gICAgICAgICAgICAgICAgcXEuZWFjaCh0aGlzLl9vcHRpb25zLmV4dHJhQnV0dG9ucywgZnVuY3Rpb24oaWR4LCBleHRyYUJ1dHRvbk9wdGlvbkVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsZSA9IGV4dHJhQnV0dG9uT3B0aW9uRW50cnkubXVsdGlwbGUsIHZhbGlkYXRpb24gPSBxcS5leHRlbmQoe30sIHNlbGYuX29wdGlvbnMudmFsaWRhdGlvbiwgdHJ1ZSksIGV4dHJhQnV0dG9uU3BlYyA9IHFxLmV4dGVuZCh7fSwgZXh0cmFCdXR0b25PcHRpb25FbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZSA9IHNlbGYuX29wdGlvbnMubXVsdGlwbGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhQnV0dG9uU3BlYy52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxcS5leHRlbmQodmFsaWRhdGlvbiwgZXh0cmFCdXR0b25PcHRpb25FbnRyeS52YWxpZGF0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBxcS5leHRlbmQoZXh0cmFCdXR0b25TcGVjLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZTogbXVsdGlwbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbml0RXh0cmFCdXR0b24oZXh0cmFCdXR0b25TcGVjKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0QnV0dG9uOiBmdW5jdGlvbihidXR0b25JZCkge1xuICAgICAgICAgICAgICAgIHZhciBleHRyYUJ1dHRvbnNTcGVjID0gdGhpcy5fZXh0cmFCdXR0b25TcGVjc1tidXR0b25JZF07XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhQnV0dG9uc1NwZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhQnV0dG9uc1NwZWMuZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJ1dHRvbklkID09PSB0aGlzLl9kZWZhdWx0QnV0dG9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuYnV0dG9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0QnV0dG9uSWQ6IGZ1bmN0aW9uKGJ1dHRvbk9yRmlsZUlucHV0T3JGaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0cywgZmlsZUlucHV0LCBmaWxlQmxvYk9ySW5wdXQgPSBidXR0b25PckZpbGVJbnB1dE9yRmlsZTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUJsb2JPcklucHV0IGluc3RhbmNlb2YgcXEuQmxvYlByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVCbG9iT3JJbnB1dCA9IGZpbGVCbG9iT3JJbnB1dC5yZWZlcmVuY2VCbG9iO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsZUJsb2JPcklucHV0ICYmICFxcS5pc0Jsb2IoZmlsZUJsb2JPcklucHV0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNGaWxlKGZpbGVCbG9iT3JJbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlQmxvYk9ySW5wdXQucXFCdXR0b25JZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxlQmxvYk9ySW5wdXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiYgZmlsZUJsb2JPcklucHV0LnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlQmxvYk9ySW5wdXQuZ2V0QXR0cmlidXRlKHFxLlVwbG9hZEJ1dHRvbi5CVVRUT05fSURfQVRUUl9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnB1dHMgPSBmaWxlQmxvYk9ySW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChpbnB1dHMsIGZ1bmN0aW9uKGlkeCwgaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09PSBcImZpbGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVJbnB1dCA9IGlucHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlSW5wdXQuZ2V0QXR0cmlidXRlKHFxLlVwbG9hZEJ1dHRvbi5CVVRUT05fSURfQVRUUl9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0Q3VzdG9tUmVzdW1lRGF0YTogZnVuY3Rpb24oZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1c3RvbVJlc3VtZURhdGFTdG9yZS5nZXQoZmlsZUlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0Tm90RmluaXNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGxvYWREYXRhLnJldHJpZXZlKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBbIHFxLnN0YXR1cy5VUExPQURJTkcsIHFxLnN0YXR1cy5VUExPQURfUkVUUllJTkcsIHFxLnN0YXR1cy5RVUVVRUQsIHFxLnN0YXR1cy5TVUJNSVRUSU5HLCBxcS5zdGF0dXMuU1VCTUlUVEVELCBxcS5zdGF0dXMuUEFVU0VEIF1cbiAgICAgICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldFZhbGlkYXRpb25CYXNlOiBmdW5jdGlvbihidXR0b25JZCkge1xuICAgICAgICAgICAgICAgIHZhciBleHRyYUJ1dHRvblNwZWMgPSB0aGlzLl9leHRyYUJ1dHRvblNwZWNzW2J1dHRvbklkXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmFCdXR0b25TcGVjID8gZXh0cmFCdXR0b25TcGVjLnZhbGlkYXRpb24gOiB0aGlzLl9vcHRpb25zLnZhbGlkYXRpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldFZhbGlkYXRpb25EZXNjcmlwdG9yOiBmdW5jdGlvbihmaWxlV3JhcHBlcikge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlV3JhcHBlci5maWxlIGluc3RhbmNlb2YgcXEuQmxvYlByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBxcS5nZXRGaWxlbmFtZShmaWxlV3JhcHBlci5maWxlLnJlZmVyZW5jZUJsb2IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmlsZVdyYXBwZXIuZmlsZS5yZWZlcmVuY2VCbG9iLnNpemVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5nZXRVcGxvYWRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBmaWxlV3JhcHBlci5pZFxuICAgICAgICAgICAgICAgICAgICB9KS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiB0aGlzLmdldFVwbG9hZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGZpbGVXcmFwcGVyLmlkXG4gICAgICAgICAgICAgICAgICAgIH0pLnNpemVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRWYWxpZGF0aW9uRGVzY3JpcHRvcnM6IGZ1bmN0aW9uKGZpbGVXcmFwcGVycykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgZmlsZURlc2NyaXB0b3JzID0gW107XG4gICAgICAgICAgICAgICAgcXEuZWFjaChmaWxlV3JhcHBlcnMsIGZ1bmN0aW9uKGlkeCwgZmlsZVdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZURlc2NyaXB0b3JzLnB1c2goc2VsZi5fZ2V0VmFsaWRhdGlvbkRlc2NyaXB0b3IoZmlsZVdyYXBwZXIpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZURlc2NyaXB0b3JzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9oYW5kbGVDYW1lcmFBY2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmNhbWVyYS5pb3MgJiYgcXEuaW9zKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjY2VwdElvc0NhbWVyYSA9IFwiaW1hZ2UvKjtjYXB0dXJlPWNhbWVyYVwiLCBidXR0b24gPSB0aGlzLl9vcHRpb25zLmNhbWVyYS5idXR0b24sIGJ1dHRvbklkID0gYnV0dG9uID8gdGhpcy5fZ2V0QnV0dG9uSWQoYnV0dG9uKSA6IHRoaXMuX2RlZmF1bHRCdXR0b25JZCwgb3B0aW9uUm9vdCA9IHRoaXMuX29wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25JZCAmJiBidXR0b25JZCAhPT0gdGhpcy5fZGVmYXVsdEJ1dHRvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25Sb290ID0gdGhpcy5fZXh0cmFCdXR0b25TcGVjc1tidXR0b25JZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uUm9vdC5tdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uUm9vdC52YWxpZGF0aW9uLmFjY2VwdEZpbGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25Sb290LnZhbGlkYXRpb24uYWNjZXB0RmlsZXMgPSBhY2NlcHRJb3NDYW1lcmE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25Sb290LnZhbGlkYXRpb24uYWNjZXB0RmlsZXMgKz0gXCIsXCIgKyBhY2NlcHRJb3NDYW1lcmE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaCh0aGlzLl9idXR0b25zLCBmdW5jdGlvbihpZHgsIGJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbi5nZXRCdXR0b25JZCgpID09PSBidXR0b25JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRNdWx0aXBsZShvcHRpb25Sb290Lm11bHRpcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0QWNjZXB0RmlsZXMob3B0aW9uUm9vdC5hY2NlcHRGaWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2hhbmRsZUNoZWNrZWRDYWxsYmFjazogZnVuY3Rpb24oZGV0YWlscykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgY2FsbGJhY2tSZXRWYWwgPSBkZXRhaWxzLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgaWYgKHFxLmlzR2VuZXJpY1Byb21pc2UoY2FsbGJhY2tSZXRWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKGRldGFpbHMubmFtZSArIFwiIC0gd2FpdGluZyBmb3IgXCIgKyBkZXRhaWxzLm5hbWUgKyBcIiBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZCBmb3IgXCIgKyBkZXRhaWxzLmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tSZXRWYWwudGhlbihmdW5jdGlvbihzdWNjZXNzUGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9nKGRldGFpbHMubmFtZSArIFwiIHByb21pc2Ugc3VjY2VzcyBmb3IgXCIgKyBkZXRhaWxzLmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5vblN1Y2Nlc3Moc3VjY2Vzc1BhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV0YWlscy5vbkZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhkZXRhaWxzLm5hbWUgKyBcIiBwcm9taXNlIGZhaWx1cmUgZm9yIFwiICsgZGV0YWlscy5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLm9uRmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhkZXRhaWxzLm5hbWUgKyBcIiBwcm9taXNlIGZhaWx1cmUgZm9yIFwiICsgZGV0YWlscy5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja1JldFZhbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5vblN1Y2Nlc3MoY2FsbGJhY2tSZXRWYWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLm9uRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coZGV0YWlscy5uYW1lICsgXCIgLSByZXR1cm4gdmFsdWUgd2FzICdmYWxzZScgZm9yIFwiICsgZGV0YWlscy5pZGVudGlmaWVyICsgXCIuICBJbnZva2luZyBmYWlsdXJlIGNhbGxiYWNrLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMub25GYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhkZXRhaWxzLm5hbWUgKyBcIiAtIHJldHVybiB2YWx1ZSB3YXMgJ2ZhbHNlJyBmb3IgXCIgKyBkZXRhaWxzLmlkZW50aWZpZXIgKyBcIi4gIFdpbGwgbm90IHByb2NlZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFja1JldFZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaGFuZGxlTmV3RmlsZTogZnVuY3Rpb24oZmlsZSwgYmF0Y2hJZCwgbmV3RmlsZVdyYXBwZXJMaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCB1dWlkID0gcXEuZ2V0VW5pcXVlSWQoKSwgc2l6ZSA9IC0xLCBuYW1lID0gcXEuZ2V0RmlsZW5hbWUoZmlsZSksIGFjdHVhbEZpbGUgPSBmaWxlLmJsb2IgfHwgZmlsZSwgaGFuZGxlciA9IHRoaXMuX2N1c3RvbU5ld0ZpbGVIYW5kbGVyID8gdGhpcy5fY3VzdG9tTmV3RmlsZUhhbmRsZXIgOiBxcS5iaW5kKHNlbGYuX2hhbmRsZU5ld0ZpbGVHZW5lcmljLCBzZWxmKTtcbiAgICAgICAgICAgICAgICBpZiAoIXFxLmlzSW5wdXQoYWN0dWFsRmlsZSkgJiYgYWN0dWFsRmlsZS5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IGFjdHVhbEZpbGUuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFuZGxlcihhY3R1YWxGaWxlLCBuYW1lLCB1dWlkLCBzaXplLCBuZXdGaWxlV3JhcHBlckxpc3QsIGJhdGNoSWQsIHRoaXMuX29wdGlvbnMucmVxdWVzdC51dWlkTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWREYXRhOiBzZWxmLl91cGxvYWREYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNTdG9yZTogc2VsZi5fcGFyYW1zU3RvcmUsXG4gICAgICAgICAgICAgICAgICAgIGFkZEZpbGVUb0hhbmRsZXI6IGZ1bmN0aW9uKGlkLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9oYW5kbGVyLmFkZChpZCwgZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9uZXRVcGxvYWRlZE9yUXVldWVkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl90cmFja0J1dHRvbihpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaGFuZGxlTmV3RmlsZUdlbmVyaWM6IGZ1bmN0aW9uKGZpbGUsIG5hbWUsIHV1aWQsIHNpemUsIGZpbGVMaXN0LCBiYXRjaElkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5fdXBsb2FkRGF0YS5hZGRGaWxlKHtcbiAgICAgICAgICAgICAgICAgICAgdXVpZDogdXVpZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hJZDogYmF0Y2hJZCxcbiAgICAgICAgICAgICAgICAgICAgZmlsZTogZmlsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuYWRkKGlkLCBmaWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFja0J1dHRvbihpZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmV0VXBsb2FkZWRPclF1ZXVlZCsrO1xuICAgICAgICAgICAgICAgIGZpbGVMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IGZpbGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaGFuZGxlUGFzdGVTdWNjZXNzOiBmdW5jdGlvbihibG9iLCBleHRTdXBwbGllZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gYmxvYi50eXBlLnNwbGl0KFwiL1wiKVsxXSwgbmFtZSA9IGV4dFN1cHBsaWVkTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLl9vcHRpb25zLnBhc3RlLmRlZmF1bHROYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lICs9IFwiLlwiICsgZXh0ZW5zaW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlsZXMoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBibG9iOiBibG9iXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2hhbmRsZURlbGV0ZVN1Y2Nlc3M6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VXBsb2Fkcyh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pLnN0YXR1cyAhPT0gcXEuc3RhdHVzLkRFTEVURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmdldE5hbWUoaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXRVcGxvYWRlZE9yUXVldWVkLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25ldFVwbG9hZGVkLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuZXhwdW5nZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEuc2V0U3RhdHVzKGlkLCBxcS5zdGF0dXMuREVMRVRFRCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiRGVsZXRlIHJlcXVlc3QgZm9yICdcIiArIG5hbWUgKyBcIicgaGFzIHN1Y2NlZWRlZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9oYW5kbGVEZWxldGVGYWlsZWQ6IGZ1bmN0aW9uKGlkLCB4aHJPclhkcikge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5nZXROYW1lKGlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWREYXRhLnNldFN0YXR1cyhpZCwgcXEuc3RhdHVzLkRFTEVURV9GQUlMRUQpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiRGVsZXRlIHJlcXVlc3QgZm9yICdcIiArIG5hbWUgKyBcIicgaGFzIGZhaWxlZC5cIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIXhock9yWGRyIHx8IHhock9yWGRyLndpdGhDcmVkZW50aWFscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLm9uRXJyb3IoaWQsIG5hbWUsIFwiRGVsZXRlIHJlcXVlc3QgZmFpbGVkXCIsIHhock9yWGRyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vbkVycm9yKGlkLCBuYW1lLCBcIkRlbGV0ZSByZXF1ZXN0IGZhaWxlZCB3aXRoIHJlc3BvbnNlIGNvZGUgXCIgKyB4aHJPclhkci5zdGF0dXMsIHhock9yWGRyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2luaXRFeHRyYUJ1dHRvbjogZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgICAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVVcGxvYWRCdXR0b24oe1xuICAgICAgICAgICAgICAgICAgICBhY2NlcHQ6IHNwZWMudmFsaWRhdGlvbi5hY2NlcHRGaWxlcyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZEV4dGVuc2lvbnM6IHNwZWMudmFsaWRhdGlvbi5hbGxvd2VkRXh0ZW5zaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogc3BlYy5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBmb2xkZXJzOiBzcGVjLmZvbGRlcnMsXG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxlOiBzcGVjLm11bHRpcGxlLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogc3BlYy5maWxlSW5wdXRUaXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4dHJhQnV0dG9uU3BlY3NbYnV0dG9uLmdldEJ1dHRvbklkKCldID0gc3BlYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfaW5pdEZvcm1TdXBwb3J0QW5kUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3JtU3VwcG9ydCA9IHFxLkZvcm1TdXBwb3J0ICYmIG5ldyBxcS5Gb3JtU3VwcG9ydCh0aGlzLl9vcHRpb25zLmZvcm0sIHFxLmJpbmQodGhpcy51cGxvYWRTdG9yZWRGaWxlcywgdGhpcyksIHFxLmJpbmQodGhpcy5sb2csIHRoaXMpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZm9ybVN1cHBvcnQgJiYgdGhpcy5fZm9ybVN1cHBvcnQuYXR0YWNoZWRUb0Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zU3RvcmUgPSB0aGlzLl9jcmVhdGVTdG9yZSh0aGlzLl9vcHRpb25zLnJlcXVlc3QucGFyYW1zLCB0aGlzLl9mb3JtU3VwcG9ydC5nZXRGb3JtSW5wdXRzQXNPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmF1dG9VcGxvYWQgPSB0aGlzLl9mb3JtU3VwcG9ydC5uZXdBdXRvVXBsb2FkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZm9ybVN1cHBvcnQubmV3RW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMucmVxdWVzdC5lbmRwb2ludCA9IHRoaXMuX2Zvcm1TdXBwb3J0Lm5ld0VuZHBvaW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyYW1zU3RvcmUgPSB0aGlzLl9jcmVhdGVTdG9yZSh0aGlzLl9vcHRpb25zLnJlcXVlc3QucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzRGVsZXRlUG9zc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghcXEuRGVsZXRlRmlsZUFqYXhSZXF1ZXN0ZXIgfHwgIXRoaXMuX29wdGlvbnMuZGVsZXRlRmlsZS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuY29ycy5leHBlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEuc3VwcG9ydGVkRmVhdHVyZXMuZGVsZXRlRmlsZUNvcnNYaHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChxcS5zdXBwb3J0ZWRGZWF0dXJlcy5kZWxldGVGaWxlQ29yc1hkciAmJiB0aGlzLl9vcHRpb25zLmNvcnMuYWxsb3dYZHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzQWxsb3dlZEV4dGVuc2lvbjogZnVuY3Rpb24oYWxsb3dlZCwgZmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbG93ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxcS5lYWNoKGFsbG93ZWQsIGZ1bmN0aW9uKGlkeCwgYWxsb3dlZEV4dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNTdHJpbmcoYWxsb3dlZEV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHRSZWdleCA9IG5ldyBSZWdFeHAoXCJcXFxcLlwiICsgYWxsb3dlZEV4dCArIFwiJFwiLCBcImlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUubWF0Y2goZXh0UmVnZXgpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pdGVtRXJyb3I6IGZ1bmN0aW9uKGNvZGUsIG1heWJlTmFtZU9yTmFtZXMsIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX29wdGlvbnMubWVzc2FnZXNbY29kZV0sIGFsbG93ZWRFeHRlbnNpb25zID0gW10sIG5hbWVzID0gW10uY29uY2F0KG1heWJlTmFtZU9yTmFtZXMpLCBuYW1lID0gbmFtZXNbMF0sIGJ1dHRvbklkID0gdGhpcy5fZ2V0QnV0dG9uSWQoaXRlbSksIHZhbGlkYXRpb25CYXNlID0gdGhpcy5fZ2V0VmFsaWRhdGlvbkJhc2UoYnV0dG9uSWQpLCBleHRlbnNpb25zRm9yTWVzc2FnZSwgcGxhY2Vob2xkZXJNYXRjaDtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByKG5hbWUsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UobmFtZSwgcmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxcS5lYWNoKHZhbGlkYXRpb25CYXNlLmFsbG93ZWRFeHRlbnNpb25zLCBmdW5jdGlvbihpZHgsIGFsbG93ZWRFeHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFxLmlzU3RyaW5nKGFsbG93ZWRFeHRlbnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkRXh0ZW5zaW9ucy5wdXNoKGFsbG93ZWRFeHRlbnNpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uc0Zvck1lc3NhZ2UgPSBhbGxvd2VkRXh0ZW5zaW9ucy5qb2luKFwiLCBcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICByKFwie2ZpbGV9XCIsIHRoaXMuX29wdGlvbnMuZm9ybWF0RmlsZU5hbWUobmFtZSkpO1xuICAgICAgICAgICAgICAgIHIoXCJ7ZXh0ZW5zaW9uc31cIiwgZXh0ZW5zaW9uc0Zvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHIoXCJ7c2l6ZUxpbWl0fVwiLCB0aGlzLl9mb3JtYXRTaXplKHZhbGlkYXRpb25CYXNlLnNpemVMaW1pdCkpO1xuICAgICAgICAgICAgICAgIHIoXCJ7bWluU2l6ZUxpbWl0fVwiLCB0aGlzLl9mb3JtYXRTaXplKHZhbGlkYXRpb25CYXNlLm1pblNpemVMaW1pdCkpO1xuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyTWF0Y2ggPSBtZXNzYWdlLm1hdGNoKC8oXFx7XFx3K1xcfSkvZyk7XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyTWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChwbGFjZWhvbGRlck1hdGNoLCBmdW5jdGlvbihpZHgsIHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByKHBsYWNlaG9sZGVyLCBuYW1lc1tpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLm9uRXJyb3IobnVsbCwgbmFtZSwgbWVzc2FnZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWFudWFsUmV0cnk6IGZ1bmN0aW9uKGlkLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbkJlZm9yZU1hbnVhbFJldHJ5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXRVcGxvYWRlZE9yUXVldWVkKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEuc2V0U3RhdHVzKGlkLCBxcS5zdGF0dXMuVVBMT0FEX1JFVFJZSU5HKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhpZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLnJldHJ5KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21heWJlQWxsQ29tcGxldGU6IGZ1bmN0aW9uKGlkLCBzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIG5vdEZpbmlzaGVkID0gdGhpcy5fZ2V0Tm90RmluaXNoZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSBxcS5zdGF0dXMuVVBMT0FEX1NVQ0NFU1NGVUwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3VjY2VlZGVkU2luY2VMYXN0QWxsQ29tcGxldGUucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IHFxLnN0YXR1cy5VUExPQURfRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZhaWxlZFNpbmNlTGFzdEFsbENvbXBsZXRlLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm90RmluaXNoZWQgPT09IDAgJiYgKHRoaXMuX3N1Y2NlZWRlZFNpbmNlTGFzdEFsbENvbXBsZXRlLmxlbmd0aCB8fCB0aGlzLl9mYWlsZWRTaW5jZUxhc3RBbGxDb21wbGV0ZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkFsbENvbXBsZXRlKHNlbGYuX3N1Y2NlZWRlZFNpbmNlTGFzdEFsbENvbXBsZXRlLCBzZWxmLl9mYWlsZWRTaW5jZUxhc3RBbGxDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWF5YmVIYW5kbGVJb3M4U2FmYXJpV29ya2Fyb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLndvcmthcm91bmRzLmlvczhTYWZhcmlVcGxvYWRzICYmIHFxLmlvczgwMCgpICYmIHFxLmlvc1NhZmFyaSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWxlcnQoc2VsZi5fb3B0aW9ucy5tZXNzYWdlcy51bnN1cHBvcnRlZEJyb3dzZXJJb3M4U2FmYXJpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBxcS5FcnJvcih0aGlzLl9vcHRpb25zLm1lc3NhZ2VzLnVuc3VwcG9ydGVkQnJvd3NlcklvczhTYWZhcmkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWF5YmVQYXJzZUFuZFNlbmRVcGxvYWRFcnJvcjogZnVuY3Rpb24oaWQsIG5hbWUsIHJlc3BvbnNlLCB4aHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhociAmJiB4aHIuc3RhdHVzICE9PSAyMDAgJiYgIXJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vbkVycm9yKGlkLCBuYW1lLCBcIlhIUiByZXR1cm5lZCByZXNwb25zZSBjb2RlIFwiICsgeGhyLnN0YXR1cywgeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvclJlYXNvbiA9IHJlc3BvbnNlLmVycm9yID8gcmVzcG9uc2UuZXJyb3IgOiB0aGlzLl9vcHRpb25zLnRleHQuZGVmYXVsdFJlc3BvbnNlRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vbkVycm9yKGlkLCBuYW1lLCBlcnJvclJlYXNvbiwgeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWF5YmVQcm9jZXNzTmV4dEl0ZW1BZnRlck9uVmFsaWRhdGVDYWxsYmFjazogZnVuY3Rpb24odmFsaWRJdGVtLCBpdGVtcywgaW5kZXgsIHBhcmFtcywgZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZEl0ZW0gfHwgIXRoaXMuX29wdGlvbnMudmFsaWRhdGlvbi5zdG9wT25GaXJzdEludmFsaWRGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0aW9uRGVzY3JpcHRvciA9IHNlbGYuX2dldFZhbGlkYXRpb25EZXNjcmlwdG9yKGl0ZW1zW2luZGV4XSksIGJ1dHRvbklkID0gc2VsZi5fZ2V0QnV0dG9uSWQoaXRlbXNbaW5kZXhdLmZpbGUpLCBidXR0b24gPSBzZWxmLl9nZXRCdXR0b24oYnV0dG9uSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2hhbmRsZUNoZWNrZWRDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwib25WYWxpZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogcXEuYmluZChzZWxmLl9vcHRpb25zLmNhbGxiYWNrcy5vblZhbGlkYXRlLCBzZWxmLCB2YWxpZGF0aW9uRGVzY3JpcHRvciwgYnV0dG9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBxcS5iaW5kKHNlbGYuX29uVmFsaWRhdGVDYWxsYmFja1N1Y2Nlc3MsIHNlbGYsIGl0ZW1zLCBpbmRleCwgcGFyYW1zLCBlbmRwb2ludCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRmFpbHVyZTogcXEuYmluZChzZWxmLl9vblZhbGlkYXRlQ2FsbGJhY2tGYWlsdXJlLCBzZWxmLCBpdGVtcywgaW5kZXgsIHBhcmFtcywgZW5kcG9pbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBcIkl0ZW0gJ1wiICsgdmFsaWRhdGlvbkRlc2NyaXB0b3IubmFtZSArIFwiJywgc2l6ZTogXCIgKyB2YWxpZGF0aW9uRGVzY3JpcHRvci5zaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdmFsaWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDtpbmRleCA8IGl0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZpbGVPckJsb2JSZWplY3RlZChpdGVtc1tpbmRleF0uaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkFsbENvbXBsZXRlOiBmdW5jdGlvbihzdWNjZXNzZnVsLCBmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbFByb2dyZXNzICYmIHRoaXMuX3RvdGFsUHJvZ3Jlc3Mub25BbGxDb21wbGV0ZShzdWNjZXNzZnVsLCBmYWlsZWQsIHRoaXMuX3ByZXZlbnRSZXRyaWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vbkFsbENvbXBsZXRlKHFxLmV4dGVuZChbXSwgc3VjY2Vzc2Z1bCksIHFxLmV4dGVuZChbXSwgZmFpbGVkKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3VjY2VlZGVkU2luY2VMYXN0QWxsQ29tcGxldGUgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYWlsZWRTaW5jZUxhc3RBbGxDb21wbGV0ZSA9IFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkF1dG9SZXRyeTogZnVuY3Rpb24oaWQsIG5hbWUsIHJlc3BvbnNlSlNPTiwgeGhyLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBzZWxmLl9wcmV2ZW50UmV0cmllc1tpZF0gPSByZXNwb25zZUpTT05bc2VsZi5fb3B0aW9ucy5yZXRyeS5wcmV2ZW50UmV0cnlSZXNwb25zZVByb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fc2hvdWxkQXV0b1JldHJ5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0cnlXYWl0UGVyaW9kID0gc2VsZi5fb3B0aW9ucy5yZXRyeS5hdXRvQXR0ZW1wdERlbGF5ICogMWUzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9tYXliZVBhcnNlQW5kU2VuZFVwbG9hZEVycm9yLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzLm9uQXV0b1JldHJ5KGlkLCBuYW1lLCBzZWxmLl9hdXRvUmV0cmllc1tpZF0pO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9vbkJlZm9yZUF1dG9SZXRyeShpZCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3VwbG9hZERhdGEuc2V0U3RhdHVzKGlkLCBxcS5zdGF0dXMuVVBMT0FEX1JFVFJZSU5HKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmV0cnlUaW1lb3V0c1tpZF0gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2coXCJTdGFydGluZyByZXRyeSBmb3IgXCIgKyBuYW1lICsgXCIuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2hhbmRsZXIucmV0cnkoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCByZXRyeVdhaXRQZXJpb2QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uQmVmb3JlQXV0b1JldHJ5OiBmdW5jdGlvbihpZCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiV2FpdGluZyBcIiArIHRoaXMuX29wdGlvbnMucmV0cnkuYXV0b0F0dGVtcHREZWxheSArIFwiIHNlY29uZHMgYmVmb3JlIHJldHJ5aW5nIFwiICsgbmFtZSArIFwiLi4uXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkJlZm9yZU1hbnVhbFJldHJ5OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtTGltaXQgPSB0aGlzLl9jdXJyZW50SXRlbUxpbWl0LCBmaWxlTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJldmVudFJldHJpZXNbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiUmV0cmllcyBhcmUgZm9yYmlkZGVuIGZvciBpZCBcIiArIGlkLCBcIndhcm5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hhbmRsZXIuaXNWYWxpZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUgPSB0aGlzLmdldE5hbWUoaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5jYWxsYmFja3Mub25NYW51YWxSZXRyeShpZCwgZmlsZU5hbWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtTGltaXQgPiAwICYmIHRoaXMuX25ldFVwbG9hZGVkT3JRdWV1ZWQgKyAxID4gaXRlbUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtRXJyb3IoXCJyZXRyeUZhaWxUb29NYW55SXRlbXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJSZXRyeWluZyB1cGxvYWQgZm9yICdcIiArIGZpbGVOYW1lICsgXCInIChpZDogXCIgKyBpZCArIFwiKS4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCInXCIgKyBpZCArIFwiJyBpcyBub3QgYSB2YWxpZCBmaWxlIElEXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uQ2FuY2VsOiBmdW5jdGlvbihpZCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25ldFVwbG9hZGVkT3JRdWV1ZWQtLTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmV0cnlUaW1lb3V0c1tpZF0pO1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZWRJdGVtSW5kZXggPSBxcS5pbmRleE9mKHRoaXMuX3N0b3JlZElkcywgaWQpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5hdXRvVXBsb2FkICYmIHN0b3JlZEl0ZW1JbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3JlZElkcy5zcGxpY2Uoc3RvcmVkSXRlbUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YS5zZXRTdGF0dXMoaWQsIHFxLnN0YXR1cy5DQU5DRUxFRCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uQ29tcGxldGU6IGZ1bmN0aW9uKGlkLCBuYW1lLCByZXN1bHQsIHhocikge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV0VXBsb2FkZWRPclF1ZXVlZC0tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWREYXRhLnNldFN0YXR1cyhpZCwgcXEuc3RhdHVzLlVQTE9BRF9GQUlMRUQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0W3RoaXMuX29wdGlvbnMucmV0cnkucHJldmVudFJldHJ5UmVzcG9uc2VQcm9wZXJ0eV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZlbnRSZXRyaWVzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnRodW1ibmFpbFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGh1bWJuYWlsVXJsc1tpZF0gPSByZXN1bHQudGh1bWJuYWlsVXJsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25ldFVwbG9hZGVkKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEuc2V0U3RhdHVzKGlkLCBxcS5zdGF0dXMuVVBMT0FEX1NVQ0NFU1NGVUwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9tYXliZVBhcnNlQW5kU2VuZFVwbG9hZEVycm9yKGlkLCBuYW1lLCByZXN1bHQsIHhocik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkRlbGV0ZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWREYXRhLnNldFN0YXR1cyhpZCwgcXEuc3RhdHVzLkRFTEVUSU5HKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25EZWxldGVDb21wbGV0ZTogZnVuY3Rpb24oaWQsIHhock9yWGRyLCBpc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmdldE5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZURlbGV0ZUZhaWxlZChpZCwgeGhyT3JYZHIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZURlbGV0ZVN1Y2Nlc3MoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25JbnB1dENoYW5nZTogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChxcS5zdXBwb3J0ZWRGZWF0dXJlcy5hamF4VXBsb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoZmlsZUluZGV4ID0gMDsgZmlsZUluZGV4IDwgaW5wdXQuZmlsZXMubGVuZ3RoOyBmaWxlSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5ub3RhdGVXaXRoQnV0dG9uSWQoaW5wdXQuZmlsZXNbZmlsZUluZGV4XSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlsZXMoaW5wdXQuZmlsZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEZpbGVzKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXEuZWFjaCh0aGlzLl9idXR0b25zLCBmdW5jdGlvbihpZHgsIGJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25Qcm9ncmVzczogZnVuY3Rpb24oaWQsIG5hbWUsIGxvYWRlZCwgdG90YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbFByb2dyZXNzICYmIHRoaXMuX3RvdGFsUHJvZ3Jlc3Mub25JbmRpdmlkdWFsUHJvZ3Jlc3MoaWQsIGxvYWRlZCwgdG90YWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblN1Ym1pdDogZnVuY3Rpb24oaWQsIG5hbWUpIHt9LFxuICAgICAgICAgICAgX29uU3VibWl0Q2FsbGJhY2tTdWNjZXNzOiBmdW5jdGlvbihpZCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3VibWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YS5zZXRTdGF0dXMoaWQsIHFxLnN0YXR1cy5TVUJNSVRURUQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3VibWl0dGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYXV0b1VwbG9hZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vblN1Ym1pdHRlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWRGaWxlKGlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdG9yZUZvckxhdGVyKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5jYWxsYmFja3Mub25TdWJtaXR0ZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uU3VibWl0RGVsZXRlOiBmdW5jdGlvbihpZCwgb25TdWNjZXNzQ2FsbGJhY2ssIGFkZGl0aW9uYWxNYW5kYXRlZFBhcmFtcykge1xuICAgICAgICAgICAgICAgIHZhciB1dWlkID0gdGhpcy5nZXRVdWlkKGlkKSwgYWRqdXN0ZWRPblN1Y2Nlc3NDYWxsYmFjaztcbiAgICAgICAgICAgICAgICBpZiAob25TdWNjZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWRPblN1Y2Nlc3NDYWxsYmFjayA9IHFxLmJpbmQob25TdWNjZXNzQ2FsbGJhY2ssIHRoaXMsIGlkLCB1dWlkLCBhZGRpdGlvbmFsTWFuZGF0ZWRQYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNEZWxldGVQb3NzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNoZWNrZWRDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm9uU3VibWl0RGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogcXEuYmluZCh0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vblN1Ym1pdERlbGV0ZSwgdGhpcywgaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBhZGp1c3RlZE9uU3VjY2Vzc0NhbGxiYWNrIHx8IHFxLmJpbmQodGhpcy5fZGVsZXRlSGFuZGxlci5zZW5kRGVsZXRlLCB0aGlzLCBpZCwgdXVpZCwgYWRkaXRpb25hbE1hbmRhdGVkUGFyYW1zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIkRlbGV0ZSByZXF1ZXN0IGlnbm9yZWQgZm9yIElEIFwiICsgaWQgKyBcIiwgZGVsZXRlIGZlYXR1cmUgaXMgZGlzYWJsZWQgb3IgcmVxdWVzdCBub3QgcG9zc2libGUgXCIgKyBcImR1ZSB0byBDT1JTIG9uIGEgdXNlciBhZ2VudCB0aGF0IGRvZXMgbm90IHN1cHBvcnQgcHJlLWZsaWdodGluZy5cIiwgXCJ3YXJuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblN1Ym1pdHRlZDogZnVuY3Rpb24oaWQpIHt9LFxuICAgICAgICAgICAgX29uVG90YWxQcm9ncmVzczogZnVuY3Rpb24obG9hZGVkLCB0b3RhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLm9uVG90YWxQcm9ncmVzcyhsb2FkZWQsIHRvdGFsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25VcGxvYWRQcmVwOiBmdW5jdGlvbihpZCkge30sXG4gICAgICAgICAgICBfb25VcGxvYWQ6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkRGF0YS5zZXRTdGF0dXMoaWQsIHFxLnN0YXR1cy5VUExPQURJTkcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblVwbG9hZENodW5rOiBmdW5jdGlvbihpZCwgY2h1bmtEYXRhKSB7fSxcbiAgICAgICAgICAgIF9vblVwbG9hZENodW5rU3VjY2VzczogZnVuY3Rpb24oaWQsIGNodW5rRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcHJldmVudFJldHJpZXNbaWRdICYmIHRoaXMuX29wdGlvbnMucmV0cnkuZW5hYmxlQXV0bykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRvUmV0cmllc1tpZF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25VcGxvYWRTdGF0dXNDaGFuZ2U6IGZ1bmN0aW9uKGlkLCBvbGRTdGF0dXMsIG5ld1N0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0dXMgPT09IHFxLnN0YXR1cy5QQVVTRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JldHJ5VGltZW91dHNbaWRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uVmFsaWRhdGVCYXRjaENhbGxiYWNrRmFpbHVyZTogZnVuY3Rpb24oZmlsZVdyYXBwZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHFxLmVhY2goZmlsZVdyYXBwZXJzLCBmdW5jdGlvbihpZHgsIGZpbGVXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZpbGVPckJsb2JSZWplY3RlZChmaWxlV3JhcHBlci5pZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uVmFsaWRhdGVCYXRjaENhbGxiYWNrU3VjY2VzczogZnVuY3Rpb24odmFsaWRhdGlvbkRlc2NyaXB0b3JzLCBpdGVtcywgcGFyYW1zLCBlbmRwb2ludCwgYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSwgaXRlbUxpbWl0ID0gdGhpcy5fY3VycmVudEl0ZW1MaW1pdCwgcHJvcG9zZWROZXRGaWxlc1VwbG9hZGVkT3JRdWV1ZWQgPSB0aGlzLl9uZXRVcGxvYWRlZE9yUXVldWVkO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtTGltaXQgPT09IDAgfHwgcHJvcG9zZWROZXRGaWxlc1VwbG9hZGVkT3JRdWV1ZWQgPD0gaXRlbUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVDaGVja2VkQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwib25WYWxpZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBxcS5iaW5kKHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLm9uVmFsaWRhdGUsIHRoaXMsIHZhbGlkYXRpb25EZXNjcmlwdG9yc1swXSwgYnV0dG9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHFxLmJpbmQodGhpcy5fb25WYWxpZGF0ZUNhbGxiYWNrU3VjY2VzcywgdGhpcywgaXRlbXMsIDAsIHBhcmFtcywgZW5kcG9pbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRmFpbHVyZTogcXEuYmluZCh0aGlzLl9vblZhbGlkYXRlQ2FsbGJhY2tGYWlsdXJlLCB0aGlzLCBpdGVtcywgMCwgcGFyYW1zLCBlbmRwb2ludCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogXCJJdGVtICdcIiArIGl0ZW1zWzBdLmZpbGUubmFtZSArIFwiJywgc2l6ZTogXCIgKyBpdGVtc1swXS5maWxlLnNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbUVycm9yKFwibm9GaWxlc0Vycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25WYWxpZGF0ZUJhdGNoQ2FsbGJhY2tGYWlsdXJlKGl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gdGhpcy5fb3B0aW9ucy5tZXNzYWdlcy50b29NYW55SXRlbXNFcnJvci5yZXBsYWNlKC9cXHtuZXRJdGVtc1xcfS9nLCBwcm9wb3NlZE5ldEZpbGVzVXBsb2FkZWRPclF1ZXVlZCkucmVwbGFjZSgvXFx7aXRlbUxpbWl0XFx9L2csIGl0ZW1MaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JhdGNoRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uVmFsaWRhdGVDYWxsYmFja0ZhaWx1cmU6IGZ1bmN0aW9uKGl0ZW1zLCBpbmRleCwgcGFyYW1zLCBlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsZU9yQmxvYlJlamVjdGVkKGl0ZW1zW2luZGV4XS5pZCwgaXRlbXNbaW5kZXhdLmZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWF5YmVQcm9jZXNzTmV4dEl0ZW1BZnRlck9uVmFsaWRhdGVDYWxsYmFjayhmYWxzZSwgaXRlbXMsIG5leHRJbmRleCwgcGFyYW1zLCBlbmRwb2ludCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uVmFsaWRhdGVDYWxsYmFja1N1Y2Nlc3M6IGZ1bmN0aW9uKGl0ZW1zLCBpbmRleCwgcGFyYW1zLCBlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcywgbmV4dEluZGV4ID0gaW5kZXggKyAxLCB2YWxpZGF0aW9uRGVzY3JpcHRvciA9IHRoaXMuX2dldFZhbGlkYXRpb25EZXNjcmlwdG9yKGl0ZW1zW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVGaWxlT3JCbG9iRGF0YShpdGVtc1tpbmRleF0sIHZhbGlkYXRpb25EZXNjcmlwdG9yKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl91cGxvYWQoaXRlbXNbaW5kZXhdLmlkLCBwYXJhbXMsIGVuZHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbWF5YmVQcm9jZXNzTmV4dEl0ZW1BZnRlck9uVmFsaWRhdGVDYWxsYmFjayh0cnVlLCBpdGVtcywgbmV4dEluZGV4LCBwYXJhbXMsIGVuZHBvaW50KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbWF5YmVQcm9jZXNzTmV4dEl0ZW1BZnRlck9uVmFsaWRhdGVDYWxsYmFjayhmYWxzZSwgaXRlbXMsIG5leHRJbmRleCwgcGFyYW1zLCBlbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ByZXBhcmVJdGVtc0ZvclVwbG9hZDogZnVuY3Rpb24oaXRlbXMsIHBhcmFtcywgZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1FcnJvcihcIm5vRmlsZXNFcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGlvbkRlc2NyaXB0b3JzID0gdGhpcy5fZ2V0VmFsaWRhdGlvbkRlc2NyaXB0b3JzKGl0ZW1zKSwgYnV0dG9uSWQgPSB0aGlzLl9nZXRCdXR0b25JZChpdGVtc1swXS5maWxlKSwgYnV0dG9uID0gdGhpcy5fZ2V0QnV0dG9uKGJ1dHRvbklkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVDaGVja2VkQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm9uVmFsaWRhdGVCYXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogcXEuYmluZCh0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5vblZhbGlkYXRlQmF0Y2gsIHRoaXMsIHZhbGlkYXRpb25EZXNjcmlwdG9ycywgYnV0dG9uKSxcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBxcS5iaW5kKHRoaXMuX29uVmFsaWRhdGVCYXRjaENhbGxiYWNrU3VjY2VzcywgdGhpcywgdmFsaWRhdGlvbkRlc2NyaXB0b3JzLCBpdGVtcywgcGFyYW1zLCBlbmRwb2ludCwgYnV0dG9uKSxcbiAgICAgICAgICAgICAgICAgICAgb25GYWlsdXJlOiBxcS5iaW5kKHRoaXMuX29uVmFsaWRhdGVCYXRjaENhbGxiYWNrRmFpbHVyZSwgdGhpcywgaXRlbXMpLFxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBcImJhdGNoIHZhbGlkYXRpb25cIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9wcmV2ZW50TGVhdmVJblByb2dyZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZVN1cHBvcnQuYXR0YWNoKHdpbmRvdywgXCJiZWZvcmV1bmxvYWRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5nZXRJblByb2dyZXNzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBzZWxmLl9vcHRpb25zLm1lc3NhZ2VzLm9uTGVhdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb3B0aW9ucy5tZXNzYWdlcy5vbkxlYXZlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlZnJlc2hTZXNzaW9uRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBvcHRpb25zID0gdGhpcy5fb3B0aW9ucy5zZXNzaW9uO1xuICAgICAgICAgICAgICAgIGlmIChxcS5TZXNzaW9uICYmIHRoaXMuX29wdGlvbnMuc2Vzc2lvbi5lbmRwb2ludCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXEuZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JzOiB0aGlzLl9vcHRpb25zLmNvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2cgPSBxcS5iaW5kKHRoaXMubG9nLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYWRkRmlsZVJlY29yZCA9IHFxLmJpbmQodGhpcy5fYWRkQ2FubmVkRmlsZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXNzaW9uID0gbmV3IHFxLlNlc3Npb24ob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3Nlc3Npb24ucmVmcmVzaCgpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UsIHhock9yWGRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2Vzc2lvblJlcXVlc3RDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzLm9uU2Vzc2lvblJlcXVlc3RDb21wbGV0ZShyZXNwb25zZSwgdHJ1ZSwgeGhyT3JYZHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24ocmVzcG9uc2UsIHhock9yWGRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb3B0aW9ucy5jYWxsYmFja3Mub25TZXNzaW9uUmVxdWVzdENvbXBsZXRlKHJlc3BvbnNlLCBmYWxzZSwgeGhyT3JYZHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2Vzc2lvblJlcXVlc3RDb21wbGV0ZTogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgIF9zZXRTaXplOiBmdW5jdGlvbihpZCwgbmV3U2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEudXBkYXRlU2l6ZShpZCwgbmV3U2l6ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxQcm9ncmVzcyAmJiB0aGlzLl90b3RhbFByb2dyZXNzLm9uTmV3U2l6ZShpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3Nob3VsZEF1dG9SZXRyeTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBsb2FkRGF0YSA9IHRoaXMuX3VwbG9hZERhdGEucmV0cmlldmUoe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3ByZXZlbnRSZXRyaWVzW2lkXSAmJiB0aGlzLl9vcHRpb25zLnJldHJ5LmVuYWJsZUF1dG8gJiYgdXBsb2FkRGF0YS5zdGF0dXMgIT09IHFxLnN0YXR1cy5QQVVTRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F1dG9SZXRyaWVzW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRvUmV0cmllc1tpZF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdXRvUmV0cmllc1tpZF0gPCB0aGlzLl9vcHRpb25zLnJldHJ5Lm1heEF1dG9BdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0b1JldHJpZXNbaWRdICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3N0b3JlRm9yTGF0ZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcmVkSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF90cmFja0J1dHRvbjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnV0dG9uSWQ7XG4gICAgICAgICAgICAgICAgaWYgKHFxLnN1cHBvcnRlZEZlYXR1cmVzLmFqYXhVcGxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uSWQgPSB0aGlzLl9oYW5kbGVyLmdldEZpbGUoaWQpLnFxQnV0dG9uSWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uSWQgPSB0aGlzLl9nZXRCdXR0b25JZCh0aGlzLl9oYW5kbGVyLmdldElucHV0KGlkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChidXR0b25JZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9idXR0b25JZHNGb3JGaWxlSWRzW2lkXSA9IGJ1dHRvbklkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdXBkYXRlRm9ybVN1cHBvcnRBbmRQYXJhbXM6IGZ1bmN0aW9uKGZvcm1FbGVtZW50T3JJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuZm9ybS5lbGVtZW50ID0gZm9ybUVsZW1lbnRPcklkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Zvcm1TdXBwb3J0ID0gcXEuRm9ybVN1cHBvcnQgJiYgbmV3IHFxLkZvcm1TdXBwb3J0KHRoaXMuX29wdGlvbnMuZm9ybSwgcXEuYmluZCh0aGlzLnVwbG9hZFN0b3JlZEZpbGVzLCB0aGlzKSwgcXEuYmluZCh0aGlzLmxvZywgdGhpcykpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mb3JtU3VwcG9ydCAmJiB0aGlzLl9mb3JtU3VwcG9ydC5hdHRhY2hlZFRvRm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbXNTdG9yZS5hZGRSZWFkT25seShudWxsLCB0aGlzLl9mb3JtU3VwcG9ydC5nZXRGb3JtSW5wdXRzQXNPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLmF1dG9VcGxvYWQgPSB0aGlzLl9mb3JtU3VwcG9ydC5uZXdBdXRvVXBsb2FkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZm9ybVN1cHBvcnQubmV3RW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RW5kcG9pbnQodGhpcy5fZm9ybVN1cHBvcnQubmV3RW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF91cGxvYWQ6IGZ1bmN0aW9uKGlkLCBwYXJhbXMsIGVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmdldE5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMocGFyYW1zLCBpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbmRwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEVuZHBvaW50KGVuZHBvaW50LCBpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNoZWNrZWRDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwib25TdWJtaXRcIixcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHFxLmJpbmQodGhpcy5fb3B0aW9ucy5jYWxsYmFja3Mub25TdWJtaXQsIHRoaXMsIGlkLCBuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBxcS5iaW5kKHRoaXMuX29uU3VibWl0Q2FsbGJhY2tTdWNjZXNzLCB0aGlzLCBpZCwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgIG9uRmFpbHVyZTogcXEuYmluZCh0aGlzLl9maWxlT3JCbG9iUmVqZWN0ZWQsIHRoaXMsIGlkLCBuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfdXBsb2FkRmlsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXIudXBsb2FkKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWREYXRhLnNldFN0YXR1cyhpZCwgcXEuc3RhdHVzLlFVRVVFRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF91cGxvYWRTdG9yZWRGaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkVG9VcGxvYWQsIHN0aWxsU3VibWl0dGluZywgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3N0b3JlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWRUb1VwbG9hZCA9IHRoaXMuX3N0b3JlZElkcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGxvYWRGaWxlKGlkVG9VcGxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGlsbFN1Ym1pdHRpbmcgPSB0aGlzLmdldFVwbG9hZHMoe1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHFxLnN0YXR1cy5TVUJNSVRUSU5HXG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChzdGlsbFN1Ym1pdHRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEubG9nKFwiU3RpbGwgd2FpdGluZyBmb3IgXCIgKyBzdGlsbFN1Ym1pdHRpbmcgKyBcIiBmaWxlcyB0byBjbGVhciBzdWJtaXQgcXVldWUuIFdpbGwgcmUtcGFyc2Ugc3RvcmVkIElEcyBhcnJheSBzaG9ydGx5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3VwbG9hZFN0b3JlZEZpbGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDFlMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF92YWxpZGF0ZUZpbGVPckJsb2JEYXRhOiBmdW5jdGlvbihmaWxlV3JhcHBlciwgdmFsaWRhdGlvbkRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGZpbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVXcmFwcGVyLmZpbGUgaW5zdGFuY2VvZiBxcS5CbG9iUHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlV3JhcHBlci5maWxlLnJlZmVyZW5jZUJsb2I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVXcmFwcGVyLmZpbGU7XG4gICAgICAgICAgICAgICAgfSgpLCBuYW1lID0gdmFsaWRhdGlvbkRlc2NyaXB0b3IubmFtZSwgc2l6ZSA9IHZhbGlkYXRpb25EZXNjcmlwdG9yLnNpemUsIGJ1dHRvbklkID0gdGhpcy5fZ2V0QnV0dG9uSWQoZmlsZVdyYXBwZXIuZmlsZSksIHZhbGlkYXRpb25CYXNlID0gdGhpcy5fZ2V0VmFsaWRhdGlvbkJhc2UoYnV0dG9uSWQpLCB2YWxpZGl0eUNoZWNrZXIgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHZhbGlkaXR5Q2hlY2tlci50aGVuKGZ1bmN0aW9uKCkge30sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9maWxlT3JCbG9iUmVqZWN0ZWQoZmlsZVdyYXBwZXIuaWQsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChxcS5pc0ZpbGVPcklucHV0KGZpbGUpICYmICF0aGlzLl9pc0FsbG93ZWRFeHRlbnNpb24odmFsaWRhdGlvbkJhc2UuYWxsb3dlZEV4dGVuc2lvbnMsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1FcnJvcihcInR5cGVFcnJvclwiLCBuYW1lLCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkaXR5Q2hlY2tlci5mYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy52YWxpZGF0aW9uLmFsbG93RW1wdHkgJiYgc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtRXJyb3IoXCJlbXB0eUVycm9yXCIsIG5hbWUsIGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRpdHlDaGVja2VyLmZhaWx1cmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPiAwICYmIHZhbGlkYXRpb25CYXNlLnNpemVMaW1pdCAmJiBzaXplID4gdmFsaWRhdGlvbkJhc2Uuc2l6ZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1FcnJvcihcInNpemVFcnJvclwiLCBuYW1lLCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkaXR5Q2hlY2tlci5mYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaXplID4gMCAmJiBzaXplIDwgdmFsaWRhdGlvbkJhc2UubWluU2l6ZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1FcnJvcihcIm1pblNpemVFcnJvclwiLCBuYW1lLCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkaXR5Q2hlY2tlci5mYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChxcS5JbWFnZVZhbGlkYXRpb24gJiYgcXEuc3VwcG9ydGVkRmVhdHVyZXMuaW1hZ2VQcmV2aWV3cyAmJiBxcS5pc0ZpbGUoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IHFxLkltYWdlVmFsaWRhdGlvbihmaWxlLCBxcS5iaW5kKHNlbGYubG9nLCBzZWxmKSkudmFsaWRhdGUodmFsaWRhdGlvbkJhc2UuaW1hZ2UpLnRoZW4odmFsaWRpdHlDaGVja2VyLnN1Y2Nlc3MsIGZ1bmN0aW9uKGVycm9yQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faXRlbUVycm9yKGVycm9yQ29kZSArIFwiSW1hZ2VFcnJvclwiLCBuYW1lLCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkaXR5Q2hlY2tlci5mYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkaXR5Q2hlY2tlci5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGl0eUNoZWNrZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3dyYXBDYWxsYmFja3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmLCBzYWZlQ2FsbGJhY2ssIHByb3A7XG4gICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgc2FmZUNhbGxiYWNrID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTXNnO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTXNnID0gZXhjZXB0aW9uLm1lc3NhZ2UgfHwgZXhjZXB0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhcIkNhdWdodCBleGNlcHRpb24gaW4gJ1wiICsgbmFtZSArIFwiJyBjYWxsYmFjayAtIFwiICsgZXJyb3JNc2csIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAocHJvcCBpbiB0aGlzLl9vcHRpb25zLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tOYW1lLCBjYWxsYmFja0Z1bmM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja05hbWUgPSBwcm9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tGdW5jID0gc2VsZi5fb3B0aW9ucy5jYWxsYmFja3NbY2FsbGJhY2tOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29wdGlvbnMuY2FsbGJhY2tzW2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2FmZUNhbGxiYWNrKGNhbGxiYWNrTmFtZSwgY2FsbGJhY2tGdW5jLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBxcS5GaW5lVXBsb2FkZXJCYXNpYyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGJ1dHRvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtYXhDb25uZWN0aW9uczogMyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlQ2FuY2VsRm9yRm9ybVVwbG9hZHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGF1dG9VcGxvYWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgd2FybkJlZm9yZVVubG9hZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogXCIvc2VydmVyL3VwbG9hZFwiLFxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZVBhcmFtOiBcInFxZmlsZW5hbWVcIixcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VNdWx0aXBhcnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0TmFtZTogXCJxcWZpbGVcIixcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgb21pdERlZmF1bHRQYXJhbXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNJbkJvZHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVTdWNjZXNzSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdG90YWxGaWxlU2l6ZU5hbWU6IFwicXF0b3RhbGZpbGVzaXplXCIsXG4gICAgICAgICAgICAgICAgICAgIHV1aWROYW1lOiBcInFxdXVpZFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRFeHRlbnNpb25zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZUxpbWl0OiAwLFxuICAgICAgICAgICAgICAgICAgICBtaW5TaXplTGltaXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1MaW1pdDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcE9uRmlyc3RJbnZhbGlkRmlsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWNjZXB0RmlsZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkhlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsbG93RW1wdHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgICAgICAgICAgb25TdWJtaXQ6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25TdWJtaXR0ZWQ6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oaWQsIG5hbWUsIHJlc3BvbnNlSlNPTiwgbWF5YmVYaHIpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvbkFsbENvbXBsZXRlOiBmdW5jdGlvbihzdWNjZXNzZnVsLCBmYWlsZWQpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbDogZnVuY3Rpb24oaWQsIG5hbWUpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvblVwbG9hZDogZnVuY3Rpb24oaWQsIG5hbWUpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvblVwbG9hZENodW5rOiBmdW5jdGlvbihpZCwgbmFtZSwgY2h1bmtEYXRhKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25VcGxvYWRDaHVua1N1Y2Nlc3M6IGZ1bmN0aW9uKGlkLCBjaHVua0RhdGEsIHJlc3BvbnNlSlNPTiwgeGhyKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25SZXN1bWU6IGZ1bmN0aW9uKGlkLCBmaWxlTmFtZSwgY2h1bmtEYXRhLCBjdXN0b21SZXN1bWVEYXRhKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24oaWQsIG5hbWUsIGxvYWRlZCwgdG90YWwpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvblRvdGFsUHJvZ3Jlc3M6IGZ1bmN0aW9uKGxvYWRlZCwgdG90YWwpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbihpZCwgbmFtZSwgcmVhc29uLCBtYXliZVhock9yWGRyKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25BdXRvUmV0cnk6IGZ1bmN0aW9uKGlkLCBuYW1lLCBhdHRlbXB0TnVtYmVyKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25NYW51YWxSZXRyeTogZnVuY3Rpb24oaWQsIG5hbWUpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvblZhbGlkYXRlQmF0Y2g6IGZ1bmN0aW9uKGZpbGVPckJsb2JEYXRhKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25WYWxpZGF0ZTogZnVuY3Rpb24oZmlsZU9yQmxvYkRhdGEpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvblN1Ym1pdERlbGV0ZTogZnVuY3Rpb24oaWQpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZTogZnVuY3Rpb24oaWQpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZUNvbXBsZXRlOiBmdW5jdGlvbihpZCwgeGhyT3JYZHIsIGlzRXJyb3IpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvblBhc3RlUmVjZWl2ZWQ6IGZ1bmN0aW9uKGJsb2IpIHt9LFxuICAgICAgICAgICAgICAgICAgICBvblN0YXR1c0NoYW5nZTogZnVuY3Rpb24oaWQsIG9sZFN0YXR1cywgbmV3U3RhdHVzKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgb25TZXNzaW9uUmVxdWVzdENvbXBsZXRlOiBmdW5jdGlvbihyZXNwb25zZSwgc3VjY2VzcywgeGhyT3JYZHIpIHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlRXJyb3I6IFwie2ZpbGV9IGhhcyBhbiBpbnZhbGlkIGV4dGVuc2lvbi4gVmFsaWQgZXh0ZW5zaW9uKHMpOiB7ZXh0ZW5zaW9uc30uXCIsXG4gICAgICAgICAgICAgICAgICAgIHNpemVFcnJvcjogXCJ7ZmlsZX0gaXMgdG9vIGxhcmdlLCBtYXhpbXVtIGZpbGUgc2l6ZSBpcyB7c2l6ZUxpbWl0fS5cIixcbiAgICAgICAgICAgICAgICAgICAgbWluU2l6ZUVycm9yOiBcIntmaWxlfSBpcyB0b28gc21hbGwsIG1pbmltdW0gZmlsZSBzaXplIGlzIHttaW5TaXplTGltaXR9LlwiLFxuICAgICAgICAgICAgICAgICAgICBlbXB0eUVycm9yOiBcIntmaWxlfSBpcyBlbXB0eSwgcGxlYXNlIHNlbGVjdCBmaWxlcyBhZ2FpbiB3aXRob3V0IGl0LlwiLFxuICAgICAgICAgICAgICAgICAgICBub0ZpbGVzRXJyb3I6IFwiTm8gZmlsZXMgdG8gdXBsb2FkLlwiLFxuICAgICAgICAgICAgICAgICAgICB0b29NYW55SXRlbXNFcnJvcjogXCJUb28gbWFueSBpdGVtcyAoe25ldEl0ZW1zfSkgd291bGQgYmUgdXBsb2FkZWQuICBJdGVtIGxpbWl0IGlzIHtpdGVtTGltaXR9LlwiLFxuICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHRJbWFnZUVycm9yOiBcIkltYWdlIGlzIHRvbyB0YWxsLlwiLFxuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aEltYWdlRXJyb3I6IFwiSW1hZ2UgaXMgdG9vIHdpZGUuXCIsXG4gICAgICAgICAgICAgICAgICAgIG1pbkhlaWdodEltYWdlRXJyb3I6IFwiSW1hZ2UgaXMgbm90IHRhbGwgZW5vdWdoLlwiLFxuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aEltYWdlRXJyb3I6IFwiSW1hZ2UgaXMgbm90IHdpZGUgZW5vdWdoLlwiLFxuICAgICAgICAgICAgICAgICAgICByZXRyeUZhaWxUb29NYW55SXRlbXM6IFwiUmV0cnkgZmFpbGVkIC0geW91IGhhdmUgcmVhY2hlZCB5b3VyIGZpbGUgbGltaXQuXCIsXG4gICAgICAgICAgICAgICAgICAgIG9uTGVhdmU6IFwiVGhlIGZpbGVzIGFyZSBiZWluZyB1cGxvYWRlZCwgaWYgeW91IGxlYXZlIG5vdyB0aGUgdXBsb2FkIHdpbGwgYmUgY2FuY2VsZWQuXCIsXG4gICAgICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkQnJvd3NlcklvczhTYWZhcmk6IFwiVW5yZWNvdmVyYWJsZSBlcnJvciAtIHRoaXMgYnJvd3NlciBkb2VzIG5vdCBwZXJtaXQgZmlsZSB1cGxvYWRpbmcgb2YgYW55IGtpbmQgZHVlIHRvIHNlcmlvdXMgYnVncyBpbiBpT1M4IFNhZmFyaS4gIFBsZWFzZSB1c2UgaU9TOCBDaHJvbWUgdW50aWwgQXBwbGUgZml4ZXMgdGhlc2UgaXNzdWVzLlwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXRyeToge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVBdXRvOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWF4QXV0b0F0dGVtcHRzOiAzLFxuICAgICAgICAgICAgICAgICAgICBhdXRvQXR0ZW1wdERlbGF5OiA1LFxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50UmV0cnlSZXNwb25zZVByb3BlcnR5OiBcInByZXZlbnRSZXRyeVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGFzc2VzOiB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkhvdmVyOiBcInFxLXVwbG9hZC1idXR0b24taG92ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uRm9jdXM6IFwicXEtdXBsb2FkLWJ1dHRvbi1mb2N1c1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjaHVua2luZzoge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uY3VycmVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbWFuZGF0b3J5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4OiBcInFxcGFydGluZGV4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0Qnl0ZU9mZnNldDogXCJxcXBhcnRieXRlb2Zmc2V0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua1NpemU6IFwicXFjaHVua3NpemVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsRmlsZVNpemU6IFwicXF0b3RhbGZpbGVzaXplXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFBhcnRzOiBcInFxdG90YWxwYXJ0c1wiXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnRTaXplOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDJlNjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25QYXlsb2FkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRPblN0YXR1czogW11cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzdW1lOiB7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmRzRXhwaXJlSW46IDcsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VtaW5nOiBcInFxcmVzdW1lXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tS2V5czogZnVuY3Rpb24oZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZvcm1hdEZpbGVOYW1lOiBmdW5jdGlvbihmaWxlT3JCbG9iTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsZU9yQmxvYk5hbWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRSZXNwb25zZUVycm9yOiBcIlVwbG9hZCBmYWlsdXJlIHJlYXNvbiB1bmtub3duXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVJbnB1dFRpdGxlOiBcImZpbGUgaW5wdXRcIixcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVN5bWJvbHM6IFsgXCJrQlwiLCBcIk1CXCIsIFwiR0JcIiwgXCJUQlwiLCBcIlBCXCIsIFwiRUJcIiBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWxldGVGaWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBcIi9zZXJ2ZXIvdXBsb2FkXCIsXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb3JzOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc2VuZENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dYZHI6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBibG9iczoge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TmFtZTogXCJtaXNjX2RhdGFcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFzdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE5hbWU6IFwicGFzdGVkX2ltYWdlXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbWVyYToge1xuICAgICAgICAgICAgICAgICAgICBpb3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBidXR0b246IG51bGxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4dHJhQnV0dG9uczogW10sXG4gICAgICAgICAgICAgICAgc2Vzc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tSGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hPblJlc2V0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmb3JtOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IFwicXEtZm9ybVwiLFxuICAgICAgICAgICAgICAgICAgICBhdXRvVXBsb2FkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJjZXB0U3VibWl0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzY2FsaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVJlc2l6ZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNlbmRPcmlnaW5hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFF1YWxpdHk6IDgwLFxuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlVGV4dDogXCJGYWlsZWQgdG8gc2NhbGVcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUV4aWY6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzaXplczogW11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHdvcmthcm91bmRzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlvc0VtcHR5VmlkZW9zOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpb3M4U2FmYXJpVXBsb2FkczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW9zOEJyb3dzZXJDcmFzaDogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcXEuZXh0ZW5kKHRoaXMuX29wdGlvbnMsIG8sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5fYnV0dG9ucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZXh0cmFCdXR0b25TcGVjcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fYnV0dG9uSWRzRm9yRmlsZUlkcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fd3JhcENhbGxiYWNrcygpO1xuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZVN1cHBvcnQgPSBuZXcgcXEuRGlzcG9zZVN1cHBvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0b3JlZElkcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fYXV0b1JldHJpZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3JldHJ5VGltZW91dHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZlbnRSZXRyaWVzID0gW107XG4gICAgICAgICAgICB0aGlzLl90aHVtYm5haWxVcmxzID0gW107XG4gICAgICAgICAgICB0aGlzLl9uZXRVcGxvYWRlZE9yUXVldWVkID0gMDtcbiAgICAgICAgICAgIHRoaXMuX25ldFVwbG9hZGVkID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3VwbG9hZERhdGEgPSB0aGlzLl9jcmVhdGVVcGxvYWREYXRhVHJhY2tlcigpO1xuICAgICAgICAgICAgdGhpcy5faW5pdEZvcm1TdXBwb3J0QW5kUGFyYW1zKCk7XG4gICAgICAgICAgICB0aGlzLl9jdXN0b21IZWFkZXJzU3RvcmUgPSB0aGlzLl9jcmVhdGVTdG9yZSh0aGlzLl9vcHRpb25zLnJlcXVlc3QuY3VzdG9tSGVhZGVycyk7XG4gICAgICAgICAgICB0aGlzLl9kZWxldGVGaWxlQ3VzdG9tSGVhZGVyc1N0b3JlID0gdGhpcy5fY3JlYXRlU3RvcmUodGhpcy5fb3B0aW9ucy5kZWxldGVGaWxlLmN1c3RvbUhlYWRlcnMpO1xuICAgICAgICAgICAgdGhpcy5fZGVsZXRlRmlsZVBhcmFtc1N0b3JlID0gdGhpcy5fY3JlYXRlU3RvcmUodGhpcy5fb3B0aW9ucy5kZWxldGVGaWxlLnBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLl9lbmRwb2ludFN0b3JlID0gdGhpcy5fY3JlYXRlU3RvcmUodGhpcy5fb3B0aW9ucy5yZXF1ZXN0LmVuZHBvaW50KTtcbiAgICAgICAgICAgIHRoaXMuX2RlbGV0ZUZpbGVFbmRwb2ludFN0b3JlID0gdGhpcy5fY3JlYXRlU3RvcmUodGhpcy5fb3B0aW9ucy5kZWxldGVGaWxlLmVuZHBvaW50KTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIgPSB0aGlzLl9jcmVhdGVVcGxvYWRIYW5kbGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9kZWxldGVIYW5kbGVyID0gcXEuRGVsZXRlRmlsZUFqYXhSZXF1ZXN0ZXIgJiYgdGhpcy5fY3JlYXRlRGVsZXRlSGFuZGxlcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdEJ1dHRvbklkID0gdGhpcy5fY3JlYXRlVXBsb2FkQnV0dG9uKHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5fb3B0aW9ucy5idXR0b24sXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLl9vcHRpb25zLnRleHQuZmlsZUlucHV0VGl0bGVcbiAgICAgICAgICAgICAgICB9KS5nZXRCdXR0b25JZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVFeHRyYUJ1dHRvblNwZWNzKCk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVDYW1lcmFBY2Nlc3MoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnBhc3RlLnRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocXEuUGFzdGVTdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Bhc3RlSGFuZGxlciA9IHRoaXMuX2NyZWF0ZVBhc3RlSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiUGFzdGUgc3VwcG9ydCBtb2R1bGUgbm90IGZvdW5kXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy53YXJuQmVmb3JlVW5sb2FkICYmIHRoaXMuX3ByZXZlbnRMZWF2ZUluUHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlR2VuZXJhdG9yID0gcXEuSW1hZ2VHZW5lcmF0b3IgJiYgbmV3IHFxLkltYWdlR2VuZXJhdG9yKHFxLmJpbmQodGhpcy5sb2csIHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hTZXNzaW9uRGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5fc3VjY2VlZGVkU2luY2VMYXN0QWxsQ29tcGxldGUgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2ZhaWxlZFNpbmNlTGFzdEFsbENvbXBsZXRlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zY2FsZXIgPSBxcS5TY2FsZXIgJiYgbmV3IHFxLlNjYWxlcih0aGlzLl9vcHRpb25zLnNjYWxpbmcsIHFxLmJpbmQodGhpcy5sb2csIHRoaXMpKSB8fCB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1c3RvbU5ld0ZpbGVIYW5kbGVyID0gcXEuYmluZCh0aGlzLl9zY2FsZXIuaGFuZGxlTmV3RmlsZSwgdGhpcy5fc2NhbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxcS5Ub3RhbFByb2dyZXNzICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLnByb2dyZXNzQmFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxQcm9ncmVzcyA9IG5ldyBxcS5Ub3RhbFByb2dyZXNzKHFxLmJpbmQodGhpcy5fb25Ub3RhbFByb2dyZXNzLCB0aGlzKSwgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc2VsZi5fdXBsb2FkRGF0YS5yZXRyaWV2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS5zaXplIHx8IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SXRlbUxpbWl0ID0gdGhpcy5fb3B0aW9ucy52YWxpZGF0aW9uLml0ZW1MaW1pdDtcbiAgICAgICAgICAgIHRoaXMuX2N1c3RvbVJlc3VtZURhdGFTdG9yZSA9IHRoaXMuX2NyZWF0ZVN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHFxLkZpbmVVcGxvYWRlckJhc2ljLnByb3RvdHlwZSA9IHFxLmJhc2VQdWJsaWNBcGk7XG4gICAgICAgIHFxLmV4dGVuZChxcS5GaW5lVXBsb2FkZXJCYXNpYy5wcm90b3R5cGUsIHFxLmJhc2VQcml2YXRlQXBpKTtcbiAgICB9KSgpO1xuICAgIHFxLkFqYXhSZXF1ZXN0ZXIgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgbG9nLCBzaG91bGRQYXJhbXNCZUluUXVlcnlTdHJpbmcsIHF1ZXVlID0gW10sIHJlcXVlc3REYXRhID0ge30sIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhY2NlcHRIZWFkZXI6IG51bGwsXG4gICAgICAgICAgICB2YWxpZE1ldGhvZHM6IFsgXCJQQVRDSFwiLCBcIlBPU1RcIiwgXCJQVVRcIiBdLFxuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnM6IDMsXG4gICAgICAgICAgICBjdXN0b21IZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIGVuZHBvaW50U3RvcmU6IHt9LFxuICAgICAgICAgICAgcGFyYW1zU3RvcmU6IHt9LFxuICAgICAgICAgICAgbWFuZGF0ZWRQYXJhbXM6IHt9LFxuICAgICAgICAgICAgYWxsb3dYUmVxdWVzdGVkV2l0aEFuZENhY2hlQ29udHJvbDogdHJ1ZSxcbiAgICAgICAgICAgIHN1Y2Nlc3NmdWxSZXNwb25zZUNvZGVzOiB7XG4gICAgICAgICAgICAgICAgREVMRVRFOiBbIDIwMCwgMjAyLCAyMDQgXSxcbiAgICAgICAgICAgICAgICBQQVRDSDogWyAyMDAsIDIwMSwgMjAyLCAyMDMsIDIwNCBdLFxuICAgICAgICAgICAgICAgIFBPU1Q6IFsgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQgXSxcbiAgICAgICAgICAgICAgICBQVVQ6IFsgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQgXSxcbiAgICAgICAgICAgICAgICBHRVQ6IFsgMjAwIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb3JzOiB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNlbmRDcmVkZW50aWFsczogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKHN0ciwgbGV2ZWwpIHt9LFxuICAgICAgICAgICAgb25TZW5kOiBmdW5jdGlvbihpZCkge30sXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbihpZCwgeGhyT3JYZHIsIGlzRXJyb3IpIHt9LFxuICAgICAgICAgICAgb25Qcm9ncmVzczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBxcS5leHRlbmQob3B0aW9ucywgbyk7XG4gICAgICAgIGxvZyA9IG9wdGlvbnMubG9nO1xuICAgICAgICBpZiAocXEuaW5kZXhPZihvcHRpb25zLnZhbGlkTWV0aG9kcywgb3B0aW9ucy5tZXRob2QpIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ1wiICsgb3B0aW9ucy5tZXRob2QgKyBcIicgaXMgbm90IGEgc3VwcG9ydGVkIG1ldGhvZCBmb3IgdGhpcyB0eXBlIG9mIHJlcXVlc3QhXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzU2ltcGxlTWV0aG9kKCkge1xuICAgICAgICAgICAgcmV0dXJuIHFxLmluZGV4T2YoWyBcIkdFVFwiLCBcIlBPU1RcIiwgXCJIRUFEXCIgXSwgb3B0aW9ucy5tZXRob2QpID49IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29udGFpbnNOb25TaW1wbGVIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluc05vblNpbXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgcXEuZWFjaChjb250YWluc05vblNpbXBsZSwgZnVuY3Rpb24oaWR4LCBoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAocXEuaW5kZXhPZihbIFwiQWNjZXB0XCIsIFwiQWNjZXB0LUxhbmd1YWdlXCIsIFwiQ29udGVudC1MYW5ndWFnZVwiLCBcIkNvbnRlbnQtVHlwZVwiIF0sIGhlYWRlcikgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zTm9uU2ltcGxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zTm9uU2ltcGxlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzWGRyKHhocikge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29ycy5leHBlY3RlZCAmJiB4aHIud2l0aENyZWRlbnRpYWxzID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29yc0FqYXhUcmFuc3BvcnQoKSB7XG4gICAgICAgICAgICB2YXIgeGhyT3JYZHI7XG4gICAgICAgICAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0IHx8IHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgeGhyT3JYZHIgPSBxcS5jcmVhdGVYaHJJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmICh4aHJPclhkci53aXRoQ3JlZGVudGlhbHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB4aHJPclhkciA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICB4aHJPclhkci5vbmxvYWQgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICAgICAgICAgICAgICB4aHJPclhkci5vbmVycm9yID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgICAgICAgICAgICAgeGhyT3JYZHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgICAgICAgICAgICAgeGhyT3JYZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHhock9yWGRyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFhock9yWGRyKGlkLCBzdXBwbGllZFhocikge1xuICAgICAgICAgICAgdmFyIHhock9yWGRyID0gcmVxdWVzdERhdGFbaWRdICYmIHJlcXVlc3REYXRhW2lkXS54aHI7XG4gICAgICAgICAgICBpZiAoIXhock9yWGRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1cHBsaWVkWGhyKSB7XG4gICAgICAgICAgICAgICAgICAgIHhock9yWGRyID0gc3VwcGxpZWRYaHI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29ycy5leHBlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyT3JYZHIgPSBnZXRDb3JzQWpheFRyYW5zcG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyT3JYZHIgPSBxcS5jcmVhdGVYaHJJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhW2lkXS54aHIgPSB4aHJPclhkcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4aHJPclhkcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZXF1ZXVlKGlkKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHFxLmluZGV4T2YocXVldWUsIGlkKSwgbWF4ID0gb3B0aW9ucy5tYXhDb25uZWN0aW9ucywgbmV4dElkO1xuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REYXRhW2lkXTtcbiAgICAgICAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPj0gbWF4ICYmIGkgPCBtYXgpIHtcbiAgICAgICAgICAgICAgICBuZXh0SWQgPSBxdWV1ZVttYXggLSAxXTtcbiAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdChuZXh0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uQ29tcGxldGUoaWQsIHhkckVycm9yKSB7XG4gICAgICAgICAgICB2YXIgeGhyID0gZ2V0WGhyT3JYZHIoaWQpLCBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCwgaXNFcnJvciA9IHhkckVycm9yID09PSB0cnVlO1xuICAgICAgICAgICAgZGVxdWV1ZShpZCk7XG4gICAgICAgICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZyhtZXRob2QgKyBcIiByZXF1ZXN0IGZvciBcIiArIGlkICsgXCIgaGFzIGZhaWxlZFwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNYZHIoeGhyKSAmJiAhaXNSZXNwb25zZVN1Y2Nlc3NmdWwoeGhyLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICBpc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsb2cobWV0aG9kICsgXCIgcmVxdWVzdCBmb3IgXCIgKyBpZCArIFwiIGhhcyBmYWlsZWQgLSByZXNwb25zZSBjb2RlIFwiICsgeGhyLnN0YXR1cywgXCJlcnJvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMub25Db21wbGV0ZShpZCwgeGhyLCBpc0Vycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRQYXJhbXMoaWQpIHtcbiAgICAgICAgICAgIHZhciBvbkRlbWFuZFBhcmFtcyA9IHJlcXVlc3REYXRhW2lkXS5hZGRpdGlvbmFsUGFyYW1zLCBtYW5kYXRlZFBhcmFtcyA9IG9wdGlvbnMubWFuZGF0ZWRQYXJhbXMsIHBhcmFtcztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcmFtc1N0b3JlLmdldCkge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IG9wdGlvbnMucGFyYW1zU3RvcmUuZ2V0KGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkRlbWFuZFBhcmFtcykge1xuICAgICAgICAgICAgICAgIHFxLmVhY2gob25EZW1hbmRQYXJhbXMsIGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tuYW1lXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYW5kYXRlZFBhcmFtcykge1xuICAgICAgICAgICAgICAgIHFxLmVhY2gobWFuZGF0ZWRQYXJhbXMsIGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tuYW1lXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2VuZFJlcXVlc3QoaWQsIG9wdFhocikge1xuICAgICAgICAgICAgdmFyIHhociA9IGdldFhock9yWGRyKGlkLCBvcHRYaHIpLCBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCwgcGFyYW1zID0gZ2V0UGFyYW1zKGlkKSwgcGF5bG9hZCA9IHJlcXVlc3REYXRhW2lkXS5wYXlsb2FkLCB1cmw7XG4gICAgICAgICAgICBvcHRpb25zLm9uU2VuZChpZCk7XG4gICAgICAgICAgICB1cmwgPSBjcmVhdGVVcmwoaWQsIHBhcmFtcywgcmVxdWVzdERhdGFbaWRdLmFkZGl0aW9uYWxRdWVyeVBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoaXNYZHIoeGhyKSkge1xuICAgICAgICAgICAgICAgIHhoci5vbmxvYWQgPSBnZXRYZHJMb2FkSGFuZGxlcihpZCk7XG4gICAgICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBnZXRYZHJFcnJvckhhbmRsZXIoaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZ2V0WGhyUmVhZHlTdGF0ZUNoYW5nZUhhbmRsZXIoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVnaXN0ZXJGb3JVcGxvYWRQcm9ncmVzcyhpZCk7XG4gICAgICAgICAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb3JzLmV4cGVjdGVkICYmIG9wdGlvbnMuY29ycy5zZW5kQ3JlZGVudGlhbHMgJiYgIWlzWGRyKHhocikpIHtcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhlYWRlcnMoaWQpO1xuICAgICAgICAgICAgbG9nKFwiU2VuZGluZyBcIiArIG1ldGhvZCArIFwiIHJlcXVlc3QgZm9yIFwiICsgaWQpO1xuICAgICAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICB4aHIuc2VuZChwYXlsb2FkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkUGFyYW1zQmVJblF1ZXJ5U3RyaW5nIHx8ICFwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMgJiYgb3B0aW9ucy5jb250ZW50VHlwZSAmJiBvcHRpb25zLmNvbnRlbnRUeXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgeGhyLnNlbmQocXEub2JqMnVybChwYXJhbXMsIFwiXCIpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zICYmIG9wdGlvbnMuY29udGVudFR5cGUgJiYgb3B0aW9ucy5jb250ZW50VHlwZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpID49IDApIHtcbiAgICAgICAgICAgICAgICB4aHIuc2VuZChKU09OLnN0cmluZ2lmeShwYXJhbXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeGhyLnNlbmQocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4aHI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlVXJsKGlkLCBwYXJhbXMsIGFkZGl0aW9uYWxRdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGVuZHBvaW50ID0gb3B0aW9ucy5lbmRwb2ludFN0b3JlLmdldChpZCksIGFkZFRvUGF0aCA9IHJlcXVlc3REYXRhW2lkXS5hZGRUb1BhdGg7XG4gICAgICAgICAgICBpZiAoYWRkVG9QYXRoICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVuZHBvaW50ICs9IFwiL1wiICsgYWRkVG9QYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZFBhcmFtc0JlSW5RdWVyeVN0cmluZyAmJiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBlbmRwb2ludCA9IHFxLm9iajJ1cmwocGFyYW1zLCBlbmRwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWRkaXRpb25hbFF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnQgPSBxcS5vYmoydXJsKGFkZGl0aW9uYWxRdWVyeVBhcmFtcywgZW5kcG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVuZHBvaW50O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFhoclJlYWR5U3RhdGVDaGFuZ2VIYW5kbGVyKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldFhock9yWGRyKGlkKS5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGUoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJGb3JVcGxvYWRQcm9ncmVzcyhpZCkge1xuICAgICAgICAgICAgdmFyIG9uUHJvZ3Jlc3MgPSBvcHRpb25zLm9uUHJvZ3Jlc3M7XG4gICAgICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGdldFhock9yWGRyKGlkKS51cGxvYWQub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhpZCwgZS5sb2FkZWQsIGUudG90YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRYZHJMb2FkSGFuZGxlcihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG9uQ29tcGxldGUoaWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRYZHJFcnJvckhhbmRsZXIoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKGlkLCB0cnVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0SGVhZGVycyhpZCkge1xuICAgICAgICAgICAgdmFyIHhociA9IGdldFhock9yWGRyKGlkKSwgY3VzdG9tSGVhZGVycyA9IG9wdGlvbnMuY3VzdG9tSGVhZGVycywgb25EZW1hbmRIZWFkZXJzID0gcmVxdWVzdERhdGFbaWRdLmFkZGl0aW9uYWxIZWFkZXJzIHx8IHt9LCBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCwgYWxsSGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgaWYgKCFpc1hkcih4aHIpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hY2NlcHRIZWFkZXIgJiYgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgb3B0aW9ucy5hY2NlcHRIZWFkZXIpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbG93WFJlcXVlc3RlZFdpdGhBbmRDYWNoZUNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNvcnMuZXhwZWN0ZWQgfHwgKCFpc1NpbXBsZU1ldGhvZCgpIHx8IGNvbnRhaW5zTm9uU2ltcGxlSGVhZGVycyhjdXN0b21IZWFkZXJzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1SZXF1ZXN0ZWQtV2l0aFwiLCBcIlhNTEh0dHBSZXF1ZXN0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDYWNoZS1Db250cm9sXCIsIFwibm8tY2FjaGVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudFR5cGUgJiYgKG1ldGhvZCA9PT0gXCJQT1NUXCIgfHwgbWV0aG9kID09PSBcIlBVVFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBvcHRpb25zLmNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXEuZXh0ZW5kKGFsbEhlYWRlcnMsIHFxLmlzRnVuY3Rpb24oY3VzdG9tSGVhZGVycykgPyBjdXN0b21IZWFkZXJzKGlkKSA6IGN1c3RvbUhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHFxLmV4dGVuZChhbGxIZWFkZXJzLCBvbkRlbWFuZEhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHFxLmVhY2goYWxsSGVhZGVycywgZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNSZXNwb25zZVN1Y2Nlc3NmdWwocmVzcG9uc2VDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcXEuaW5kZXhPZihvcHRpb25zLnN1Y2Nlc3NmdWxSZXNwb25zZUNvZGVzW29wdGlvbnMubWV0aG9kXSwgcmVzcG9uc2VDb2RlKSA+PSAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByZXBhcmVUb1NlbmQoaWQsIG9wdFhociwgYWRkVG9QYXRoLCBhZGRpdGlvbmFsUGFyYW1zLCBhZGRpdGlvbmFsUXVlcnlQYXJhbXMsIGFkZGl0aW9uYWxIZWFkZXJzLCBwYXlsb2FkKSB7XG4gICAgICAgICAgICByZXF1ZXN0RGF0YVtpZF0gPSB7XG4gICAgICAgICAgICAgICAgYWRkVG9QYXRoOiBhZGRUb1BhdGgsXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbFBhcmFtczogYWRkaXRpb25hbFBhcmFtcyxcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUXVlcnlQYXJhbXM6IGFkZGl0aW9uYWxRdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsSGVhZGVyczogYWRkaXRpb25hbEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBxdWV1ZS5wdXNoKGlkKTtcbiAgICAgICAgICAgIGlmIChsZW4gPD0gb3B0aW9ucy5tYXhDb25uZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZW5kUmVxdWVzdChpZCwgb3B0WGhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaG91bGRQYXJhbXNCZUluUXVlcnlTdHJpbmcgPSBvcHRpb25zLm1ldGhvZCA9PT0gXCJHRVRcIiB8fCBvcHRpb25zLm1ldGhvZCA9PT0gXCJERUxFVEVcIjtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIGluaXRUcmFuc3BvcnQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGgsIHBhcmFtcywgaGVhZGVycywgcGF5bG9hZCwgY2FjaGVCdXN0ZXIsIGFkZGl0aW9uYWxRdWVyeVBhcmFtcztcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB3aXRoUGF0aDogZnVuY3Rpb24oYXBwZW5kVG9QYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gYXBwZW5kVG9QYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdpdGhQYXJhbXM6IGZ1bmN0aW9uKGFkZGl0aW9uYWxQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IGFkZGl0aW9uYWxQYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd2l0aFF1ZXJ5UGFyYW1zOiBmdW5jdGlvbihfYWRkaXRpb25hbFF1ZXJ5UGFyYW1zXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFF1ZXJ5UGFyYW1zID0gX2FkZGl0aW9uYWxRdWVyeVBhcmFtc187XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd2l0aEhlYWRlcnM6IGZ1bmN0aW9uKGFkZGl0aW9uYWxIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzID0gYWRkaXRpb25hbEhlYWRlcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd2l0aFBheWxvYWQ6IGZ1bmN0aW9uKHRoZVBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSB0aGVQYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdpdGhDYWNoZUJ1c3RlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUJ1c3RlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24ob3B0WGhyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVCdXN0ZXIgJiYgcXEuaW5kZXhPZihbIFwiR0VUXCIsIFwiREVMRVRFXCIgXSwgb3B0aW9ucy5tZXRob2QpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucXF0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVwYXJlVG9TZW5kKGlkLCBvcHRYaHIsIHBhdGgsIHBhcmFtcywgYWRkaXRpb25hbFF1ZXJ5UGFyYW1zLCBoZWFkZXJzLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsZWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgZGVxdWV1ZShpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuVXBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBwcm94eSA9IHNwZWMucHJveHksIGZpbGVTdGF0ZSA9IHt9LCBvbkNhbmNlbCA9IHByb3h5Lm9uQ2FuY2VsLCBnZXROYW1lID0gcHJveHkuZ2V0TmFtZTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oaWQsIGZpbGVJdGVtKSB7XG4gICAgICAgICAgICAgICAgZmlsZVN0YXRlW2lkXSA9IGZpbGVJdGVtO1xuICAgICAgICAgICAgICAgIGZpbGVTdGF0ZVtpZF0udGVtcCA9IHt9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGNhbmNlbEZpbmFsaXphdGlvbkVmZm9ydCA9IG5ldyBxcS5Qcm9taXNlKCksIG9uQ2FuY2VsUmV0VmFsID0gb25DYW5jZWwoaWQsIGdldE5hbWUoaWQpLCBjYW5jZWxGaW5hbGl6YXRpb25FZmZvcnQpO1xuICAgICAgICAgICAgICAgIG9uQ2FuY2VsUmV0VmFsLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmlzVmFsaWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlU3RhdGVbaWRdLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXhwdW5nZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRmluYWxpemF0aW9uRWZmb3J0LnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHB1bmdlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBmaWxlU3RhdGVbaWRdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFRoaXJkUGFydHlGaWxlSWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVTdGF0ZVtpZF0ua2V5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVTdGF0ZVtpZF0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZmlsZVN0YXRlID0ge307XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldEZpbGVTdGF0ZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZVN0YXRlW2lkXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2V0VGhpcmRQYXJ0eUZpbGVJZDogZnVuY3Rpb24oaWQsIHRoaXJkUGFydHlGaWxlSWQpIHtcbiAgICAgICAgICAgICAgICBmaWxlU3RhdGVbaWRdLmtleSA9IHRoaXJkUGFydHlGaWxlSWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3dhc0NhbmNlbGVkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWZpbGVTdGF0ZVtpZF0uY2FuY2VsZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuVXBsb2FkSGFuZGxlckNvbnRyb2xsZXIgPSBmdW5jdGlvbihvLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gdGhpcywgY2h1bmtpbmdQb3NzaWJsZSA9IGZhbHNlLCBjb25jdXJyZW50Q2h1bmtpbmdQb3NzaWJsZSA9IGZhbHNlLCBjaHVua2luZywgcHJldmVudFJldHJ5UmVzcG9uc2UsIGxvZywgaGFuZGxlciwgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcmFtc1N0b3JlOiB7fSxcbiAgICAgICAgICAgIG1heENvbm5lY3Rpb25zOiAzLFxuICAgICAgICAgICAgY2h1bmtpbmc6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtdWx0aXBsZToge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKHN0ciwgbGV2ZWwpIHt9LFxuICAgICAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24oaWQsIGZpbGVOYW1lLCBsb2FkZWQsIHRvdGFsKSB7fSxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKGlkLCBmaWxlTmFtZSwgcmVzcG9uc2UsIHhocikge30sXG4gICAgICAgICAgICBvbkNhbmNlbDogZnVuY3Rpb24oaWQsIGZpbGVOYW1lKSB7fSxcbiAgICAgICAgICAgIG9uVXBsb2FkUHJlcDogZnVuY3Rpb24oaWQpIHt9LFxuICAgICAgICAgICAgb25VcGxvYWQ6IGZ1bmN0aW9uKGlkLCBmaWxlTmFtZSkge30sXG4gICAgICAgICAgICBvblVwbG9hZENodW5rOiBmdW5jdGlvbihpZCwgZmlsZU5hbWUsIGNodW5rRGF0YSkge30sXG4gICAgICAgICAgICBvblVwbG9hZENodW5rU3VjY2VzczogZnVuY3Rpb24oaWQsIGNodW5rRGF0YSwgcmVzcG9uc2UsIHhocikge30sXG4gICAgICAgICAgICBvbkF1dG9SZXRyeTogZnVuY3Rpb24oaWQsIGZpbGVOYW1lLCByZXNwb25zZSwgeGhyKSB7fSxcbiAgICAgICAgICAgIG9uUmVzdW1lOiBmdW5jdGlvbihpZCwgZmlsZU5hbWUsIGNodW5rRGF0YSwgY3VzdG9tUmVzdW1lRGF0YSkge30sXG4gICAgICAgICAgICBvblV1aWRDaGFuZ2VkOiBmdW5jdGlvbihpZCwgbmV3VXVpZCkge30sXG4gICAgICAgICAgICBnZXROYW1lOiBmdW5jdGlvbihpZCkge30sXG4gICAgICAgICAgICBzZXRTaXplOiBmdW5jdGlvbihpZCwgbmV3U2l6ZSkge30sXG4gICAgICAgICAgICBpc1F1ZXVlZDogZnVuY3Rpb24oaWQpIHt9LFxuICAgICAgICAgICAgZ2V0SWRzSW5Qcm94eUdyb3VwOiBmdW5jdGlvbihpZCkge30sXG4gICAgICAgICAgICBnZXRJZHNJbkJhdGNoOiBmdW5jdGlvbihpZCkge30sXG4gICAgICAgICAgICBpc0luUHJvZ3Jlc3M6IGZ1bmN0aW9uKGlkKSB7fVxuICAgICAgICB9LCBjaHVua2VkID0ge1xuICAgICAgICAgICAgZG9uZTogZnVuY3Rpb24oaWQsIGNodW5rSWR4LCByZXNwb25zZSwgeGhyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNodW5rRGF0YSA9IGhhbmRsZXIuX2dldENodW5rRGF0YShpZCwgY2h1bmtJZHgpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuYXR0ZW1wdGluZ1Jlc3VtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLnRlbXAuY2h1bmtQcm9ncmVzc1tjaHVua0lkeF07XG4gICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5sb2FkZWQgKz0gY2h1bmtEYXRhLnNpemU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblVwbG9hZENodW5rU3VjY2VzcyhpZCwgaGFuZGxlci5fZ2V0Q2h1bmtEYXRhRm9yQ2FsbGJhY2soY2h1bmtEYXRhKSwgcmVzcG9uc2UsIHhocik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBvcHRpb25zLmdldFNpemUoaWQpLCBuYW1lID0gb3B0aW9ucy5nZXROYW1lKGlkKTtcbiAgICAgICAgICAgICAgICBsb2coXCJBbGwgY2h1bmtzIGhhdmUgYmVlbiB1cGxvYWRlZCBmb3IgXCIgKyBpZCArIFwiIC0gZmluYWxpemluZy4uLi5cIik7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5maW5hbGl6ZUNodW5rcyhpZCkudGhlbihmdW5jdGlvbihyZXNwb25zZSwgeGhyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIkZpbmFsaXplIHN1Y2Nlc3NmdWwgZm9yIFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFpemVkUmVzcG9uc2UgPSB1cGxvYWQubm9ybWFsaXplUmVzcG9uc2UocmVzcG9uc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uUHJvZ3Jlc3MoaWQsIG5hbWUsIHNpemUsIHNpemUpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9tYXliZURlbGV0ZVBlcnNpc3RlZENodW5rRGF0YShpZCk7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZC5jbGVhbnVwKGlkLCBub3JtYWl6ZWRSZXNwb25zZSwgeGhyKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihyZXNwb25zZSwgeGhyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkUmVzcG9uc2UgPSB1cGxvYWQubm9ybWFsaXplUmVzcG9uc2UocmVzcG9uc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiUHJvYmxlbSBmaW5hbGl6aW5nIGNodW5rcyBmb3IgZmlsZSBJRCBcIiArIGlkICsgXCIgLSBcIiArIG5vcm1hbGl6ZWRSZXNwb25zZS5lcnJvciwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRSZXNwb25zZS5yZXNldCB8fCB4aHIgJiYgb3B0aW9ucy5jaHVua2luZy5zdWNjZXNzLnJlc2V0T25TdGF0dXMuaW5kZXhPZih4aHIuc3RhdHVzKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua2VkLnJlc2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMub25BdXRvUmV0cnkoaWQsIG5hbWUsIG5vcm1hbGl6ZWRSZXNwb25zZSwgeGhyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkLmNsZWFudXAoaWQsIG5vcm1hbGl6ZWRSZXNwb25zZSwgeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZUZhaWx1cmU6IGZ1bmN0aW9uKGNodW5rSWR4LCBpZCwgcmVzcG9uc2UsIHhocikge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gb3B0aW9ucy5nZXROYW1lKGlkKTtcbiAgICAgICAgICAgICAgICBsb2coXCJDaHVua2VkIHVwbG9hZCByZXF1ZXN0IGZhaWxlZCBmb3IgXCIgKyBpZCArIFwiLCBjaHVuayBcIiArIGNodW5rSWR4KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmNsZWFyQ2FjaGVkQ2h1bmsoaWQsIGNodW5rSWR4KTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VUb1JlcG9ydCA9IHVwbG9hZC5ub3JtYWxpemVSZXNwb25zZShyZXNwb25zZSwgZmFsc2UpLCBpblByb2dyZXNzSWR4O1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVRvUmVwb3J0LnJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rZWQucmVzZXQoaWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpblByb2dyZXNzQ2h1bmtzQXJyYXkgPSBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmNodW5raW5nLmluUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvZ3Jlc3NJZHggPSBpblByb2dyZXNzQ2h1bmtzQXJyYXkgPyBxcS5pbmRleE9mKGluUHJvZ3Jlc3NDaHVua3NBcnJheSwgY2h1bmtJZHgpIDogLTE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpblByb2dyZXNzSWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuY2h1bmtpbmcuaW5Qcm9ncmVzcy5zcGxpY2UoaW5Qcm9ncmVzc0lkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmNodW5raW5nLnJlbWFpbmluZy51bnNoaWZ0KGNodW5rSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkudGVtcC5pZ25vcmVGYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25jdXJyZW50Q2h1bmtpbmdQb3NzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS50ZW1wLmlnbm9yZUZhaWx1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKHFxLmZvcm1hdChcIkdvaW5nIHRvIGF0dGVtcHQgdG8gYWJvcnQgdGhlc2UgY2h1bmtzOiB7fS4gVGhlc2UgYXJlIGN1cnJlbnRseSBpbi1wcm9ncmVzczoge30uXCIsIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKGhhbmRsZXIuX2dldFhocnMoaWQpKSksIEpTT04uc3RyaW5naWZ5KGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuY2h1bmtpbmcuaW5Qcm9ncmVzcykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFxLmVhY2goaGFuZGxlci5fZ2V0WGhycyhpZCksIGZ1bmN0aW9uKGNraWQsIGNrWGhyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKHFxLmZvcm1hdChcIkF0dGVtcHRpbmcgdG8gYWJvcnQgZmlsZSB7fS57fS4gWEhSIHJlYWR5U3RhdGUge30uIFwiLCBpZCwgY2tpZCwgY2tYaHIucmVhZHlTdGF0ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNrWGhyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2tYaHIuX2NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIubW92ZUluUHJvZ3Jlc3NUb1JlbWFpbmluZyhpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5mcmVlKGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMub25BdXRvUmV0cnkoaWQsIG5hbWUsIHJlc3BvbnNlVG9SZXBvcnQsIHhocikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZC5jbGVhbnVwKGlkLCByZXNwb25zZVRvUmVwb3J0LCB4aHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc01vcmVQYXJ0czogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmNodW5raW5nLnJlbWFpbmluZy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dFBhcnQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRJZHggPSBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmNodW5raW5nLnJlbWFpbmluZy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0SWR4ID49IGhhbmRsZXIuX2dldFRvdGFsQ2h1bmtzKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0SWR4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRJZHg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiU2VydmVyIG9yIGNhbGxiYWNrIGhhcyBvcmRlcmVkIGNodW5raW5nIGVmZm9ydCB0byBiZSByZXN0YXJ0ZWQgb24gbmV4dCBhdHRlbXB0IGZvciBpdGVtIElEIFwiICsgaWQsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5fbWF5YmVEZWxldGVQZXJzaXN0ZWRDaHVua0RhdGEoaWQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIucmVldmFsdWF0ZUNodW5raW5nKGlkKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmxvYWRlZCA9IDA7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5hdHRlbXB0aW5nUmVzdW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VuZE5leHQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBvcHRpb25zLmdldFNpemUoaWQpLCBuYW1lID0gb3B0aW9ucy5nZXROYW1lKGlkKSwgY2h1bmtJZHggPSBjaHVua2VkLm5leHRQYXJ0KGlkKSwgY2h1bmtEYXRhID0gaGFuZGxlci5fZ2V0Q2h1bmtEYXRhKGlkLCBjaHVua0lkeCksIGZpbGVTdGF0ZSA9IGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCksIHJlc3VtaW5nID0gZmlsZVN0YXRlLmF0dGVtcHRpbmdSZXN1bWUsIGluUHJvZ3Jlc3NDaHVua3MgPSBmaWxlU3RhdGUuY2h1bmtpbmcuaW5Qcm9ncmVzcyB8fCBbXTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZVN0YXRlLmxvYWRlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVTdGF0ZS5sb2FkZWQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdW1pbmcgJiYgb3B0aW9ucy5vblJlc3VtZShpZCwgbmFtZSwgY2h1bmtEYXRhLCBmaWxlU3RhdGUuY3VzdG9tUmVzdW1lRGF0YSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rZWQucmVzZXQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua0lkeCA9IGNodW5rZWQubmV4dFBhcnQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua0RhdGEgPSBoYW5kbGVyLl9nZXRDaHVua0RhdGEoaWQsIGNodW5rSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdW1pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rSWR4ID09IG51bGwgJiYgaW5Qcm9ncmVzc0NodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtlZC5maW5hbGl6ZShpZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9ncmVzc0NodW5rcy5wdXNoKGNodW5rSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5jaHVua2luZy5pblByb2dyZXNzID0gaW5Qcm9ncmVzc0NodW5rcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmN1cnJlbnRDaHVua2luZ1Bvc3NpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5vcGVuKGlkLCBjaHVua0lkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmN1cnJlbnRDaHVua2luZ1Bvc3NpYmxlICYmIGNvbm5lY3Rpb25NYW5hZ2VyLmF2YWlsYWJsZSgpICYmIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuY2h1bmtpbmcucmVtYWluaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtlZC5zZW5kTmV4dChpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rRGF0YS5ibG9iLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJDaHVuayB7fSBmb3IgZmlsZSB7fSB3aWxsIG5vdCBiZSB1cGxvYWRlZCwgemVybyBzaXplZCBjaHVuay5cIiwgY2h1bmtJZHgsIGlkKSwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rZWQuaGFuZGxlRmFpbHVyZShjaHVua0lkeCwgaWQsIFwiRmlsZSBpcyBubyBsb25nZXIgYXZhaWxhYmxlXCIsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBvblVwbG9hZENodW5rUHJvbWlzZSA9IG9wdGlvbnMub25VcGxvYWRDaHVuayhpZCwgbmFtZSwgaGFuZGxlci5fZ2V0Q2h1bmtEYXRhRm9yQ2FsbGJhY2soY2h1bmtEYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIG9uVXBsb2FkQ2h1bmtQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVxdWVzdE92ZXJyaWRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmlzSW5Qcm9ncmVzcyhpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiTm90IHNlbmRpbmcgY2h1bmtlZCB1cGxvYWQgcmVxdWVzdCBmb3IgaXRlbSB7fS57fSAtIG5vIGxvbmdlciBpbiBwcm9ncmVzcy5cIiwgaWQsIGNodW5rSWR4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJTZW5kaW5nIGNodW5rZWQgdXBsb2FkIHJlcXVlc3QgZm9yIGl0ZW0ge30ue30sIGJ5dGVzIHt9LXt9IG9mIHt9LlwiLCBpZCwgY2h1bmtJZHgsIGNodW5rRGF0YS5zdGFydCArIDEsIGNodW5rRGF0YS5lbmQsIHNpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBsb2FkQ2h1bmtEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua0lkeDogY2h1bmtJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzOiByZXF1ZXN0T3ZlcnJpZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bWluZzogcmVzdW1pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIudXBsb2FkQ2h1bmsodXBsb2FkQ2h1bmtEYXRhKS50aGVuKGZ1bmN0aW9uIHN1Y2Nlc3MocmVzcG9uc2UsIHhocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coXCJDaHVua2VkIHVwbG9hZCByZXF1ZXN0IHN1Y2NlZWRlZCBmb3IgXCIgKyBpZCArIFwiLCBjaHVuayBcIiArIGNodW5rSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5jbGVhckNhY2hlZENodW5rKGlkLCBjaHVua0lkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpblByb2dyZXNzQ2h1bmtzID0gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5jaHVua2luZy5pblByb2dyZXNzIHx8IFtdLCByZXNwb25zZVRvUmVwb3J0ID0gdXBsb2FkLm5vcm1hbGl6ZVJlc3BvbnNlKHJlc3BvbnNlLCB0cnVlKSwgaW5Qcm9ncmVzc0NodW5rSWR4ID0gcXEuaW5kZXhPZihpblByb2dyZXNzQ2h1bmtzLCBjaHVua0lkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJDaHVuayB7fSBmb3IgZmlsZSB7fSB1cGxvYWRlZCBzdWNjZXNzZnVsbHkuXCIsIGNodW5rSWR4LCBpZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua2VkLmRvbmUoaWQsIGNodW5rSWR4LCByZXNwb25zZVRvUmVwb3J0LCB4aHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5Qcm9ncmVzc0NodW5rSWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUHJvZ3Jlc3NDaHVua3Muc3BsaWNlKGluUHJvZ3Jlc3NDaHVua0lkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fbWF5YmVQZXJzaXN0Q2h1bmtlZFN0YXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaHVua2VkLmhhc01vcmVQYXJ0cyhpZCkgJiYgaW5Qcm9ncmVzc0NodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rZWQuZmluYWxpemUoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNodW5rZWQuaGFzTW9yZVBhcnRzKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtlZC5zZW5kTmV4dChpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiRmlsZSBJRCB7fSBoYXMgbm8gbW9yZSBjaHVua3MgdG8gc2VuZCBhbmQgdGhlc2UgY2h1bmsgaW5kZXhlcyBhcmUgc3RpbGwgbWFya2VkIGFzIGluLXByb2dyZXNzOiB7fVwiLCBpZCwgSlNPTi5zdHJpbmdpZnkoaW5Qcm9ncmVzc0NodW5rcykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIGZhaWx1cmUocmVzcG9uc2UsIHhocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua2VkLmhhbmRsZUZhaWx1cmUoY2h1bmtJZHgsIGlkLCByZXNwb25zZSwgeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5kb25lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNsZWFyWGhyKGlkLCBjaHVua0lkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua2VkLmhhbmRsZUZhaWx1cmUoY2h1bmtJZHgsIGlkLCBlcnJvciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgY29ubmVjdGlvbk1hbmFnZXIgPSB7XG4gICAgICAgICAgICBfb3BlbjogW10sXG4gICAgICAgICAgICBfb3BlbkNodW5rczoge30sXG4gICAgICAgICAgICBfd2FpdGluZzogW10sXG4gICAgICAgICAgICBhdmFpbGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXggPSBvcHRpb25zLm1heENvbm5lY3Rpb25zLCBvcGVuQ2h1bmtFbnRyaWVzQ291bnQgPSAwLCBvcGVuQ2h1bmtzQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHFxLmVhY2goY29ubmVjdGlvbk1hbmFnZXIuX29wZW5DaHVua3MsIGZ1bmN0aW9uKGZpbGVJZCwgb3BlbkNodW5rSW5kZXhlcykge1xuICAgICAgICAgICAgICAgICAgICBvcGVuQ2h1bmtFbnRyaWVzQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgb3BlbkNodW5rc0NvdW50ICs9IG9wZW5DaHVua0luZGV4ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXggLSAoY29ubmVjdGlvbk1hbmFnZXIuX29wZW4ubGVuZ3RoIC0gb3BlbkNodW5rRW50cmllc0NvdW50ICsgb3BlbkNodW5rc0NvdW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcmVlOiBmdW5jdGlvbihpZCwgZG9udEFsbG93TmV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBhbGxvd05leHQgPSAhZG9udEFsbG93TmV4dCwgd2FpdGluZ0luZGV4ID0gcXEuaW5kZXhPZihjb25uZWN0aW9uTWFuYWdlci5fd2FpdGluZywgaWQpLCBjb25uZWN0aW9uc0luZGV4ID0gcXEuaW5kZXhPZihjb25uZWN0aW9uTWFuYWdlci5fb3BlbiwgaWQpLCBuZXh0SWQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbm5lY3Rpb25NYW5hZ2VyLl9vcGVuQ2h1bmtzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAodXBsb2FkLmdldFByb3h5T3JCbG9iKGlkKSBpbnN0YW5jZW9mIHFxLkJsb2JQcm94eSkge1xuICAgICAgICAgICAgICAgICAgICBsb2coXCJHZW5lcmF0ZWQgYmxvYiB1cGxvYWQgaGFzIGVuZGVkIGZvciBcIiArIGlkICsgXCIsIGRpc3Bvc2luZyBnZW5lcmF0ZWQgYmxvYi5cIik7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmZpbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5fd2FpdGluZy5zcGxpY2Uod2FpdGluZ0luZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFsbG93TmV4dCAmJiBjb25uZWN0aW9uc0luZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuX29wZW4uc3BsaWNlKGNvbm5lY3Rpb25zSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0SWQgPSBjb25uZWN0aW9uTWFuYWdlci5fd2FpdGluZy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dElkID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLl9vcGVuLnB1c2gobmV4dElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZC5zdGFydChuZXh0SWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFdhaXRpbmdPckNvbm5lY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdhaXRpbmdPckNvbm5lY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgIHFxLmVhY2goY29ubmVjdGlvbk1hbmFnZXIuX29wZW5DaHVua3MsIGZ1bmN0aW9uKGZpbGVJZCwgY2h1bmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVua3MgJiYgY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FpdGluZ09yQ29ubmVjdGVkLnB1c2gocGFyc2VJbnQoZmlsZUlkKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKGNvbm5lY3Rpb25NYW5hZ2VyLl9vcGVuLCBmdW5jdGlvbihpZHgsIGZpbGVJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb25NYW5hZ2VyLl9vcGVuQ2h1bmtzW2ZpbGVJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRpbmdPckNvbm5lY3RlZC5wdXNoKHBhcnNlSW50KGZpbGVJZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgd2FpdGluZ09yQ29ubmVjdGVkID0gd2FpdGluZ09yQ29ubmVjdGVkLmNvbmNhdChjb25uZWN0aW9uTWFuYWdlci5fd2FpdGluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhaXRpbmdPckNvbm5lY3RlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1VzaW5nQ29ubmVjdGlvbjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEuaW5kZXhPZihjb25uZWN0aW9uTWFuYWdlci5fb3BlbiwgaWQpID49IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24oaWQsIGNodW5rSWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rSWR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuX3dhaXRpbmcucHVzaChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uTWFuYWdlci5hdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtJZHggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuX3dhaXRpbmcucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5fb3Blbi5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlbkNodW5rc0VudHJ5ID0gY29ubmVjdGlvbk1hbmFnZXIuX29wZW5DaHVua3NbaWRdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5DaHVua3NFbnRyeS5wdXNoKGNodW5rSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5fb3BlbkNodW5rc1tpZF0gPSBvcGVuQ2h1bmtzRW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLl93YWl0aW5nID0gW107XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuX29wZW4gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2ltcGxlID0ge1xuICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24oaWQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZVN0YXRlID0gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGVTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2coXCJJZ25vcmluZyBzZW5kIHJlcXVlc3QgYXMgdGhpcyB1cGxvYWQgbWF5IGhhdmUgYmVlbiBjYW5jZWxsZWQsIEZpbGUgSUQgXCIgKyBpZCwgXCJ3YXJuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbGVTdGF0ZS5sb2FkZWQgPSAwO1xuICAgICAgICAgICAgICAgIGxvZyhcIlNlbmRpbmcgc2ltcGxlIHVwbG9hZCByZXF1ZXN0IGZvciBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLnVwbG9hZEZpbGUoaWQpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UsIG9wdFhocikge1xuICAgICAgICAgICAgICAgICAgICBsb2coXCJTaW1wbGUgdXBsb2FkIHJlcXVlc3Qgc3VjY2VlZGVkIGZvciBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlVG9SZXBvcnQgPSB1cGxvYWQubm9ybWFsaXplUmVzcG9uc2UocmVzcG9uc2UsIHRydWUpLCBzaXplID0gb3B0aW9ucy5nZXRTaXplKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vblByb2dyZXNzKGlkLCBuYW1lLCBzaXplLCBzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkLm1heWJlTmV3VXVpZChpZCwgcmVzcG9uc2VUb1JlcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZC5jbGVhbnVwKGlkLCByZXNwb25zZVRvUmVwb3J0LCBvcHRYaHIpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKHJlc3BvbnNlLCBvcHRYaHIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiU2ltcGxlIHVwbG9hZCByZXF1ZXN0IGZhaWxlZCBmb3IgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZVRvUmVwb3J0ID0gdXBsb2FkLm5vcm1hbGl6ZVJlc3BvbnNlKHJlc3BvbnNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5vbkF1dG9SZXRyeShpZCwgbmFtZSwgcmVzcG9uc2VUb1JlcG9ydCwgb3B0WGhyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkLmNsZWFudXAoaWQsIHJlc3BvbnNlVG9SZXBvcnQsIG9wdFhocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdXBsb2FkID0ge1xuICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGxvZyhcIkNhbmNlbGxpbmcgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXNTdG9yZS5yZW1vdmUoaWQpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLmZyZWUoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsZWFudXA6IGZ1bmN0aW9uKGlkLCByZXNwb25zZSwgb3B0WGhyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLmdldE5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25Db21wbGV0ZShpZCwgbmFtZSwgcmVzcG9uc2UsIG9wdFhocik7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fY2xlYXJYaHJzICYmIGhhbmRsZXIuX2NsZWFyWGhycyhpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLmZyZWUoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFByb3h5T3JCbG9iOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmdldFByb3h5ICYmIGhhbmRsZXIuZ2V0UHJveHkoaWQpIHx8IGhhbmRsZXIuZ2V0RmlsZSAmJiBoYW5kbGVyLmdldEZpbGUoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluaXRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFuZGxlclR5cGUgPSBuYW1lc3BhY2UgPyBxcVtuYW1lc3BhY2VdIDogcXEudHJhZGl0aW9uYWwsIGhhbmRsZXJNb2R1bGVTdWJ0eXBlID0gcXEuc3VwcG9ydGVkRmVhdHVyZXMuYWpheFVwbG9hZGluZyA/IFwiWGhyXCIgOiBcIkZvcm1cIjtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gbmV3IGhhbmRsZXJUeXBlW2hhbmRsZXJNb2R1bGVTdWJ0eXBlICsgXCJVcGxvYWRIYW5kbGVyXCJdKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q3VzdG9tUmVzdW1lRGF0YTogb3B0aW9ucy5nZXRDdXN0b21SZXN1bWVEYXRhLFxuICAgICAgICAgICAgICAgICAgICBnZXREYXRhQnlVdWlkOiBvcHRpb25zLmdldERhdGFCeVV1aWQsXG4gICAgICAgICAgICAgICAgICAgIGdldE5hbWU6IG9wdGlvbnMuZ2V0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0U2l6ZTogb3B0aW9ucy5nZXRTaXplLFxuICAgICAgICAgICAgICAgICAgICBnZXRVdWlkOiBvcHRpb25zLmdldFV1aWQsXG4gICAgICAgICAgICAgICAgICAgIGxvZzogbG9nLFxuICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbDogb3B0aW9ucy5vbkNhbmNlbCxcbiAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzczogb3B0aW9ucy5vblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICBvblV1aWRDaGFuZ2VkOiBvcHRpb25zLm9uVXVpZENoYW5nZWQsXG4gICAgICAgICAgICAgICAgICAgIG9uRmluYWxpemluZzogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2V0U3RhdHVzKGlkLCBxcS5zdGF0dXMuVVBMT0FEX0ZJTkFMSVpJTkcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuX3JlbW92ZUV4cGlyZWRDaHVua2luZ1JlY29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fcmVtb3ZlRXhwaXJlZENodW5raW5nUmVjb3JkcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0RlZmVycmVkRWxpZ2libGVGb3JVcGxvYWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuaXNRdWV1ZWQoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heWJlRGVmZXI6IGZ1bmN0aW9uKGlkLCBibG9iKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2IgJiYgIWhhbmRsZXIuZ2V0RmlsZShpZCkgJiYgYmxvYiBpbnN0YW5jZW9mIHFxLkJsb2JQcm94eSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uVXBsb2FkUHJlcChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIkF0dGVtcHRpbmcgdG8gZ2VuZXJhdGUgYSBibG9iIG9uLWRlbWFuZCBmb3IgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgICAgIGJsb2IuY3JlYXRlKCkudGhlbihmdW5jdGlvbihnZW5lcmF0ZWRCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coXCJHZW5lcmF0ZWQgYW4gb24tZGVtYW5kIGJsb2IgZm9yIFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci51cGRhdGVCbG9iKGlkLCBnZW5lcmF0ZWRCbG9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2V0U2l6ZShpZCwgZ2VuZXJhdGVkQmxvYi5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIucmVldmFsdWF0ZUNodW5raW5nKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZC5tYXliZVNlbmREZWZlcnJlZEZpbGVzKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JSZXNwb25zZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yUmVzcG9uc2UuZXJyb3IgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiRmFpbGVkIHRvIGdlbmVyYXRlIGJsb2IgZm9yIElEIHt9LiAgRXJyb3IgbWVzc2FnZToge30uXCIsIGlkLCBlcnJvck1lc3NhZ2UpLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlKGlkLCBvcHRpb25zLmdldE5hbWUoaWQpLCBxcS5leHRlbmQoZXJyb3JSZXNwb25zZSwgcHJldmVudFJldHJ5UmVzcG9uc2UpLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZC5tYXliZVNlbmREZWZlcnJlZEZpbGVzKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLmZyZWUoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBsb2FkLm1heWJlU2VuZERlZmVycmVkRmlsZXMoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF5YmVTZW5kRGVmZXJyZWRGaWxlczogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWRzSW5Hcm91cCA9IG9wdGlvbnMuZ2V0SWRzSW5Qcm94eUdyb3VwKGlkKSwgdXBsb2FkZWRUaGlzSWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaWRzSW5Hcm91cCAmJiBpZHNJbkdyb3VwLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsb2coXCJNYXliZSByZWFkeSB0byB1cGxvYWQgcHJveHkgZ3JvdXAgZmlsZSBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChpZHNJbkdyb3VwLCBmdW5jdGlvbihpZHgsIGlkSW5Hcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwbG9hZC5pc0RlZmVycmVkRWxpZ2libGVGb3JVcGxvYWQoaWRJbkdyb3VwKSAmJiAhIWhhbmRsZXIuZ2V0RmlsZShpZEluR3JvdXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkZWRUaGlzSWQgPSBpZEluR3JvdXAgPT09IGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZC5ub3coaWRJbkdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodXBsb2FkLmlzRGVmZXJyZWRFbGlnaWJsZUZvclVwbG9hZChpZEluR3JvdXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZFRoaXNJZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZC5ub3coaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdXBsb2FkZWRUaGlzSWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWF5YmVOZXdVdWlkOiBmdW5jdGlvbihpZCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UubmV3VXVpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25VdWlkQ2hhbmdlZChpZCwgcmVzcG9uc2UubmV3VXVpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZVJlc3BvbnNlOiBmdW5jdGlvbihvcmlnaW5hbFJlc3BvbnNlLCBzdWNjZXNzZnVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gb3JpZ2luYWxSZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAoIXFxLmlzT2JqZWN0KG9yaWdpbmFsUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0ge307XG4gICAgICAgICAgICAgICAgICAgIGlmIChxcS5pc1N0cmluZyhvcmlnaW5hbFJlc3BvbnNlKSAmJiAhc3VjY2Vzc2Z1bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZXJyb3IgPSBvcmlnaW5hbFJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnN1Y2Nlc3MgPSBzdWNjZXNzZnVsO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub3c6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLmdldE5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIGlmICghY29udHJvbGxlci5pc1ZhbGlkKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcXEuRXJyb3IoaWQgKyBcIiBpcyBub3QgYSB2YWxpZCBmaWxlIElEIHRvIHVwbG9hZCFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25VcGxvYWQoaWQsIG5hbWUpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLnBhdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNldFN0YXR1cyhpZCwgcXEuc3RhdHVzLlBBVVNFRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLnBhdXNlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLmZyZWUoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5raW5nUG9zc2libGUgJiYgaGFuZGxlci5fc2hvdWxkQ2h1bmtUaGlzRmlsZShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua2VkLnNlbmROZXh0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxlLnNlbmQoaWQsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvciB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbG9nKGlkICsgXCIgdXBsb2FkIHN0YXJ0IGFib3J0ZWQgZHVlIHRvIHJlamVjdGVkIG9uVXBsb2FkIFByb21pc2UgLSBkZXRhaWxzOiBcIiArIGVycm9yLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMub25BdXRvUmV0cnkoaWQsIG5hbWUsIGVycm9yLnJlc3BvbnNlSlNPTiB8fCB7fSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHVwbG9hZC5ub3JtYWxpemVSZXNwb25zZShlcnJvci5yZXNwb25zZUpTT04sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZC5jbGVhbnVwKGlkLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdGFydDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvYlRvVXBsb2FkID0gdXBsb2FkLmdldFByb3h5T3JCbG9iKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvYlRvVXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1cGxvYWQubWF5YmVEZWZlcihpZCwgYmxvYlRvVXBsb2FkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWQubm93KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBxcS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgYWRkOiBmdW5jdGlvbihpZCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuYWRkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBsb2FkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uTWFuYWdlci5vcGVuKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXBsb2FkLnN0YXJ0KGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHJ5OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25jdXJyZW50Q2h1bmtpbmdQb3NzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLnRlbXAuaWdub3JlRmFpbHVyZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbk1hbmFnZXIuaXNVc2luZ0Nvbm5lY3Rpb24oaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1cGxvYWQuc3RhcnQoaWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnVwbG9hZChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FuY2VsUmV0VmFsID0gaGFuZGxlci5jYW5jZWwoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChxcS5pc0dlbmVyaWNQcm9taXNlKGNhbmNlbFJldFZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsUmV0VmFsLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWQuY2FuY2VsKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYW5jZWxSZXRWYWwgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZC5jYW5jZWwoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWxBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB3YWl0aW5nT3JDb25uZWN0ZWQgPSBjb25uZWN0aW9uTWFuYWdlci5nZXRXYWl0aW5nT3JDb25uZWN0ZWQoKSwgaTtcbiAgICAgICAgICAgICAgICBpZiAod2FpdGluZ09yQ29ubmVjdGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSB3YWl0aW5nT3JDb25uZWN0ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2FuY2VsKHdhaXRpbmdPckNvbm5lY3RlZFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGaWxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmdldFByb3h5ICYmIGhhbmRsZXIuZ2V0UHJveHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmdldFByb3h5KGlkKS5yZWZlcmVuY2VCbG9iO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5nZXRGaWxlICYmIGhhbmRsZXIuZ2V0RmlsZShpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNQcm94aWVkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIShoYW5kbGVyLmdldFByb3h5ICYmIGhhbmRsZXIuZ2V0UHJveHkoaWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJbnB1dDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5nZXRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5nZXRJbnB1dChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBsb2coXCJSZXNldHRpbmcgdXBsb2FkIGhhbmRsZXJcIik7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5jYW5jZWxBbGwoKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHB1bmdlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLmlzVmFsaWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmV4cHVuZ2UoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1ZhbGlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmlzVmFsaWQoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhc1Jlc3VtZVJlY29yZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gaGFuZGxlci5pc1ZhbGlkKGlkKSAmJiBoYW5kbGVyLl9nZXRMb2NhbFN0b3JhZ2VJZCAmJiBoYW5kbGVyLl9nZXRMb2NhbFN0b3JhZ2VJZChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UmVzdW1hYmxlRmlsZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5nZXRSZXN1bWFibGVGaWxlc0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuZ2V0UmVzdW1hYmxlRmlsZXNEYXRhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRUaGlyZFBhcnR5RmlsZUlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLmlzVmFsaWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmdldFRoaXJkUGFydHlGaWxlSWQoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXVzZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5pc1Jlc3VtYWJsZShpZCkgJiYgaGFuZGxlci5wYXVzZSAmJiBjb250cm9sbGVyLmlzVmFsaWQoaWQpICYmIGhhbmRsZXIucGF1c2UoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLmZyZWUoaWQpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLm1vdmVJblByb2dyZXNzVG9SZW1haW5pbmcoaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzQXR0ZW1wdGluZ1Jlc3VtZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFoYW5kbGVyLmlzQXR0ZW1wdGluZ1Jlc3VtZSAmJiBoYW5kbGVyLmlzQXR0ZW1wdGluZ1Jlc3VtZShpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNSZXN1bWFibGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhaGFuZGxlci5pc1Jlc3VtYWJsZSAmJiBoYW5kbGVyLmlzUmVzdW1hYmxlKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHFxLmV4dGVuZChvcHRpb25zLCBvKTtcbiAgICAgICAgbG9nID0gb3B0aW9ucy5sb2c7XG4gICAgICAgIGNodW5raW5nUG9zc2libGUgPSBvcHRpb25zLmNodW5raW5nLmVuYWJsZWQgJiYgcXEuc3VwcG9ydGVkRmVhdHVyZXMuY2h1bmtpbmc7XG4gICAgICAgIGNvbmN1cnJlbnRDaHVua2luZ1Bvc3NpYmxlID0gY2h1bmtpbmdQb3NzaWJsZSAmJiBvcHRpb25zLmNodW5raW5nLmNvbmN1cnJlbnQuZW5hYmxlZDtcbiAgICAgICAgcHJldmVudFJldHJ5UmVzcG9uc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHt9O1xuICAgICAgICAgICAgcmVzcG9uc2Vbb3B0aW9ucy5wcmV2ZW50UmV0cnlQYXJhbV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KCk7XG4gICAgICAgIHVwbG9hZC5pbml0SGFuZGxlcigpO1xuICAgIH07XG4gICAgcXEuV2luZG93UmVjZWl2ZU1lc3NhZ2UgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGxvZzogZnVuY3Rpb24obWVzc2FnZSwgbGV2ZWwpIHt9XG4gICAgICAgIH0sIGNhbGxiYWNrV3JhcHBlckRldGFjaGVycyA9IHt9O1xuICAgICAgICBxcS5leHRlbmQob3B0aW9ucywgbyk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICByZWNlaXZlTWVzc2FnZTogZnVuY3Rpb24oaWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9uTWVzc2FnZUNhbGxiYWNrV3JhcHBlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5wb3N0TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1dyYXBwZXJEZXRhY2hlcnNbaWRdID0gcXEod2luZG93KS5hdHRhY2goXCJtZXNzYWdlXCIsIG9uTWVzc2FnZUNhbGxiYWNrV3JhcHBlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiaWZyYW1lIG1lc3NhZ2UgcGFzc2luZyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlciFcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RvcFJlY2VpdmluZ01lc3NhZ2VzOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cucG9zdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRldGFjaGVyID0gY2FsbGJhY2tXcmFwcGVyRGV0YWNoZXJzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRldGFjaGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhY2hlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLkZvcm1VcGxvYWRIYW5kbGVyID0gZnVuY3Rpb24oc3BlYykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBzcGVjLm9wdGlvbnMsIGhhbmRsZXIgPSB0aGlzLCBwcm94eSA9IHNwZWMucHJveHksIGZvcm1IYW5kbGVySW5zdGFuY2VJZCA9IHFxLmdldFVuaXF1ZUlkKCksIG9ubG9hZENhbGxiYWNrcyA9IHt9LCBkZXRhY2hMb2FkRXZlbnRzID0ge30sIHBvc3RNZXNzYWdlQ2FsbGJhY2tUaW1lcnMgPSB7fSwgaXNDb3JzID0gb3B0aW9ucy5pc0NvcnMsIGlucHV0TmFtZSA9IG9wdGlvbnMuaW5wdXROYW1lLCBnZXRVdWlkID0gcHJveHkuZ2V0VXVpZCwgbG9nID0gcHJveHkubG9nLCBjb3JzTWVzc2FnZVJlY2VpdmVyID0gbmV3IHFxLldpbmRvd1JlY2VpdmVNZXNzYWdlKHtcbiAgICAgICAgICAgIGxvZzogbG9nXG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBleHB1bmdlRmlsZShpZCkge1xuICAgICAgICAgICAgZGVsZXRlIGRldGFjaExvYWRFdmVudHNbaWRdO1xuICAgICAgICAgICAgaWYgKGlzQ29ycykge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChwb3N0TWVzc2FnZUNhbGxiYWNrVGltZXJzW2lkXSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBvc3RNZXNzYWdlQ2FsbGJhY2tUaW1lcnNbaWRdO1xuICAgICAgICAgICAgICAgIGNvcnNNZXNzYWdlUmVjZWl2ZXIuc3RvcFJlY2VpdmluZ01lc3NhZ2VzKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYW5kbGVyLl9nZXRJZnJhbWVOYW1lKGlkKSk7XG4gICAgICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZShcInNyY1wiLCBcImphdmFzY3JpcHQ6ZmFsc2U7XCIpO1xuICAgICAgICAgICAgICAgIHFxKGlmcmFtZSkucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RmlsZUlkRm9ySWZyYW1lTmFtZShpZnJhbWVOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gaWZyYW1lTmFtZS5zcGxpdChcIl9cIilbMF07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5pdElmcmFtZUZvclVwbG9hZChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgaWZyYW1lID0gcXEudG9FbGVtZW50KFwiPGlmcmFtZSBzcmM9J2phdmFzY3JpcHQ6ZmFsc2U7JyBuYW1lPSdcIiArIG5hbWUgKyBcIicgLz5cIik7XG4gICAgICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgbmFtZSk7XG4gICAgICAgICAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGlmcmFtZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWdpc3RlclBvc3RNZXNzYWdlQ2FsbGJhY2soaWZyYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlmcmFtZU5hbWUgPSBpZnJhbWUuaWQsIGZpbGVJZCA9IGdldEZpbGVJZEZvcklmcmFtZU5hbWUoaWZyYW1lTmFtZSksIHV1aWQgPSBnZXRVdWlkKGZpbGVJZCk7XG4gICAgICAgICAgICBvbmxvYWRDYWxsYmFja3NbdXVpZF0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGRldGFjaExvYWRFdmVudHNbZmlsZUlkXSA9IHFxKGlmcmFtZSkuYXR0YWNoKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5nZXRJbnB1dChmaWxlSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIlJlY2VpdmVkIGlmcmFtZSBsb2FkIGV2ZW50IGZvciBDT1JTIHVwbG9hZCByZXF1ZXN0IChpZnJhbWUgbmFtZSBcIiArIGlmcmFtZU5hbWUgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlQ2FsbGJhY2tUaW1lcnNbaWZyYW1lTmFtZV0gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFwiTm8gdmFsaWQgbWVzc2FnZSByZWNlaXZlZCBmcm9tIGxvYWRlZCBpZnJhbWUgZm9yIGlmcmFtZSBuYW1lIFwiICsgaWZyYW1lTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhlcnJvck1lc3NhZ2UsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDFlMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb3JzTWVzc2FnZVJlY2VpdmVyLnJlY2VpdmVNZXNzYWdlKGlmcmFtZU5hbWUsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBsb2coXCJSZWNlaXZlZCB0aGUgZm9sbG93aW5nIHdpbmRvdyBtZXNzYWdlOiAnXCIgKyBtZXNzYWdlICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIHZhciBmaWxlSWQgPSBnZXRGaWxlSWRGb3JJZnJhbWVOYW1lKGlmcmFtZU5hbWUpLCByZXNwb25zZSA9IGhhbmRsZXIuX3BhcnNlSnNvblJlc3BvbnNlKG1lc3NhZ2UpLCB1dWlkID0gcmVzcG9uc2UudXVpZCwgb25sb2FkQ2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgaWYgKHV1aWQgJiYgb25sb2FkQ2FsbGJhY2tzW3V1aWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIkhhbmRsaW5nIHJlc3BvbnNlIGZvciBpZnJhbWUgbmFtZSBcIiArIGlmcmFtZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocG9zdE1lc3NhZ2VDYWxsYmFja1RpbWVyc1tpZnJhbWVOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwb3N0TWVzc2FnZUNhbGxiYWNrVGltZXJzW2lmcmFtZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9kZXRhY2hMb2FkRXZlbnQoaWZyYW1lTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIG9ubG9hZENhbGxiYWNrID0gb25sb2FkQ2FsbGJhY2tzW3V1aWRdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb25sb2FkQ2FsbGJhY2tzW3V1aWRdO1xuICAgICAgICAgICAgICAgICAgICBjb3JzTWVzc2FnZVJlY2VpdmVyLnN0b3BSZWNlaXZpbmdNZXNzYWdlcyhpZnJhbWVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgb25sb2FkQ2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXV1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiJ1wiICsgbWVzc2FnZSArIFwiJyBkb2VzIG5vdCBjb250YWluIGEgVVVJRCAtIGlnbm9yaW5nLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBxcS5leHRlbmQodGhpcywgbmV3IHFxLlVwbG9hZEhhbmRsZXIoc3BlYykpO1xuICAgICAgICBxcS5vdmVycmlkZSh0aGlzLCBmdW5jdGlvbihzdXBlcl8pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkOiBmdW5jdGlvbihpZCwgZmlsZUlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyXy5hZGQoaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBmaWxlSW5wdXRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVJbnB1dC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIGlucHV0TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlSW5wdXQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXEoZmlsZUlucHV0KS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXhwdW5nZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwdW5nZUZpbGUoaWQpO1xuICAgICAgICAgICAgICAgICAgICBzdXBlcl8uZXhwdW5nZShpZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXJfLmlzVmFsaWQoaWQpICYmIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuaW5wdXQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIGdldElucHV0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmlucHV0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hdHRhY2hMb2FkRXZlbnQ6IGZ1bmN0aW9uKGlmcmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VEZXNjcmlwdG9yO1xuICAgICAgICAgICAgICAgIGlmIChpc0NvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJQb3N0TWVzc2FnZUNhbGxiYWNrKGlmcmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFjaExvYWRFdmVudHNbaWZyYW1lLmlkXSA9IHFxKGlmcmFtZSkuYXR0YWNoKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcIlJlY2VpdmVkIHJlc3BvbnNlIGZvciBcIiArIGlmcmFtZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlmcmFtZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnREb2N1bWVudCAmJiBpZnJhbWUuY29udGVudERvY3VtZW50LmJvZHkgJiYgaWZyYW1lLmNvbnRlbnREb2N1bWVudC5ib2R5LmlubmVySFRNTCA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFwiRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBpZnJhbWUgZHVyaW5nIGhhbmRsaW5nIG9mIHVwbG9hZCByZXNwb25zZSAoXCIgKyBlcnJvci5tZXNzYWdlICsgXCIpXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VEZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZURlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NyZWF0ZUlmcmFtZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWZyYW1lTmFtZSA9IGhhbmRsZXIuX2dldElmcmFtZU5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0SWZyYW1lRm9yVXBsb2FkKGlmcmFtZU5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9kZXRhY2hMb2FkRXZlbnQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRldGFjaExvYWRFdmVudHNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWNoTG9hZEV2ZW50c1tpZF0oKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRldGFjaExvYWRFdmVudHNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0SWZyYW1lTmFtZTogZnVuY3Rpb24oZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVJZCArIFwiX1wiICsgZm9ybUhhbmRsZXJJbnN0YW5jZUlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pbml0Rm9ybUZvclVwbG9hZDogZnVuY3Rpb24oc3BlYykge1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBzcGVjLm1ldGhvZCwgZW5kcG9pbnQgPSBzcGVjLmVuZHBvaW50LCBwYXJhbXMgPSBzcGVjLnBhcmFtcywgcGFyYW1zSW5Cb2R5ID0gc3BlYy5wYXJhbXNJbkJvZHksIHRhcmdldE5hbWUgPSBzcGVjLnRhcmdldE5hbWUsIGZvcm0gPSBxcS50b0VsZW1lbnQoXCI8Zm9ybSBtZXRob2Q9J1wiICsgbWV0aG9kICsgXCInIGVuY3R5cGU9J211bHRpcGFydC9mb3JtLWRhdGEnPjwvZm9ybT5cIiksIHVybCA9IGVuZHBvaW50O1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXNJbkJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEub2JqMklucHV0cyhwYXJhbXMsIGZvcm0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHFxLm9iajJ1cmwocGFyYW1zLCBlbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKFwiYWN0aW9uXCIsIHVybCk7XG4gICAgICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIiwgdGFyZ2V0TmFtZSk7XG4gICAgICAgICAgICAgICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcGFyc2VKc29uUmVzcG9uc2U6IGZ1bmN0aW9uKGlubmVySHRtbE9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHt9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcXEucGFyc2VKc29uKGlubmVySHRtbE9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIHBhcnNlIGlmcmFtZSB1cGxvYWQgcmVzcG9uc2UgKFwiICsgZXJyb3IubWVzc2FnZSArIFwiKVwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuWGhyVXBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcywgbmFtZXNwYWNlID0gc3BlYy5vcHRpb25zLm5hbWVzcGFjZSwgcHJveHkgPSBzcGVjLnByb3h5LCBjaHVua2luZyA9IHNwZWMub3B0aW9ucy5jaHVua2luZywgZ2V0Q2h1bmtTaXplID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHZhciBmaWxlU3RhdGUgPSBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpO1xuICAgICAgICAgICAgaWYgKGZpbGVTdGF0ZS5jaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZVN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNodW5rU2l6ZSA9IGNodW5raW5nLnBhcnRTaXplO1xuICAgICAgICAgICAgICAgIGlmIChxcS5pc0Z1bmN0aW9uKGNodW5rU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtTaXplID0gY2h1bmtTaXplKGlkLCBnZXRTaXplKGlkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbGVTdGF0ZS5jaHVua1NpemUgPSBjaHVua1NpemU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNodW5rU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgcmVzdW1lID0gc3BlYy5vcHRpb25zLnJlc3VtZSwgY2h1bmtGaWxlcyA9IGNodW5raW5nICYmIHNwZWMub3B0aW9ucy5jaHVua2luZy5lbmFibGVkICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLmNodW5raW5nLCByZXN1bWVFbmFibGVkID0gcmVzdW1lICYmIHNwZWMub3B0aW9ucy5yZXN1bWUuZW5hYmxlZCAmJiBjaHVua0ZpbGVzICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLnJlc3VtZSwgZ2V0TmFtZSA9IHByb3h5LmdldE5hbWUsIGdldFNpemUgPSBwcm94eS5nZXRTaXplLCBnZXRVdWlkID0gcHJveHkuZ2V0VXVpZCwgZ2V0RW5kcG9pbnQgPSBwcm94eS5nZXRFbmRwb2ludCwgZ2V0RGF0YUJ5VXVpZCA9IHByb3h5LmdldERhdGFCeVV1aWQsIG9uVXVpZENoYW5nZWQgPSBwcm94eS5vblV1aWRDaGFuZ2VkLCBvblByb2dyZXNzID0gcHJveHkub25Qcm9ncmVzcywgbG9nID0gcHJveHkubG9nLCBnZXRDdXN0b21SZXN1bWVEYXRhID0gcHJveHkuZ2V0Q3VzdG9tUmVzdW1lRGF0YTtcbiAgICAgICAgZnVuY3Rpb24gYWJvcnQoaWQpIHtcbiAgICAgICAgICAgIHFxLmVhY2goaGFuZGxlci5fZ2V0WGhycyhpZCksIGZ1bmN0aW9uKHhocklkLCB4aHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWpheFJlcXVlc3RlciA9IGhhbmRsZXIuX2dldEFqYXhSZXF1ZXN0ZXIoaWQsIHhocklkKTtcbiAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIGFqYXhSZXF1ZXN0ZXIgJiYgYWpheFJlcXVlc3Rlci5jYW5jZWxlZCAmJiBhamF4UmVxdWVzdGVyLmNhbmNlbGVkKGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCBuZXcgcXEuVXBsb2FkSGFuZGxlcihzcGVjKSk7XG4gICAgICAgIHFxLm92ZXJyaWRlKHRoaXMsIGZ1bmN0aW9uKHN1cGVyXykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGlkLCBibG9iT3JQcm94eSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXEuaXNGaWxlKGJsb2JPclByb3h5KSB8fCBxcS5pc0Jsb2IoYmxvYk9yUHJveHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBlcl8uYWRkKGlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogYmxvYk9yUHJveHlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJsb2JPclByb3h5IGluc3RhbmNlb2YgcXEuQmxvYlByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBlcl8uYWRkKGlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHk6IGJsb2JPclByb3h5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhc3NlZCBvYmogaXMgbm90IGEgRmlsZSwgQmxvYiwgb3IgcHJveHlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5faW5pdFRlbXBTdGF0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VtZUVuYWJsZWQgJiYgaGFuZGxlci5fbWF5YmVQcmVwYXJlRm9yUmVzdW1lKGlkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGV4cHVuZ2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFib3J0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fbWF5YmVEZWxldGVQZXJzaXN0ZWRDaHVua0RhdGEoaWQpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9jbGVhclhocnMoaWQpO1xuICAgICAgICAgICAgICAgICAgICBzdXBlcl8uZXhwdW5nZShpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBjbGVhckNhY2hlZENodW5rOiBmdW5jdGlvbihpZCwgY2h1bmtJZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZVN0YXRlID0gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmaWxlU3RhdGUudGVtcC5jYWNoZWRDaHVua3NbY2h1bmtJZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhclhocjogZnVuY3Rpb24oaWQsIGNodW5rSWR4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBTdGF0ZSA9IGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkudGVtcDtcbiAgICAgICAgICAgICAgICBpZiAodGVtcFN0YXRlLnhocnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRlbXBTdGF0ZS54aHJzW2NodW5rSWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBTdGF0ZS5hamF4UmVxdWVzdGVycykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGVtcFN0YXRlLmFqYXhSZXF1ZXN0ZXJzW2NodW5rSWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluYWxpemVDaHVua3M6IGZ1bmN0aW9uKGlkLCByZXNwb25zZVBhcnNlcikge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0Q2h1bmtJZHggPSBoYW5kbGVyLl9nZXRUb3RhbENodW5rcyhpZCkgLSAxLCB4aHIgPSBoYW5kbGVyLl9nZXRYaHIoaWQsIGxhc3RDaHVua0lkeCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlUGFyc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcXEuUHJvbWlzZSgpLnN1Y2Nlc3MocmVzcG9uc2VQYXJzZXIoeGhyKSwgeGhyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBxcS5Qcm9taXNlKCkuc3VjY2Vzcyh7fSwgeGhyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGaWxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmlzVmFsaWQoaWQpICYmIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuZmlsZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRQcm94eTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5pc1ZhbGlkKGlkKSAmJiBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLnByb3h5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFJlc3VtYWJsZUZpbGVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VtYWJsZUZpbGVzRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuX2l0ZXJhdGVSZXN1bWVSZWNvcmRzKGZ1bmN0aW9uKGtleSwgdXBsb2FkRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLm1vdmVJblByb2dyZXNzVG9SZW1haW5pbmcobnVsbCwgdXBsb2FkRGF0YS5jaHVua2luZy5pblByb2dyZXNzLCB1cGxvYWREYXRhLmNodW5raW5nLnJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdXBsb2FkRGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nOiB1cGxvYWREYXRhLmNodW5raW5nLnJlbWFpbmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHVwbG9hZERhdGEuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWQ6IHVwbG9hZERhdGEudXVpZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBsb2FkRGF0YS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEua2V5ID0gdXBsb2FkRGF0YS5rZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwbG9hZERhdGEuY3VzdG9tUmVzdW1lRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jdXN0b21SZXN1bWVEYXRhID0gdXBsb2FkRGF0YS5jdXN0b21SZXN1bWVEYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VtYWJsZUZpbGVzRGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bWFibGVGaWxlc0RhdGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNBdHRlbXB0aW5nUmVzdW1lOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmF0dGVtcHRpbmdSZXN1bWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNSZXN1bWFibGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhY2h1bmtpbmcgJiYgaGFuZGxlci5pc1ZhbGlkKGlkKSAmJiAhaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5ub3RSZXN1bWFibGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW92ZUluUHJvZ3Jlc3NUb1JlbWFpbmluZzogZnVuY3Rpb24oaWQsIG9wdEluUHJvZ3Jlc3MsIG9wdFJlbWFpbmluZykge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlU3RhdGUgPSBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpIHx8IHt9LCBjaHVua2luZ1N0YXRlID0gZmlsZVN0YXRlLmNodW5raW5nIHx8IHt9LCBpblByb2dyZXNzID0gb3B0SW5Qcm9ncmVzcyB8fCBjaHVua2luZ1N0YXRlLmluUHJvZ3Jlc3MsIHJlbWFpbmluZyA9IG9wdFJlbWFpbmluZyB8fCBjaHVua2luZ1N0YXRlLnJlbWFpbmluZztcbiAgICAgICAgICAgICAgICBpZiAoaW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiTW92aW5nIHRoZXNlIGNodW5rcyBmcm9tIGluLXByb2dyZXNzIHt9LCB0byByZW1haW5pbmcuXCIsIEpTT04uc3RyaW5naWZ5KGluUHJvZ3Jlc3MpKSk7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvZ3Jlc3MucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICBxcS5lYWNoKGluUHJvZ3Jlc3MsIGZ1bmN0aW9uKGlkeCwgY2h1bmtJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZy51bnNoaWZ0KGNodW5rSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvZ3Jlc3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF1c2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuaXNWYWxpZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKHFxLmZvcm1hdChcIkFib3J0aW5nIFhIUiB1cGxvYWQgZm9yIHt9ICd7fScgZHVlIHRvIHBhdXNlIGluc3RydWN0aW9uLlwiLCBpZCwgZ2V0TmFtZShpZCkpKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhYm9ydChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWV2YWx1YXRlQ2h1bmtpbmc6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5raW5nICYmIGhhbmRsZXIuaXNWYWxpZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKSwgdG90YWxDaHVua3MsIGk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5jaHVua2luZztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2h1bmtpbmcgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxDaHVua3MgPSBoYW5kbGVyLl9nZXRUb3RhbENodW5rcyhpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbENodW5rcyA+IDEgfHwgY2h1bmtpbmcubWFuZGF0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaHVua2luZy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNodW5raW5nLnBhcnRzID0gdG90YWxDaHVua3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaHVua2luZy5yZW1haW5pbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2h1bmtpbmcucmVtYWluaW5nLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9pbml0VGVtcFN0YXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmNodW5raW5nLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVCbG9iOiBmdW5jdGlvbihpZCwgbmV3QmxvYikge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmlzVmFsaWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuZmlsZSA9IG5ld0Jsb2I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jbGVhclhocnM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBTdGF0ZSA9IGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkudGVtcDtcbiAgICAgICAgICAgICAgICBxcS5lYWNoKHRlbXBTdGF0ZS5hamF4UmVxdWVzdGVycywgZnVuY3Rpb24oY2h1bmtJZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGVtcFN0YXRlLmFqYXhSZXF1ZXN0ZXJzW2NodW5rSWRdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHFxLmVhY2godGVtcFN0YXRlLnhocnMsIGZ1bmN0aW9uKGNodW5rSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRlbXBTdGF0ZS54aHJzW2NodW5rSWRdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9jcmVhdGVYaHI6IGZ1bmN0aW9uKGlkLCBvcHRDaHVua0lkeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLl9yZWdpc3RlclhocihpZCwgb3B0Q2h1bmtJZHgsIHFxLmNyZWF0ZVhockluc3RhbmNlKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRBamF4UmVxdWVzdGVyOiBmdW5jdGlvbihpZCwgb3B0Q2h1bmtJZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtJZHggPSBvcHRDaHVua0lkeCA9PSBudWxsID8gLTEgOiBvcHRDaHVua0lkeDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS50ZW1wLmFqYXhSZXF1ZXN0ZXJzW2NodW5rSWR4XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZ2V0Q2h1bmtEYXRhOiBmdW5jdGlvbihpZCwgY2h1bmtJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBjaHVua1NpemUgPSBnZXRDaHVua1NpemUoaWQpLCBmaWxlU2l6ZSA9IGdldFNpemUoaWQpLCBmaWxlT3JCbG9iID0gaGFuZGxlci5nZXRGaWxlKGlkKSwgc3RhcnRCeXRlcyA9IGNodW5rU2l6ZSAqIGNodW5rSW5kZXgsIGVuZEJ5dGVzID0gc3RhcnRCeXRlcyArIGNodW5rU2l6ZSA+PSBmaWxlU2l6ZSA/IGZpbGVTaXplIDogc3RhcnRCeXRlcyArIGNodW5rU2l6ZSwgdG90YWxDaHVua3MgPSBoYW5kbGVyLl9nZXRUb3RhbENodW5rcyhpZCksIGNhY2hlZENodW5rcyA9IHRoaXMuX2dldEZpbGVTdGF0ZShpZCkudGVtcC5jYWNoZWRDaHVua3MsIGJsb2IgPSBjYWNoZWRDaHVua3NbY2h1bmtJbmRleF0gfHwgcXEuc2xpY2VCbG9iKGZpbGVPckJsb2IsIHN0YXJ0Qnl0ZXMsIGVuZEJ5dGVzKTtcbiAgICAgICAgICAgICAgICBjYWNoZWRDaHVua3NbY2h1bmtJbmRleF0gPSBibG9iO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQ6IGNodW5rSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydEJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZEJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogdG90YWxDaHVua3MsXG4gICAgICAgICAgICAgICAgICAgIGJsb2I6IGJsb2IsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGVuZEJ5dGVzIC0gc3RhcnRCeXRlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldENodW5rRGF0YUZvckNhbGxiYWNrOiBmdW5jdGlvbihjaHVua0RhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0SW5kZXg6IGNodW5rRGF0YS5wYXJ0LFxuICAgICAgICAgICAgICAgICAgICBzdGFydEJ5dGU6IGNodW5rRGF0YS5zdGFydCArIDEsXG4gICAgICAgICAgICAgICAgICAgIGVuZEJ5dGU6IGNodW5rRGF0YS5lbmQsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsUGFydHM6IGNodW5rRGF0YS5jb3VudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldExvY2FsU3RvcmFnZUlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXRWZXJzaW9uID0gXCI1LjBcIiwgbmFtZSA9IGdldE5hbWUoaWQpLCBzaXplID0gZ2V0U2l6ZShpZCksIGNodW5rU2l6ZSA9IGdldENodW5rU2l6ZShpZCksIGVuZHBvaW50ID0gZ2V0RW5kcG9pbnQoaWQpLCBjdXN0b21LZXlzID0gcmVzdW1lLmN1c3RvbUtleXMoaWQpLCBsb2NhbFN0b3JhZ2VJZCA9IHFxLmZvcm1hdChcInFxe31yZXN1bWV7fS17fS17fS17fS17fVwiLCBuYW1lc3BhY2UsIGZvcm1hdFZlcnNpb24sIG5hbWUsIHNpemUsIGNodW5rU2l6ZSwgZW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgIGN1c3RvbUtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlSWQgKz0gXCItXCIgKyBrZXk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZUlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRNaW1lVHlwZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5nZXRGaWxlKGlkKS50eXBlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRQZXJzaXN0YWJsZURhdGE6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkuY2h1bmtpbmc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldFRvdGFsQ2h1bmtzOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmIChjaHVua2luZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZVNpemUgPSBnZXRTaXplKGlkKSwgY2h1bmtTaXplID0gZ2V0Q2h1bmtTaXplKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChmaWxlU2l6ZSAvIGNodW5rU2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9nZXRYaHI6IGZ1bmN0aW9uKGlkLCBvcHRDaHVua0lkeCkge1xuICAgICAgICAgICAgICAgIHZhciBjaHVua0lkeCA9IG9wdENodW5rSWR4ID09IG51bGwgPyAtMSA6IG9wdENodW5rSWR4O1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLnRlbXAueGhyc1tjaHVua0lkeF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2dldFhocnM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkudGVtcC54aHJzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pdGVyYXRlUmVzdW1lUmVjb3JkczogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdW1lRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBxcS5lYWNoKGxvY2FsU3RvcmFnZSwgZnVuY3Rpb24oa2V5LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YocXEuZm9ybWF0KFwicXF7fXJlc3VtZVwiLCBuYW1lc3BhY2UpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cGxvYWREYXRhID0gSlNPTi5wYXJzZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhrZXksIHVwbG9hZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2luaXRUZW1wU3RhdGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS50ZW1wID0ge1xuICAgICAgICAgICAgICAgICAgICBhamF4UmVxdWVzdGVyczoge30sXG4gICAgICAgICAgICAgICAgICAgIGNodW5rUHJvZ3Jlc3M6IHt9LFxuICAgICAgICAgICAgICAgICAgICB4aHJzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkQ2h1bmtzOiB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX21hcmtOb3RSZXN1bWFibGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS5ub3RSZXN1bWFibGUgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9tYXliZURlbGV0ZVBlcnNpc3RlZENodW5rRGF0YTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxTdG9yYWdlSWQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VtZUVuYWJsZWQgJiYgaGFuZGxlci5pc1Jlc3VtYWJsZShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlSWQgPSBoYW5kbGVyLl9nZXRMb2NhbFN0b3JhZ2VJZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2VJZCAmJiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShsb2NhbFN0b3JhZ2VJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGxvY2FsU3RvcmFnZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWF5YmVQcmVwYXJlRm9yUmVzdW1lOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCksIGxvY2FsU3RvcmFnZUlkLCBwZXJzaXN0ZWREYXRhO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bWVFbmFibGVkICYmIHN0YXRlLmtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZUlkID0gaGFuZGxlci5fZ2V0TG9jYWxTdG9yYWdlSWQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZWREYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obG9jYWxTdG9yYWdlSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVyc2lzdGVkRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVkRGF0YSA9IEpTT04ucGFyc2UocGVyc2lzdGVkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0RGF0YUJ5VXVpZChwZXJzaXN0ZWREYXRhLnV1aWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5fbWFya05vdFJlc3VtYWJsZShpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJJZGVudGlmaWVkIGZpbGUgd2l0aCBJRCB7fSBhbmQgbmFtZSBvZiB7fSBhcyByZXN1bWFibGUuXCIsIGlkLCBnZXROYW1lKGlkKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uVXVpZENoYW5nZWQoaWQsIHBlcnNpc3RlZERhdGEudXVpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUua2V5ID0gcGVyc2lzdGVkRGF0YS5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2h1bmtpbmcgPSBwZXJzaXN0ZWREYXRhLmNodW5raW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmxvYWRlZCA9IHBlcnNpc3RlZERhdGEubG9hZGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmN1c3RvbVJlc3VtZURhdGEgPSBwZXJzaXN0ZWREYXRhLmN1c3RvbVJlc3VtZURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuYXR0ZW1wdGluZ1Jlc3VtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5tb3ZlSW5Qcm9ncmVzc1RvUmVtYWluaW5nKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWF5YmVQZXJzaXN0Q2h1bmtlZFN0YXRlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCksIGxvY2FsU3RvcmFnZUlkLCBwZXJzaXN0ZWREYXRhO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bWVFbmFibGVkICYmIGhhbmRsZXIuaXNSZXN1bWFibGUoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXN0b21SZXN1bWVEYXRhID0gZ2V0Q3VzdG9tUmVzdW1lRGF0YShpZCk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZUlkID0gaGFuZGxlci5fZ2V0TG9jYWxTdG9yYWdlSWQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZWREYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZ2V0TmFtZShpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBnZXRTaXplKGlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWQ6IGdldFV1aWQoaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBzdGF0ZS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua2luZzogc3RhdGUuY2h1bmtpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IHN0YXRlLmxvYWRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXN0b21SZXN1bWVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZWREYXRhLmN1c3RvbVJlc3VtZURhdGEgPSBjdXN0b21SZXN1bWVEYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShsb2NhbFN0b3JhZ2VJZCwgSlNPTi5zdHJpbmdpZnkocGVyc2lzdGVkRGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKHFxLmZvcm1hdChcIlVuYWJsZSB0byBzYXZlIHJlc3VtZSBkYXRhIGZvciAne30nIGR1ZSB0byBlcnJvcjogJ3t9Jy5cIiwgaWQsIGVycm9yLnRvU3RyaW5nKCkpLCBcIndhcm5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlZ2lzdGVyUHJvZ3Jlc3NIYW5kbGVyOiBmdW5jdGlvbihpZCwgY2h1bmtJZHgsIGNodW5rU2l6ZSkge1xuICAgICAgICAgICAgICAgIHZhciB4aHIgPSBoYW5kbGVyLl9nZXRYaHIoaWQsIGNodW5rSWR4KSwgbmFtZSA9IGdldE5hbWUoaWQpLCBwcm9ncmVzc0NhbGN1bGF0b3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbXBsZTogZnVuY3Rpb24obG9hZGVkLCB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVTaXplID0gZ2V0U2l6ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGVkID09PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MoaWQsIG5hbWUsIGZpbGVTaXplLCBmaWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MoaWQsIG5hbWUsIGxvYWRlZCA+PSBmaWxlU2l6ZSA/IGZpbGVTaXplIC0gMSA6IGxvYWRlZCwgZmlsZVNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjaHVua2VkOiBmdW5jdGlvbihsb2FkZWQsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmtQcm9ncmVzcyA9IGhhbmRsZXIuX2dldEZpbGVTdGF0ZShpZCkudGVtcC5jaHVua1Byb2dyZXNzLCB0b3RhbFN1Y2Nlc3NmdWxseUxvYWRlZEZvckZpbGUgPSBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpLmxvYWRlZCwgbG9hZGVkRm9yUmVxdWVzdCA9IGxvYWRlZCwgdG90YWxGb3JSZXF1ZXN0ID0gdG90YWwsIHRvdGFsRmlsZVNpemUgPSBnZXRTaXplKGlkKSwgZXN0QWN0dWFsQ2h1bmtMb2FkZWQgPSBsb2FkZWRGb3JSZXF1ZXN0IC0gKHRvdGFsRm9yUmVxdWVzdCAtIGNodW5rU2l6ZSksIHRvdGFsTG9hZGVkRm9yRmlsZSA9IHRvdGFsU3VjY2Vzc2Z1bGx5TG9hZGVkRm9yRmlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rUHJvZ3Jlc3NbY2h1bmtJZHhdID0gZXN0QWN0dWFsQ2h1bmtMb2FkZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBxcS5lYWNoKGNodW5rUHJvZ3Jlc3MsIGZ1bmN0aW9uKGNodW5rSWR4LCBjaHVua0xvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsTG9hZGVkRm9yRmlsZSArPSBjaHVua0xvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhpZCwgbmFtZSwgdG90YWxMb2FkZWRGb3JGaWxlLCB0b3RhbEZpbGVTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGNodW5rU2l6ZSA9PSBudWxsID8gXCJzaW1wbGVcIiA6IFwiY2h1bmtlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NDYWxjdWxhdG9yW3R5cGVdKGUubG9hZGVkLCBlLnRvdGFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JlZ2lzdGVyWGhyOiBmdW5jdGlvbihpZCwgb3B0Q2h1bmtJZHgsIHhociwgb3B0QWpheFJlcXVlc3Rlcikge1xuICAgICAgICAgICAgICAgIHZhciB4aHJzSWQgPSBvcHRDaHVua0lkeCA9PSBudWxsID8gLTEgOiBvcHRDaHVua0lkeCwgdGVtcFN0YXRlID0gaGFuZGxlci5fZ2V0RmlsZVN0YXRlKGlkKS50ZW1wO1xuICAgICAgICAgICAgICAgIHRlbXBTdGF0ZS54aHJzID0gdGVtcFN0YXRlLnhocnMgfHwge307XG4gICAgICAgICAgICAgICAgdGVtcFN0YXRlLmFqYXhSZXF1ZXN0ZXJzID0gdGVtcFN0YXRlLmFqYXhSZXF1ZXN0ZXJzIHx8IHt9O1xuICAgICAgICAgICAgICAgIHRlbXBTdGF0ZS54aHJzW3hocnNJZF0gPSB4aHI7XG4gICAgICAgICAgICAgICAgaWYgKG9wdEFqYXhSZXF1ZXN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN0YXRlLmFqYXhSZXF1ZXN0ZXJzW3hocnNJZF0gPSBvcHRBamF4UmVxdWVzdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geGhyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9yZW1vdmVFeHBpcmVkQ2h1bmtpbmdSZWNvcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwaXJhdGlvbkRheXMgPSByZXN1bWUucmVjb3Jkc0V4cGlyZUluO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuX2l0ZXJhdGVSZXN1bWVSZWNvcmRzKGZ1bmN0aW9uKGtleSwgdXBsb2FkRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwaXJhdGlvbkRhdGUgPSBuZXcgRGF0ZSh1cGxvYWREYXRhLmxhc3RVcGRhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJhdGlvbkRhdGUuc2V0RGF0ZShleHBpcmF0aW9uRGF0ZS5nZXREYXRlKCkgKyBleHBpcmF0aW9uRGF5cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBpcmF0aW9uRGF0ZS5nZXRUaW1lKCkgPD0gRGF0ZS5ub3coKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFwiUmVtb3ZpbmcgZXhwaXJlZCByZXN1bWUgcmVjb3JkIHdpdGgga2V5IFwiICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2hvdWxkQ2h1bmtUaGlzRmlsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBoYW5kbGVyLl9nZXRGaWxlU3RhdGUoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmNodW5raW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLnJlZXZhbHVhdGVDaHVua2luZyhpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmNodW5raW5nLmVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLkRlbGV0ZUZpbGVBamF4UmVxdWVzdGVyID0gZnVuY3Rpb24obykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIHJlcXVlc3Rlciwgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIHV1aWRQYXJhbU5hbWU6IFwicXF1dWlkXCIsXG4gICAgICAgICAgICBlbmRwb2ludFN0b3JlOiB7fSxcbiAgICAgICAgICAgIG1heENvbm5lY3Rpb25zOiAzLFxuICAgICAgICAgICAgY3VzdG9tSGVhZGVyczogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyYW1zU3RvcmU6IHt9LFxuICAgICAgICAgICAgY29yczoge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZW5kQ3JlZGVudGlhbHM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9nOiBmdW5jdGlvbihzdHIsIGxldmVsKSB7fSxcbiAgICAgICAgICAgIG9uRGVsZXRlOiBmdW5jdGlvbihpZCkge30sXG4gICAgICAgICAgICBvbkRlbGV0ZUNvbXBsZXRlOiBmdW5jdGlvbihpZCwgeGhyT3JYZHIsIGlzRXJyb3IpIHt9XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZChvcHRpb25zLCBvKTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0TWFuZGF0ZWRQYXJhbXMoKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKSA9PT0gXCJQT1NUXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBfbWV0aG9kOiBcIkRFTEVURVwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0ZXIgPSBxcS5leHRlbmQodGhpcywgbmV3IHFxLkFqYXhSZXF1ZXN0ZXIoe1xuICAgICAgICAgICAgYWNjZXB0SGVhZGVyOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIHZhbGlkTWV0aG9kczogWyBcIlBPU1RcIiwgXCJERUxFVEVcIiBdLFxuICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgIGVuZHBvaW50U3RvcmU6IG9wdGlvbnMuZW5kcG9pbnRTdG9yZSxcbiAgICAgICAgICAgIHBhcmFtc1N0b3JlOiBvcHRpb25zLnBhcmFtc1N0b3JlLFxuICAgICAgICAgICAgbWFuZGF0ZWRQYXJhbXM6IGdldE1hbmRhdGVkUGFyYW1zKCksXG4gICAgICAgICAgICBtYXhDb25uZWN0aW9uczogb3B0aW9ucy5tYXhDb25uZWN0aW9ucyxcbiAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY3VzdG9tSGVhZGVycy5nZXQoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvZzogb3B0aW9ucy5sb2csXG4gICAgICAgICAgICBvblNlbmQ6IG9wdGlvbnMub25EZWxldGUsXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBvcHRpb25zLm9uRGVsZXRlQ29tcGxldGUsXG4gICAgICAgICAgICBjb3JzOiBvcHRpb25zLmNvcnNcbiAgICAgICAgfSkpO1xuICAgICAgICBxcS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgc2VuZERlbGV0ZTogZnVuY3Rpb24oaWQsIHV1aWQsIGFkZGl0aW9uYWxNYW5kYXRlZFBhcmFtcykge1xuICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsT3B0aW9ucyA9IGFkZGl0aW9uYWxNYW5kYXRlZFBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhcIlN1Ym1pdHRpbmcgZGVsZXRlIGZpbGUgcmVxdWVzdCBmb3IgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0aG9kID09PSBcIkRFTEVURVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Rlci5pbml0VHJhbnNwb3J0KGlkKS53aXRoUGF0aCh1dWlkKS53aXRoUGFyYW1zKGFkZGl0aW9uYWxPcHRpb25zKS5zZW5kKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnNbb3B0aW9ucy51dWlkUGFyYW1OYW1lXSA9IHV1aWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Rlci5pbml0VHJhbnNwb3J0KGlkKS53aXRoUGFyYW1zKGFkZGl0aW9uYWxPcHRpb25zKS5zZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gZGV0ZWN0U3Vic2FtcGxpbmcoaW1nKSB7XG4gICAgICAgICAgICB2YXIgaXcgPSBpbWcubmF0dXJhbFdpZHRoLCBpaCA9IGltZy5uYXR1cmFsSGVpZ2h0LCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLCBjdHg7XG4gICAgICAgICAgICBpZiAoaXcgKiBpaCA+IDEwMjQgKiAxMDI0KSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgLWl3ICsgMSwgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YVszXSA9PT0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRldGVjdFZlcnRpY2FsU3F1YXNoKGltZywgaXcsIGloKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgc3kgPSAwLCBleSA9IGloLCBweSA9IGloLCBjdHgsIGRhdGEsIGFscGhhLCByYXRpbztcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaWg7XG4gICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgICAgICAgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgaWgpLmRhdGE7XG4gICAgICAgICAgICB3aGlsZSAocHkgPiBzeSkge1xuICAgICAgICAgICAgICAgIGFscGhhID0gZGF0YVsocHkgLSAxKSAqIDQgKyAzXTtcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXkgPSBweTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzeSA9IHB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBweSA9IGV5ICsgc3kgPj4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhdGlvID0gcHkgLyBpaDtcbiAgICAgICAgICAgIHJldHVybiByYXRpbyA9PT0gMCA/IDEgOiByYXRpbztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZW5kZXJJbWFnZVRvRGF0YVVSTChpbWcsIGJsb2IsIG9wdGlvbnMsIGRvU3F1YXNoKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgbWltZSA9IG9wdGlvbnMubWltZSB8fCBcImltYWdlL2pwZWdcIiwgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICByZW5kZXJJbWFnZVRvQ2FudmFzKGltZywgYmxvYiwgY2FudmFzLCBvcHRpb25zLCBkb1NxdWFzaCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MoY2FudmFzLnRvRGF0YVVSTChtaW1lLCBvcHRpb25zLnF1YWxpdHkgfHwgLjgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVDYWxjdWxhdGVEb3duc2FtcGxlZERpbWVuc2lvbnMoc3BlYykge1xuICAgICAgICAgICAgdmFyIG1heFBpeGVscyA9IDUyNDFlMztcbiAgICAgICAgICAgIGlmICghcXEuaW9zKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcXEuRXJyb3IoXCJEb3duc2FtcGxlZCBkaW1lbnNpb25zIGNhbiBvbmx5IGJlIHJlbGlhYmx5IGNhbGN1bGF0ZWQgZm9yIGlPUyFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BlYy5vcmlnSGVpZ2h0ICogc3BlYy5vcmlnV2lkdGggPiBtYXhQaXhlbHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuZXdIZWlnaHQ6IE1hdGgucm91bmQoTWF0aC5zcXJ0KG1heFBpeGVscyAqIChzcGVjLm9yaWdIZWlnaHQgLyBzcGVjLm9yaWdXaWR0aCkpKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3V2lkdGg6IE1hdGgucm91bmQoTWF0aC5zcXJ0KG1heFBpeGVscyAqIChzcGVjLm9yaWdXaWR0aCAvIHNwZWMub3JpZ0hlaWdodCkpKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVuZGVySW1hZ2VUb0NhbnZhcyhpbWcsIGJsb2IsIGNhbnZhcywgb3B0aW9ucywgZG9TcXVhc2gpIHtcbiAgICAgICAgICAgIHZhciBpdyA9IGltZy5uYXR1cmFsV2lkdGgsIGloID0gaW1nLm5hdHVyYWxIZWlnaHQsIHdpZHRoID0gb3B0aW9ucy53aWR0aCwgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQsIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpLCBtb2RpZmllZERpbWVuc2lvbnM7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVzaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlckltYWdlVG9DYW52YXNXaXRoQ3VzdG9tUmVzaXplcih7XG4gICAgICAgICAgICAgICAgICAgIGJsb2I6IGJsb2IsXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhczogY2FudmFzLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1nLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZUhlaWdodDogaWgsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlV2lkdGg6IGl3LFxuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjogb3B0aW9ucy5vcmllbnRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplOiBvcHRpb25zLnJlc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFdpZHRoOiB3aWR0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFxcS5zdXBwb3J0ZWRGZWF0dXJlcy51bmxpbWl0ZWRTY2FsZWRJbWFnZVNpemUpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZERpbWVuc2lvbnMgPSBtYXliZUNhbGN1bGF0ZURvd25zYW1wbGVkRGltZW5zaW9ucyh7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdIZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZERpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEubG9nKHFxLmZvcm1hdChcIkhhZCB0byByZWR1Y2UgZGltZW5zaW9ucyBkdWUgdG8gZGV2aWNlIGxpbWl0YXRpb25zIGZyb20ge313IC8ge31oIHRvIHt9dyAvIHt9aFwiLCB3aWR0aCwgaGVpZ2h0LCBtb2RpZmllZERpbWVuc2lvbnMubmV3V2lkdGgsIG1vZGlmaWVkRGltZW5zaW9ucy5uZXdIZWlnaHQpLCBcIndhcm5cIik7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gbW9kaWZpZWREaW1lbnNpb25zLm5ld1dpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBtb2RpZmllZERpbWVuc2lvbnMubmV3SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zZm9ybUNvb3JkaW5hdGUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zLm9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgIGlmIChxcS5pb3MoKSkge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRldGVjdFN1YnNhbXBsaW5nKGltZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl3IC89IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpaCAvPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gMTAyNCwgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgdmVydFNxdWFzaFJhdGlvID0gZG9TcXVhc2ggPyBkZXRlY3RWZXJ0aWNhbFNxdWFzaChpbWcsIGl3LCBpaCkgOiAxLCBkdyA9IE1hdGguY2VpbChkICogd2lkdGggLyBpdyksIGRoID0gTWF0aC5jZWlsKGQgKiBoZWlnaHQgLyBpaCAvIHZlcnRTcXVhc2hSYXRpbyksIHN5ID0gMCwgZHkgPSAwLCB0bXBDdHgsIHN4LCBkeDtcbiAgICAgICAgICAgICAgICAgICAgdG1wQ2FudmFzLndpZHRoID0gdG1wQ2FudmFzLmhlaWdodCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIHRtcEN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzeSA8IGloKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3ggPCBpdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgZCwgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wQ3R4LmRyYXdJbWFnZShpbWcsIC1zeCwgLXN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRtcENhbnZhcywgMCwgMCwgZCwgZCwgZHgsIGR5LCBkdywgZGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN4ICs9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHggKz0gZHc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzeSArPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHkgKz0gZGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wQ2FudmFzID0gdG1wQ3R4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW52YXMucXFJbWFnZVJlbmRlcmVkICYmIGNhbnZhcy5xcUltYWdlUmVuZGVyZWQoKTtcbiAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVuZGVySW1hZ2VUb0NhbnZhc1dpdGhDdXN0b21SZXNpemVyKHJlc2l6ZUluZm8pIHtcbiAgICAgICAgICAgIHZhciBibG9iID0gcmVzaXplSW5mby5ibG9iLCBpbWFnZSA9IHJlc2l6ZUluZm8uaW1hZ2UsIGltYWdlSGVpZ2h0ID0gcmVzaXplSW5mby5pbWFnZUhlaWdodCwgaW1hZ2VXaWR0aCA9IHJlc2l6ZUluZm8uaW1hZ2VXaWR0aCwgb3JpZW50YXRpb24gPSByZXNpemVJbmZvLm9yaWVudGF0aW9uLCBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKSwgcmVzaXplID0gcmVzaXplSW5mby5yZXNpemUsIHNvdXJjZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksIHNvdXJjZUNhbnZhc0NvbnRleHQgPSBzb3VyY2VDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLCB0YXJnZXRDYW52YXMgPSByZXNpemVJbmZvLmNhbnZhcywgdGFyZ2V0SGVpZ2h0ID0gcmVzaXplSW5mby50YXJnZXRIZWlnaHQsIHRhcmdldFdpZHRoID0gcmVzaXplSW5mby50YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIHRyYW5zZm9ybUNvb3JkaW5hdGUoc291cmNlQ2FudmFzLCBpbWFnZVdpZHRoLCBpbWFnZUhlaWdodCwgb3JpZW50YXRpb24pO1xuICAgICAgICAgICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IHRhcmdldEhlaWdodDtcbiAgICAgICAgICAgIHRhcmdldENhbnZhcy53aWR0aCA9IHRhcmdldFdpZHRoO1xuICAgICAgICAgICAgc291cmNlQ2FudmFzQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgICAgICAgcmVzaXplKHtcbiAgICAgICAgICAgICAgICBibG9iOiBibG9iLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGFyZ2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICAgICAgICBzb3VyY2VDYW52YXM6IHNvdXJjZUNhbnZhcyxcbiAgICAgICAgICAgICAgICB0YXJnZXRDYW52YXM6IHRhcmdldENhbnZhcyxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGFyZ2V0V2lkdGhcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gc3VjY2VzcygpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRDYW52YXMucXFJbWFnZVJlbmRlcmVkICYmIHRhcmdldENhbnZhcy5xcUltYWdlUmVuZGVyZWQoKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH0sIHByb21pc2UuZmFpbHVyZSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0cmFuc2Zvcm1Db29yZGluYXRlKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgb3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKC41ICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSguNSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgLWhlaWdodCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLjUgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKC0uNSAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXdpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIE1lZ2FQaXhJbWFnZShzcmNJbWFnZSwgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5CbG9iICYmIHNyY0ltYWdlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpLCBVUkwgPSB3aW5kb3cuVVJMICYmIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMID8gd2luZG93LlVSTCA6IHdpbmRvdy53ZWJraXRVUkwgJiYgd2luZG93LndlYmtpdFVSTC5jcmVhdGVPYmplY3RVUkwgPyB3aW5kb3cud2Via2l0VVJMIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFVUkwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTm8gY3JlYXRlT2JqZWN0VVJMIGZ1bmN0aW9uIGZvdW5kIHRvIGNyZWF0ZSBibG9iIHVybFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzcmNJbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmxvYiA9IHNyY0ltYWdlO1xuICAgICAgICAgICAgICAgICAgICBzcmNJbWFnZSA9IGltZztcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzcmNJbWFnZS5uYXR1cmFsV2lkdGggJiYgIXNyY0ltYWdlLm5hdHVyYWxIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzcmNJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHNlbGYuaW1hZ2VMb2FkTGlzdGVuZXJzO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmltYWdlTG9hZExpc3RlbmVycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNyY0ltYWdlLm9uZXJyb3IgPSBlcnJvckNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VMb2FkTGlzdGVuZXJzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNyY0ltYWdlID0gc3JjSW1hZ2U7XG4gICAgICAgIH1cbiAgICAgICAgTWVnYVBpeEltYWdlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBpbWdXaWR0aCA9IHRoaXMuc3JjSW1hZ2UubmF0dXJhbFdpZHRoLCBpbWdIZWlnaHQgPSB0aGlzLnNyY0ltYWdlLm5hdHVyYWxIZWlnaHQsIHdpZHRoID0gb3B0aW9ucy53aWR0aCwgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQsIG1heFdpZHRoID0gb3B0aW9ucy5tYXhXaWR0aCwgbWF4SGVpZ2h0ID0gb3B0aW9ucy5tYXhIZWlnaHQsIGRvU3F1YXNoID0gIXRoaXMuYmxvYiB8fCB0aGlzLmJsb2IudHlwZSA9PT0gXCJpbWFnZS9qcGVnXCIsIHRhZ05hbWUgPSB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBvcHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbWFnZUxvYWRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlTG9hZExpc3RlbmVycy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlcih0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaW1nSGVpZ2h0ICogd2lkdGggLyBpbWdXaWR0aCA8PCAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQgJiYgIXdpZHRoKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBpbWdXaWR0aCAqIGhlaWdodCAvIGltZ0hlaWdodCA8PCAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ1dpZHRoO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ0hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhXaWR0aCAmJiB3aWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdIZWlnaHQgKiB3aWR0aCAvIGltZ1dpZHRoIDw8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4SGVpZ2h0ICYmIGhlaWdodCA+IG1heEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ1dpZHRoICogaGVpZ2h0IC8gaW1nSGVpZ2h0IDw8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHQgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICB9LCBxcS5lYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKG9wdGlvbnNLZXksIG9wdGlvbnNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG9wdFtvcHRpb25zS2V5XSA9IG9wdGlvbnNWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09IFwiaW1nXCIpIHtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRUYXJnZXRTcmMgPSB0YXJnZXQuc3JjO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJJbWFnZVRvRGF0YVVSTChzZWxmLnNyY0ltYWdlLCBzZWxmLmJsb2IsIG9wdCwgZG9TcXVhc2gpLnRoZW4oZnVuY3Rpb24oZGF0YVVyaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNyYyA9IGRhdGFVcmk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRUYXJnZXRTcmMgPT09IHRhcmdldC5zcmMgJiYgdGFyZ2V0Lm9ubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVySW1hZ2VUb0NhbnZhcyh0aGlzLnNyY0ltYWdlLCB0aGlzLmJsb2IsIHRhcmdldCwgb3B0LCBkb1NxdWFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub25yZW5kZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRoaXMub25yZW5kZXIodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEuTWVnYVBpeEltYWdlID0gTWVnYVBpeEltYWdlO1xuICAgIH0pKCk7XG4gICAgcXEuSW1hZ2VHZW5lcmF0b3IgPSBmdW5jdGlvbihsb2cpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIGZ1bmN0aW9uIGlzSW1nKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImltZ1wiO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQ2FudmFzKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImNhbnZhc1wiO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzSW1nQ29yc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1hZ2UoKS5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQ2FudmFzU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQgJiYgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZXRlcm1pbmVNaW1lT2ZGaWxlTmFtZShuYW1lV2l0aFBhdGgpIHtcbiAgICAgICAgICAgIHZhciBwYXRoU2VnbWVudHMgPSBuYW1lV2l0aFBhdGguc3BsaXQoXCIvXCIpLCBuYW1lID0gcGF0aFNlZ21lbnRzW3BhdGhTZWdtZW50cy5sZW5ndGggLSAxXS5zcGxpdChcIj9cIilbMF0sIGV4dGVuc2lvbiA9IHFxLmdldEV4dGVuc2lvbihuYW1lKTtcbiAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbiAmJiBleHRlbnNpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJqcGVnXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJqcGdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJpbWFnZS9qcGVnXCI7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInBuZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImltYWdlL3BuZ1wiO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJibXBcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJpbWFnZS9ibXBcIjtcblxuICAgICAgICAgICAgICBjYXNlIFwiZ2lmXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaW1hZ2UvZ2lmXCI7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInRpZmZcIjpcbiAgICAgICAgICAgICAgY2FzZSBcInRpZlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImltYWdlL3RpZmZcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0Nyb3NzT3JpZ2luKHVybCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpLCB0YXJnZXRQcm90b2NvbCwgdGFyZ2V0SG9zdG5hbWUsIHRhcmdldFBvcnQ7XG4gICAgICAgICAgICB0YXJnZXRBbmNob3IuaHJlZiA9IHVybDtcbiAgICAgICAgICAgIHRhcmdldFByb3RvY29sID0gdGFyZ2V0QW5jaG9yLnByb3RvY29sO1xuICAgICAgICAgICAgdGFyZ2V0UG9ydCA9IHRhcmdldEFuY2hvci5wb3J0O1xuICAgICAgICAgICAgdGFyZ2V0SG9zdG5hbWUgPSB0YXJnZXRBbmNob3IuaG9zdG5hbWU7XG4gICAgICAgICAgICBpZiAodGFyZ2V0UHJvdG9jb2wudG9Mb3dlckNhc2UoKSAhPT0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRIb3N0bmFtZS50b0xvd2VyQ2FzZSgpICE9PSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldFBvcnQgIT09IHdpbmRvdy5sb2NhdGlvbi5wb3J0ICYmICFxcS5pZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJJbWdMb2FkTGlzdGVuZXJzKGltZywgcHJvbWlzZSkge1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MoaW1nKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsb2coXCJQcm9ibGVtIGRyYXdpbmcgdGh1bWJuYWlsIVwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHByb21pc2UuZmFpbHVyZShpbWcsIFwiUHJvYmxlbSBkcmF3aW5nIHRodW1ibmFpbCFcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQ2FudmFzRHJhd0ltYWdlTGlzdGVuZXIoY2FudmFzLCBwcm9taXNlKSB7XG4gICAgICAgICAgICBjYW52YXMucXFJbWFnZVJlbmRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKGNhbnZhcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyVGh1bWJuYWlsUmVuZGVyZWRMaXN0ZW5lcihpbWdPckNhbnZhcywgcHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIHJlZ2lzdGVyZWQgPSBpc0ltZyhpbWdPckNhbnZhcykgfHwgaXNDYW52YXMoaW1nT3JDYW52YXMpO1xuICAgICAgICAgICAgaWYgKGlzSW1nKGltZ09yQ2FudmFzKSkge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVySW1nTG9hZExpc3RlbmVycyhpbWdPckNhbnZhcywgcHJvbWlzZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2FudmFzKGltZ09yQ2FudmFzKSkge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyQ2FudmFzRHJhd0ltYWdlTGlzdGVuZXIoaW1nT3JDYW52YXMsIHByb21pc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLmZhaWx1cmUoaW1nT3JDYW52YXMpO1xuICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJFbGVtZW50IGNvbnRhaW5lciBvZiB0eXBlIHt9IGlzIG5vdCBzdXBwb3J0ZWQhXCIsIGltZ09yQ2FudmFzLnRhZ05hbWUpLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZHJhdyhmaWxlT3JCbG9iLCBjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBkcmF3UHJldmlldyA9IG5ldyBxcS5Qcm9taXNlKCksIGlkZW50aWZpZXIgPSBuZXcgcXEuSWRlbnRpZnkoZmlsZU9yQmxvYiwgbG9nKSwgbWF4U2l6ZSA9IG9wdGlvbnMubWF4U2l6ZSwgb3JpZW50ID0gb3B0aW9ucy5vcmllbnQgPT0gbnVsbCA/IHRydWUgOiBvcHRpb25zLm9yaWVudCwgbWVnYXBpeEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb250YWluZXIub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsb2coXCJDb3VsZCBub3QgcmVuZGVyIHByZXZpZXcsIGZpbGUgbWF5IGJlIHRvbyBsYXJnZSFcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBkcmF3UHJldmlldy5mYWlsdXJlKGNvbnRhaW5lciwgXCJCcm93c2VyIGNhbm5vdCByZW5kZXIgaW1hZ2UhXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlkZW50aWZpZXIuaXNQcmV2aWV3YWJsZSgpLnRoZW4oZnVuY3Rpb24obWltZSkge1xuICAgICAgICAgICAgICAgIHZhciBkdW1teUV4aWYgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcXEuUHJvbWlzZSgpLnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGV4aWYgPSBvcmllbnQgPyBuZXcgcXEuRXhpZihmaWxlT3JCbG9iLCBsb2cpIDogZHVtbXlFeGlmLCBtcEltZyA9IG5ldyBxcS5NZWdhUGl4SW1hZ2UoZmlsZU9yQmxvYiwgbWVnYXBpeEVycm9ySGFuZGxlcik7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdGVyVGh1bWJuYWlsUmVuZGVyZWRMaXN0ZW5lcihjb250YWluZXIsIGRyYXdQcmV2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICBleGlmLnBhcnNlKCkudGhlbihmdW5jdGlvbihleGlmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZW50YXRpb24gPSBleGlmICYmIGV4aWYuT3JpZW50YXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBtcEltZy5yZW5kZXIoY29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IG1heFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBtYXhTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lOiBtaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZTogb3B0aW9ucy5jdXN0b21SZXNpemVGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGZhaWx1cmVNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJFWElGIGRhdGEgY291bGQgbm90IGJlIHBhcnNlZCAoe30pLiAgQXNzdW1pbmcgb3JpZW50YXRpb24gPSAxLlwiLCBmYWlsdXJlTXNnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtcEltZy5yZW5kZXIoY29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IG1heFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBtYXhTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWU6IG1pbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplOiBvcHRpb25zLmN1c3RvbVJlc2l6ZUZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiTm90IHByZXZpZXdhYmxlXCIpO1xuICAgICAgICAgICAgICAgIGRyYXdQcmV2aWV3LmZhaWx1cmUoY29udGFpbmVyLCBcIk5vdCBwcmV2aWV3YWJsZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRyYXdQcmV2aWV3O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRyYXdPbkNhbnZhc09ySW1nRnJvbVVybCh1cmwsIGNhbnZhc09ySW1nLCBkcmF3LCBtYXhTaXplLCBjdXN0b21SZXNpemVGdW5jdGlvbikge1xuICAgICAgICAgICAgdmFyIHRlbXBJbWcgPSBuZXcgSW1hZ2UoKSwgdGVtcEltZ1JlbmRlciA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICByZWdpc3RlclRodW1ibmFpbFJlbmRlcmVkTGlzdGVuZXIodGVtcEltZywgdGVtcEltZ1JlbmRlcik7XG4gICAgICAgICAgICBpZiAoaXNDcm9zc09yaWdpbih1cmwpKSB7XG4gICAgICAgICAgICAgICAgdGVtcEltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wSW1nLnNyYyA9IHVybDtcbiAgICAgICAgICAgIHRlbXBJbWdSZW5kZXIudGhlbihmdW5jdGlvbiByZW5kZXJlZCgpIHtcbiAgICAgICAgICAgICAgICByZWdpc3RlclRodW1ibmFpbFJlbmRlcmVkTGlzdGVuZXIoY2FudmFzT3JJbWcsIGRyYXcpO1xuICAgICAgICAgICAgICAgIHZhciBtcEltZyA9IG5ldyBxcS5NZWdhUGl4SW1hZ2UodGVtcEltZyk7XG4gICAgICAgICAgICAgICAgbXBJbWcucmVuZGVyKGNhbnZhc09ySW1nLCB7XG4gICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiBtYXhTaXplLFxuICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IG1heFNpemUsXG4gICAgICAgICAgICAgICAgICAgIG1pbWU6IGRldGVybWluZU1pbWVPZkZpbGVOYW1lKHVybCksXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZTogY3VzdG9tUmVzaXplRnVuY3Rpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGRyYXcuZmFpbHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZHJhd09uSW1nRnJvbVVybFdpdGhDc3NTY2FsaW5nKHVybCwgaW1nLCBkcmF3LCBtYXhTaXplKSB7XG4gICAgICAgICAgICByZWdpc3RlclRodW1ibmFpbFJlbmRlcmVkTGlzdGVuZXIoaW1nLCBkcmF3KTtcbiAgICAgICAgICAgIHFxKGltZykuY3NzKHtcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogbWF4U2l6ZSArIFwicHhcIixcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IG1heFNpemUgKyBcInB4XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkcmF3RnJvbVVybCh1cmwsIGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGRyYXcgPSBuZXcgcXEuUHJvbWlzZSgpLCBzY2FsZSA9IG9wdGlvbnMuc2NhbGUsIG1heFNpemUgPSBzY2FsZSA/IG9wdGlvbnMubWF4U2l6ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoc2NhbGUgJiYgaXNJbWcoY29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0NhbnZhc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Nyb3NzT3JpZ2luKHVybCkgJiYgIWlzSW1nQ29yc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3T25JbWdGcm9tVXJsV2l0aENzc1NjYWxpbmcodXJsLCBjb250YWluZXIsIGRyYXcsIG1heFNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd09uQ2FudmFzT3JJbWdGcm9tVXJsKHVybCwgY29udGFpbmVyLCBkcmF3LCBtYXhTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdPbkltZ0Zyb21VcmxXaXRoQ3NzU2NhbGluZyh1cmwsIGNvbnRhaW5lciwgZHJhdywgbWF4U2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NhbnZhcyhjb250YWluZXIpKSB7XG4gICAgICAgICAgICAgICAgZHJhd09uQ2FudmFzT3JJbWdGcm9tVXJsKHVybCwgY29udGFpbmVyLCBkcmF3LCBtYXhTaXplKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVnaXN0ZXJUaHVtYm5haWxSZW5kZXJlZExpc3RlbmVyKGNvbnRhaW5lciwgZHJhdykpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc3JjID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRyYXc7XG4gICAgICAgIH1cbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIGdlbmVyYXRlOiBmdW5jdGlvbihmaWxlQmxvYk9yVXJsLCBjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocXEuaXNTdHJpbmcoZmlsZUJsb2JPclVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiQXR0ZW1wdGluZyB0byB1cGRhdGUgdGh1bWJuYWlsIGJhc2VkIG9uIHNlcnZlciByZXNwb25zZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkcmF3RnJvbVVybChmaWxlQmxvYk9yVXJsLCBjb250YWluZXIsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIkF0dGVtcHRpbmcgdG8gZHJhdyBjbGllbnQtc2lkZSBpbWFnZSBwcmV2aWV3LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRyYXcoZmlsZUJsb2JPclVybCwgY29udGFpbmVyLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90ZXN0aW5nID0ge307XG4gICAgICAgIHRoaXMuX3Rlc3RpbmcuaXNJbWcgPSBpc0ltZztcbiAgICAgICAgdGhpcy5fdGVzdGluZy5pc0NhbnZhcyA9IGlzQ2FudmFzO1xuICAgICAgICB0aGlzLl90ZXN0aW5nLmlzQ3Jvc3NPcmlnaW4gPSBpc0Nyb3NzT3JpZ2luO1xuICAgICAgICB0aGlzLl90ZXN0aW5nLmRldGVybWluZU1pbWVPZkZpbGVOYW1lID0gZGV0ZXJtaW5lTWltZU9mRmlsZU5hbWU7XG4gICAgfTtcbiAgICBxcS5FeGlmID0gZnVuY3Rpb24oZmlsZU9yQmxvYiwgbG9nKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgVEFHX0lEUyA9IFsgMjc0IF0sIFRBR19JTkZPID0ge1xuICAgICAgICAgICAgMjc0OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJPcmllbnRhdGlvblwiLFxuICAgICAgICAgICAgICAgIGJ5dGVzOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlTGl0dGxlRW5kaWFuKGhleCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IDAsIHBvdyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaGV4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZygwLCAyKSwgMTYpICogTWF0aC5wb3coMiwgcG93KTtcbiAgICAgICAgICAgICAgICBoZXggPSBoZXguc3Vic3RyaW5nKDIsIGhleC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHBvdyArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZWVrVG9BcHAxKG9mZnNldCwgcHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIHRoZU9mZnNldCA9IG9mZnNldCwgdGhlUHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgICAgICBpZiAodGhlT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGVPZmZzZXQgPSAyO1xuICAgICAgICAgICAgICAgIHRoZVByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXEucmVhZEJsb2JUb0hleChmaWxlT3JCbG9iLCB0aGVPZmZzZXQsIDQpLnRoZW4oZnVuY3Rpb24oaGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gL15mZmUoWzAtOV0pLy5leGVjKGhleCksIHNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSAhPT0gXCIxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRMZW5ndGggPSBwYXJzZUludChoZXguc2xpY2UoNCwgOCksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZWtUb0FwcDEodGhlT2Zmc2V0ICsgc2VnbWVudExlbmd0aCArIDIsIHRoZVByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhlUHJvbWlzZS5zdWNjZXNzKHRoZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGVQcm9taXNlLmZhaWx1cmUoXCJObyBFWElGIGhlYWRlciB0byBiZSBmb3VuZCFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhlUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRBcHAxT2Zmc2V0KCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgcXEucmVhZEJsb2JUb0hleChmaWxlT3JCbG9iLCAwLCA2KS50aGVuKGZ1bmN0aW9uKGhleCkge1xuICAgICAgICAgICAgICAgIGlmIChoZXguaW5kZXhPZihcImZmZDhcIikgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKFwiTm90IGEgdmFsaWQgSlBFRyFcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vla1RvQXBwMSgpLnRoZW4oZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3Mob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuZmFpbHVyZShlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oYXBwMVN0YXJ0KSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICBxcS5yZWFkQmxvYlRvSGV4KGZpbGVPckJsb2IsIGFwcDFTdGFydCArIDEwLCAyKS50aGVuKGZ1bmN0aW9uKGhleCkge1xuICAgICAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcyhoZXggPT09IFwiNDk0OVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGlyRW50cnlDb3VudChhcHAxU3RhcnQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgcXEucmVhZEJsb2JUb0hleChmaWxlT3JCbG9iLCBhcHAxU3RhcnQgKyAxOCwgMikudGhlbihmdW5jdGlvbihoZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnN1Y2Nlc3MocGFyc2VMaXR0bGVFbmRpYW4oaGV4KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKHBhcnNlSW50KGhleCwgMTYpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldElmZChhcHAxU3RhcnQsIGRpckVudHJpZXMpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBhcHAxU3RhcnQgKyAyMCwgYnl0ZXMgPSBkaXJFbnRyaWVzICogMTI7XG4gICAgICAgICAgICByZXR1cm4gcXEucmVhZEJsb2JUb0hleChmaWxlT3JCbG9iLCBvZmZzZXQsIGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXREaXJFbnRyaWVzKGlmZEhleCkge1xuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSBbXSwgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgKyAyNCA8PSBpZmRIZXgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKGlmZEhleC5zbGljZShvZmZzZXQsIG9mZnNldCArIDI0KSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0VGFnVmFsdWVzKGxpdHRsZUVuZGlhbiwgZGlyRW50cmllcykge1xuICAgICAgICAgICAgdmFyIFRBR19WQUxfT0ZGU0VUID0gMTYsIHRhZ3NUb0ZpbmQgPSBxcS5leHRlbmQoW10sIFRBR19JRFMpLCB2YWxzID0ge307XG4gICAgICAgICAgICBxcS5lYWNoKGRpckVudHJpZXMsIGZ1bmN0aW9uKGlkeCwgZW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWRIZXggPSBlbnRyeS5zbGljZSgwLCA0KSwgaWQgPSBsaXR0bGVFbmRpYW4gPyBwYXJzZUxpdHRsZUVuZGlhbihpZEhleCkgOiBwYXJzZUludChpZEhleCwgMTYpLCB0YWdzVG9GaW5kSWR4ID0gdGFnc1RvRmluZC5pbmRleE9mKGlkKSwgdGFnVmFsSGV4LCB0YWdOYW1lLCB0YWdWYWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ3NUb0ZpbmRJZHggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lID0gVEFHX0lORk9baWRdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRhZ1ZhbExlbmd0aCA9IFRBR19JTkZPW2lkXS5ieXRlcztcbiAgICAgICAgICAgICAgICAgICAgdGFnVmFsSGV4ID0gZW50cnkuc2xpY2UoVEFHX1ZBTF9PRkZTRVQsIFRBR19WQUxfT0ZGU0VUICsgdGFnVmFsTGVuZ3RoICogMik7XG4gICAgICAgICAgICAgICAgICAgIHZhbHNbdGFnTmFtZV0gPSBsaXR0bGVFbmRpYW4gPyBwYXJzZUxpdHRsZUVuZGlhbih0YWdWYWxIZXgpIDogcGFyc2VJbnQodGFnVmFsSGV4LCAxNik7XG4gICAgICAgICAgICAgICAgICAgIHRhZ3NUb0ZpbmQuc3BsaWNlKHRhZ3NUb0ZpbmRJZHgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGFnc1RvRmluZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHM7XG4gICAgICAgIH1cbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IHFxLlByb21pc2UoKSwgb25QYXJzZUZhaWx1cmUgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJFWElGIGhlYWRlciBwYXJzZSBmYWlsZWQ6ICd7fScgXCIsIG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmZhaWx1cmUobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBnZXRBcHAxT2Zmc2V0KCkudGhlbihmdW5jdGlvbihhcHAxT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJNb3ZpbmcgZm9yd2FyZCB3aXRoIEVYSUYgaGVhZGVyIHBhcnNpbmcgZm9yICd7fSdcIiwgZmlsZU9yQmxvYi5uYW1lID09PSB1bmRlZmluZWQgPyBcImJsb2JcIiA6IGZpbGVPckJsb2IubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBpc0xpdHRsZUVuZGlhbihhcHAxT2Zmc2V0KS50aGVuKGZ1bmN0aW9uKGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKHFxLmZvcm1hdChcIkVYSUYgQnl0ZSBvcmRlciBpcyB7fSBlbmRpYW5cIiwgbGl0dGxlRW5kaWFuID8gXCJsaXR0bGVcIiA6IFwiYmlnXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldERpckVudHJ5Q291bnQoYXBwMU9mZnNldCwgbGl0dGxlRW5kaWFuKS50aGVuKGZ1bmN0aW9uKGRpckVudHJ5Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiRm91bmQge30gQVBQMSBkaXJlY3RvcnkgZW50cmllc1wiLCBkaXJFbnRyeUNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SWZkKGFwcDFPZmZzZXQsIGRpckVudHJ5Q291bnQpLnRoZW4oZnVuY3Rpb24oaWZkSGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXJFbnRyaWVzID0gZ2V0RGlyRW50cmllcyhpZmRIZXgpLCB0YWdWYWx1ZXMgPSBnZXRUYWdWYWx1ZXMobGl0dGxlRW5kaWFuLCBkaXJFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFwiU3VjY2Vzc2Z1bGx5IHBhcnNlZCBzb21lIEVYSUYgdGFnc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnN1Y2Nlc3ModGFnVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBvblBhcnNlRmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBvblBhcnNlRmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG9uUGFyc2VGYWlsdXJlKTtcbiAgICAgICAgICAgICAgICB9LCBvblBhcnNlRmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3Rlc3RpbmcgPSB7fTtcbiAgICAgICAgdGhpcy5fdGVzdGluZy5wYXJzZUxpdHRsZUVuZGlhbiA9IHBhcnNlTGl0dGxlRW5kaWFuO1xuICAgIH07XG4gICAgcXEuSWRlbnRpZnkgPSBmdW5jdGlvbihmaWxlT3JCbG9iLCBsb2cpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmlhYmxlKG1hZ2ljQnl0ZXMsIHF1ZXN0aW9uYWJsZUJ5dGVzKSB7XG4gICAgICAgICAgICB2YXIgaWRlbnRpZmlhYmxlID0gZmFsc2UsIG1hZ2ljQnl0ZXNFbnRyaWVzID0gW10uY29uY2F0KG1hZ2ljQnl0ZXMpO1xuICAgICAgICAgICAgcXEuZWFjaChtYWdpY0J5dGVzRW50cmllcywgZnVuY3Rpb24oaWR4LCBtYWdpY0J5dGVzQXJyYXlFbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmIChxdWVzdGlvbmFibGVCeXRlcy5pbmRleE9mKG1hZ2ljQnl0ZXNBcnJheUVudHJ5KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZmlhYmxlO1xuICAgICAgICB9XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBpc1ByZXZpZXdhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGlkZW50aWZpZXIgPSBuZXcgcXEuUHJvbWlzZSgpLCBwcmV2aWV3YWJsZSA9IGZhbHNlLCBuYW1lID0gZmlsZU9yQmxvYi5uYW1lID09PSB1bmRlZmluZWQgPyBcImJsb2JcIiA6IGZpbGVPckJsb2IubmFtZTtcbiAgICAgICAgICAgICAgICBsb2cocXEuZm9ybWF0KFwiQXR0ZW1wdGluZyB0byBkZXRlcm1pbmUgaWYge30gY2FuIGJlIHJlbmRlcmVkIGluIHRoaXMgYnJvd3NlclwiLCBuYW1lKSk7XG4gICAgICAgICAgICAgICAgbG9nKFwiRmlyc3QgcGFzczogY2hlY2sgdHlwZSBhdHRyaWJ1dGUgb2YgYmxvYiBvYmplY3QuXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUHJldmlld2FibGVTeW5jKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiU2Vjb25kIHBhc3M6IGNoZWNrIGZvciBtYWdpYyBieXRlcyBpbiBmaWxlIGhlYWRlci5cIik7XG4gICAgICAgICAgICAgICAgICAgIHFxLnJlYWRCbG9iVG9IZXgoZmlsZU9yQmxvYiwgMCwgNCkudGhlbihmdW5jdGlvbihoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFxLmVhY2goc2VsZi5QUkVWSUVXQUJMRV9NSU1FX1RZUEVTLCBmdW5jdGlvbihtaW1lLCBieXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0lkZW50aWZpYWJsZShieXRlcywgaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWltZSAhPT0gXCJpbWFnZS90aWZmXCIgfHwgcXEuc3VwcG9ydGVkRmVhdHVyZXMudGlmZlByZXZpZXdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyLnN1Y2Nlc3MobWltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKHFxLmZvcm1hdChcIid7fScgaXMge30gYWJsZSB0byBiZSByZW5kZXJlZCBpbiB0aGlzIGJyb3dzZXJcIiwgbmFtZSwgcHJldmlld2FibGUgPyBcIlwiIDogXCJOT1RcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2aWV3YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcIkVycm9yIHJlYWRpbmcgZmlsZSB3LyBuYW1lICdcIiArIG5hbWUgKyBcIicuICBOb3QgYWJsZSB0byBiZSByZW5kZXJlZCBpbiB0aGlzIGJyb3dzZXIuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllci5mYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1ByZXZpZXdhYmxlU3luYzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVNaW1lID0gZmlsZU9yQmxvYi50eXBlLCBpc1JlY29nbml6ZWRJbWFnZSA9IHFxLmluZGV4T2YoT2JqZWN0LmtleXModGhpcy5QUkVWSUVXQUJMRV9NSU1FX1RZUEVTKSwgZmlsZU1pbWUpID49IDAsIHByZXZpZXdhYmxlID0gZmFsc2UsIG5hbWUgPSBmaWxlT3JCbG9iLm5hbWUgPT09IHVuZGVmaW5lZCA/IFwiYmxvYlwiIDogZmlsZU9yQmxvYi5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlY29nbml6ZWRJbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU1pbWUgPT09IFwiaW1hZ2UvdGlmZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3YWJsZSA9IHFxLnN1cHBvcnRlZEZlYXR1cmVzLnRpZmZQcmV2aWV3cztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpZXdhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAhcHJldmlld2FibGUgJiYgbG9nKG5hbWUgKyBcIiBpcyBub3QgcHJldmlld2FibGUgaW4gdGhpcyBicm93c2VyIHBlciB0aGUgYmxvYidzIHR5cGUgYXR0clwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlld2FibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuSWRlbnRpZnkucHJvdG90eXBlLlBSRVZJRVdBQkxFX01JTUVfVFlQRVMgPSB7XG4gICAgICAgIFwiaW1hZ2UvanBlZ1wiOiBcImZmZDhmZlwiLFxuICAgICAgICBcImltYWdlL2dpZlwiOiBcIjQ3NDk0NlwiLFxuICAgICAgICBcImltYWdlL3BuZ1wiOiBcIjg5NTA0ZVwiLFxuICAgICAgICBcImltYWdlL2JtcFwiOiBcIjQyNGRcIixcbiAgICAgICAgXCJpbWFnZS90aWZmXCI6IFsgXCI0OTQ5MmEwMFwiLCBcIjRkNGQwMDJhXCIgXVxuICAgIH07XG4gICAgcXEuSW1hZ2VWYWxpZGF0aW9uID0gZnVuY3Rpb24oYmxvYiwgbG9nKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBmdW5jdGlvbiBoYXNOb25aZXJvTGltaXRzKGxpbWl0cykge1xuICAgICAgICAgICAgdmFyIGF0TGVhc3RPbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHFxLmVhY2gobGltaXRzLCBmdW5jdGlvbihsaW1pdCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYXRMZWFzdE9uZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRXaWR0aEhlaWdodCgpIHtcbiAgICAgICAgICAgIHZhciBzaXplRGV0ZXJtaW5hdGlvbiA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICBuZXcgcXEuSWRlbnRpZnkoYmxvYiwgbG9nKS5pc1ByZXZpZXdhYmxlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKSwgdXJsID0gd2luZG93LlVSTCAmJiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCA/IHdpbmRvdy5VUkwgOiB3aW5kb3cud2Via2l0VVJMICYmIHdpbmRvdy53ZWJraXRVUkwuY3JlYXRlT2JqZWN0VVJMID8gd2luZG93LndlYmtpdFVSTCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coXCJDYW5ub3QgZGV0ZXJtaW5lIGRpbWVuc2lvbnMgZm9yIGltYWdlLiAgTWF5IGJlIHRvbyBsYXJnZS5cIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVEZXRlcm1pbmF0aW9uLmZhaWx1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplRGV0ZXJtaW5hdGlvbi5zdWNjZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gdXJsLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2coXCJObyBjcmVhdGVPYmplY3RVUkwgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGdlbmVyYXRlIGltYWdlIFVSTCFcIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZURldGVybWluYXRpb24uZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNpemVEZXRlcm1pbmF0aW9uLmZhaWx1cmUpO1xuICAgICAgICAgICAgcmV0dXJuIHNpemVEZXRlcm1pbmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEZhaWxpbmdMaW1pdChsaW1pdHMsIGRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgIHZhciBmYWlsaW5nTGltaXQ7XG4gICAgICAgICAgICBxcS5lYWNoKGxpbWl0cywgZnVuY3Rpb24obGltaXROYW1lLCBsaW1pdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0VmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW1pdE1hdGNoZXIgPSAvKG1heHxtaW4pKFdpZHRofEhlaWdodCkvLmV4ZWMobGltaXROYW1lKSwgZGltZW5zaW9uUHJvcE5hbWUgPSBsaW1pdE1hdGNoZXJbMl0uY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBsaW1pdE1hdGNoZXJbMl0uc2xpY2UoMSksIGFjdHVhbFZhbHVlID0gZGltZW5zaW9uc1tkaW1lbnNpb25Qcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobGltaXRNYXRjaGVyWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1pblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdHVhbFZhbHVlIDwgbGltaXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxpbmdMaW1pdCA9IGxpbWl0TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3R1YWxWYWx1ZSA+IGxpbWl0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsaW5nTGltaXQgPSBsaW1pdE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWlsaW5nTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IGZ1bmN0aW9uKGxpbWl0cykge1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRpb25FZmZvcnQgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgbG9nKFwiQXR0ZW1wdGluZyB0byB2YWxpZGF0ZSBpbWFnZS5cIik7XG4gICAgICAgICAgICBpZiAoaGFzTm9uWmVyb0xpbWl0cyhsaW1pdHMpKSB7XG4gICAgICAgICAgICAgICAgZ2V0V2lkdGhIZWlnaHQoKS50aGVuKGZ1bmN0aW9uKGRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhaWxpbmdMaW1pdCA9IGdldEZhaWxpbmdMaW1pdChsaW1pdHMsIGRpbWVuc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbGluZ0xpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRWZmb3J0LmZhaWx1cmUoZmFpbGluZ0xpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FZmZvcnQuc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdmFsaWRhdGlvbkVmZm9ydC5zdWNjZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbkVmZm9ydC5zdWNjZXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGlvbkVmZm9ydDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHFxLlNlc3Npb24gPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGVuZHBvaW50OiBudWxsLFxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgY29yczoge30sXG4gICAgICAgICAgICBhZGRGaWxlUmVjb3JkOiBmdW5jdGlvbihzZXNzaW9uRGF0YSkge30sXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIGxldmVsKSB7fVxuICAgICAgICB9O1xuICAgICAgICBxcS5leHRlbmQob3B0aW9ucywgc3BlYywgdHJ1ZSk7XG4gICAgICAgIGZ1bmN0aW9uIGlzSnNvblJlc3BvbnNlVmFsaWQocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChxcS5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5sb2coXCJTZXNzaW9uIHJlc3BvbnNlIGlzIG5vdCBhbiBhcnJheS5cIiwgXCJlcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVGaWxlSXRlbXMoZmlsZUl0ZW1zLCBzdWNjZXNzLCB4aHJPclhkciwgcHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIHNvbWVJdGVtc0lnbm9yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSBzdWNjZXNzICYmIGlzSnNvblJlc3BvbnNlVmFsaWQoZmlsZUl0ZW1zKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChmaWxlSXRlbXMsIGZ1bmN0aW9uKGlkeCwgZmlsZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVJdGVtLnV1aWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29tZUl0ZW1zSWdub3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhxcS5mb3JtYXQoXCJTZXNzaW9uIHJlc3BvbnNlIGl0ZW0ge30gZGlkIG5vdCBpbmNsdWRlIGEgdmFsaWQgVVVJRCAtIGlnbm9yaW5nLlwiLCBpZHgpLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGVJdGVtLm5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29tZUl0ZW1zSWdub3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhxcS5mb3JtYXQoXCJTZXNzaW9uIHJlc3BvbnNlIGl0ZW0ge30gZGlkIG5vdCBpbmNsdWRlIGEgdmFsaWQgbmFtZSAtIGlnbm9yaW5nLlwiLCBpZHgpLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFkZEZpbGVSZWNvcmQoZmlsZUl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29tZUl0ZW1zSWdub3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2coZXJyLm1lc3NhZ2UsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZVtzdWNjZXNzICYmICFzb21lSXRlbXNJZ25vcmVkID8gXCJzdWNjZXNzXCIgOiBcImZhaWx1cmVcIl0oZmlsZUl0ZW1zLCB4aHJPclhkcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcmVmcmVzaEVmZm9ydCA9IG5ldyBxcS5Qcm9taXNlKCksIHJlZnJlc2hDb21wbGV0ZUNhbGxiYWNrID0gZnVuY3Rpb24ocmVzcG9uc2UsIHN1Y2Nlc3MsIHhock9yWGRyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRmlsZUl0ZW1zKHJlc3BvbnNlLCBzdWNjZXNzLCB4aHJPclhkciwgcmVmcmVzaEVmZm9ydCk7XG4gICAgICAgICAgICB9LCByZXF1ZXN0ZXJPcHRpb25zID0gcXEuZXh0ZW5kKHt9LCBvcHRpb25zKSwgcmVxdWVzdGVyID0gbmV3IHFxLlNlc3Npb25BamF4UmVxdWVzdGVyKHFxLmV4dGVuZChyZXF1ZXN0ZXJPcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZTogcmVmcmVzaENvbXBsZXRlQ2FsbGJhY2tcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJlcXVlc3Rlci5xdWVyeVNlcnZlcigpO1xuICAgICAgICAgICAgcmV0dXJuIHJlZnJlc2hFZmZvcnQ7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBxcS5TZXNzaW9uQWpheFJlcXVlc3RlciA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciByZXF1ZXN0ZXIsIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlbmRwb2ludDogbnVsbCxcbiAgICAgICAgICAgIGN1c3RvbUhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgIGNvcnM6IHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VuZENyZWRlbnRpYWxzOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKHJlc3BvbnNlLCBzdWNjZXNzLCB4aHJPclhkcikge30sXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKHN0ciwgbGV2ZWwpIHt9XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZChvcHRpb25zLCBzcGVjKTtcbiAgICAgICAgZnVuY3Rpb24gb25Db21wbGV0ZShpZCwgeGhyT3JYZHIsIGlzRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoeGhyT3JYZHIucmVzcG9uc2VUZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHFxLnBhcnNlSnNvbih4aHJPclhkci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvZyhcIlByb2JsZW0gcGFyc2luZyBzZXNzaW9uIHJlc3BvbnNlOiBcIiArIGVyci5tZXNzYWdlLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICBpc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUocmVzcG9uc2UsICFpc0Vycm9yLCB4aHJPclhkcik7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdGVyID0gcXEuZXh0ZW5kKHRoaXMsIG5ldyBxcS5BamF4UmVxdWVzdGVyKHtcbiAgICAgICAgICAgIGFjY2VwdEhlYWRlcjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB2YWxpZE1ldGhvZHM6IFsgXCJHRVRcIiBdLFxuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgZW5kcG9pbnRTdG9yZToge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmVuZHBvaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdXN0b21IZWFkZXJzOiBvcHRpb25zLmN1c3RvbUhlYWRlcnMsXG4gICAgICAgICAgICBsb2c6IG9wdGlvbnMubG9nLFxuICAgICAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZSxcbiAgICAgICAgICAgIGNvcnM6IG9wdGlvbnMuY29yc1xuICAgICAgICB9KSk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBxdWVyeVNlcnZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHFxLmV4dGVuZCh7fSwgb3B0aW9ucy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nKFwiU2Vzc2lvbiBxdWVyeSByZXF1ZXN0LlwiKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZXIuaW5pdFRyYW5zcG9ydChcInNlc3Npb25SZWZyZXNoXCIpLndpdGhQYXJhbXMocGFyYW1zKS53aXRoQ2FjaGVCdXN0ZXIoKS5zZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuU2NhbGVyID0gZnVuY3Rpb24oc3BlYywgbG9nKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGN1c3RvbVJlc2l6ZUZ1bmN0aW9uID0gc3BlYy5jdXN0b21SZXNpemVyLCBpbmNsdWRlT3JpZ2luYWwgPSBzcGVjLnNlbmRPcmlnaW5hbCwgb3JpZW50ID0gc3BlYy5vcmllbnQsIGRlZmF1bHRUeXBlID0gc3BlYy5kZWZhdWx0VHlwZSwgZGVmYXVsdFF1YWxpdHkgPSBzcGVjLmRlZmF1bHRRdWFsaXR5IC8gMTAwLCBmYWlsZWRUb1NjYWxlVGV4dCA9IHNwZWMuZmFpbHVyZVRleHQsIGluY2x1ZGVFeGlmID0gc3BlYy5pbmNsdWRlRXhpZiwgc2l6ZXMgPSB0aGlzLl9nZXRTb3J0ZWRTaXplcyhzcGVjLnNpemVzKTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHFxLnN1cHBvcnRlZEZlYXR1cmVzLnNjYWxpbmcgJiYgc2l6ZXMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgIGdldEZpbGVSZWNvcmRzOiBmdW5jdGlvbihvcmlnaW5hbEZpbGVVdWlkLCBvcmlnaW5hbEZpbGVOYW1lLCBvcmlnaW5hbEJsb2JPckJsb2JEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCByZWNvcmRzID0gW10sIG9yaWdpbmFsQmxvYiA9IG9yaWdpbmFsQmxvYk9yQmxvYkRhdGEuYmxvYiA/IG9yaWdpbmFsQmxvYk9yQmxvYkRhdGEuYmxvYiA6IG9yaWdpbmFsQmxvYk9yQmxvYkRhdGEsIGlkZW50aWZpZXIgPSBuZXcgcXEuSWRlbnRpZnkob3JpZ2luYWxCbG9iLCBsb2cpO1xuICAgICAgICAgICAgICAgIGlmIChpZGVudGlmaWVyLmlzUHJldmlld2FibGVTeW5jKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChzaXplcywgZnVuY3Rpb24oaWR4LCBzaXplUmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0cHV0VHlwZSA9IHNlbGYuX2RldGVybWluZU91dHB1dFR5cGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRUeXBlOiBkZWZhdWx0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRUeXBlOiBzaXplUmVjb3JkLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmVHlwZTogb3JpZ2luYWxCbG9iLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dWlkOiBxcS5nZXRVbmlxdWVJZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNlbGYuX2dldE5hbWUob3JpZ2luYWxGaWxlTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzaXplUmVjb3JkLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG91dHB1dFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZlR5cGU6IG9yaWdpbmFsQmxvYi50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvYjogbmV3IHFxLkJsb2JQcm94eShvcmlnaW5hbEJsb2IsIHFxLmJpbmQoc2VsZi5fZ2VuZXJhdGVTY2FsZWRJbWFnZSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21SZXNpemVGdW5jdGlvbjogY3VzdG9tUmVzaXplRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFNpemU6IHNpemVSZWNvcmQubWF4U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZW50OiBvcmllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG91dHB1dFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YWxpdHk6IGRlZmF1bHRRdWFsaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWRUZXh0OiBmYWlsZWRUb1NjYWxlVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUV4aWY6IGluY2x1ZGVFeGlmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2c6IGxvZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXVpZDogb3JpZ2luYWxGaWxlVXVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsRmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBvcmlnaW5hbEJsb2Iuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2I6IGluY2x1ZGVPcmlnaW5hbCA/IG9yaWdpbmFsQmxvYiA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWQ6IG9yaWdpbmFsRmlsZVV1aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBvcmlnaW5hbEZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogb3JpZ2luYWxCbG9iLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9iOiBvcmlnaW5hbEJsb2JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZU5ld0ZpbGU6IGZ1bmN0aW9uKGZpbGUsIG5hbWUsIHV1aWQsIHNpemUsIGZpbGVMaXN0LCBiYXRjaElkLCB1dWlkUGFyYW1OYW1lLCBhcGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGJ1dHRvbklkID0gZmlsZS5xcUJ1dHRvbklkIHx8IGZpbGUuYmxvYiAmJiBmaWxlLmJsb2IucXFCdXR0b25JZCwgc2NhbGVkSWRzID0gW10sIG9yaWdpbmFsSWQgPSBudWxsLCBhZGRGaWxlVG9IYW5kbGVyID0gYXBpLmFkZEZpbGVUb0hhbmRsZXIsIHVwbG9hZERhdGEgPSBhcGkudXBsb2FkRGF0YSwgcGFyYW1zU3RvcmUgPSBhcGkucGFyYW1zU3RvcmUsIHByb3h5R3JvdXBJZCA9IHFxLmdldFVuaXF1ZUlkKCk7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChzZWxmLmdldEZpbGVSZWNvcmRzKHV1aWQsIG5hbWUsIGZpbGUpLCBmdW5jdGlvbihpZHgsIHJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvYlNpemUgPSByZWNvcmQuc2l6ZSwgaWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYmxvYiBpbnN0YW5jZW9mIHFxLkJsb2JQcm94eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvYlNpemUgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZCA9IHVwbG9hZERhdGEuYWRkRmlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dWlkOiByZWNvcmQudXVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJlY29yZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogYmxvYlNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXRjaElkOiBiYXRjaElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlHcm91cElkOiBwcm94eUdyb3VwSWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYmxvYiBpbnN0YW5jZW9mIHFxLkJsb2JQcm94eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJZCA9IGlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYmxvYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRmlsZVRvSGFuZGxlcihpZCwgcmVjb3JkLmJsb2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUxpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IHJlY29yZC5ibG9iXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZERhdGEuc2V0U3RhdHVzKGlkLCBxcS5zdGF0dXMuUkVKRUNURUQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChzY2FsZWRJZHMsIGZ1bmN0aW9uKGlkeCwgc2NhbGVkSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXFwYXJlbnR1dWlkOiB1cGxvYWREYXRhLnJldHJpZXZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG9yaWdpbmFsSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS51dWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFxcGFyZW50c2l6ZTogdXBsb2FkRGF0YS5yZXRyaWV2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBvcmlnaW5hbElkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1t1dWlkUGFyYW1OYW1lXSA9IHVwbG9hZERhdGEucmV0cmlldmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzY2FsZWRJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudXVpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZERhdGEuc2V0UGFyZW50SWQoc2NhbGVkSWQsIG9yaWdpbmFsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zU3RvcmUuYWRkUmVhZE9ubHkoc2NhbGVkSWQsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGVkSWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtW3V1aWRQYXJhbU5hbWVdID0gdXBsb2FkRGF0YS5yZXRyaWV2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBvcmlnaW5hbElkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudXVpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNTdG9yZS5hZGRSZWFkT25seShvcmlnaW5hbElkLCBwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHFxLmV4dGVuZChxcS5TY2FsZXIucHJvdG90eXBlLCB7XG4gICAgICAgIHNjYWxlSW1hZ2U6IGZ1bmN0aW9uKGlkLCBzcGVjcywgYXBpKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGlmICghcXEuc3VwcG9ydGVkRmVhdHVyZXMuc2NhbGluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBxcS5FcnJvcihcIlNjYWxpbmcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjYWxpbmdFZmZvcnQgPSBuZXcgcXEuUHJvbWlzZSgpLCBsb2cgPSBhcGkubG9nLCBmaWxlID0gYXBpLmdldEZpbGUoaWQpLCB1cGxvYWREYXRhID0gYXBpLnVwbG9hZERhdGEucmV0cmlldmUoe1xuICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgfSksIG5hbWUgPSB1cGxvYWREYXRhICYmIHVwbG9hZERhdGEubmFtZSwgdXVpZCA9IHVwbG9hZERhdGEgJiYgdXBsb2FkRGF0YS51dWlkLCBzY2FsaW5nT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBjdXN0b21SZXNpemVyOiBzcGVjcy5jdXN0b21SZXNpemVyLFxuICAgICAgICAgICAgICAgIHNlbmRPcmlnaW5hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgb3JpZW50OiBzcGVjcy5vcmllbnQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFR5cGU6IHNwZWNzLnR5cGUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0UXVhbGl0eTogc3BlY3MucXVhbGl0eSxcbiAgICAgICAgICAgICAgICBmYWlsZWRUb1NjYWxlVGV4dDogXCJVbmFibGUgdG8gc2NhbGVcIixcbiAgICAgICAgICAgICAgICBzaXplczogWyB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIG1heFNpemU6IHNwZWNzLm1heFNpemVcbiAgICAgICAgICAgICAgICB9IF1cbiAgICAgICAgICAgIH0sIHNjYWxlciA9IG5ldyBxcS5TY2FsZXIoc2NhbGluZ09wdGlvbnMsIGxvZyk7XG4gICAgICAgICAgICBpZiAoIXFxLlNjYWxlciB8fCAhcXEuc3VwcG9ydGVkRmVhdHVyZXMuaW1hZ2VQcmV2aWV3cyB8fCAhZmlsZSkge1xuICAgICAgICAgICAgICAgIHNjYWxpbmdFZmZvcnQuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIGxvZyhcIkNvdWxkIG5vdCBnZW5lcmF0ZSByZXF1ZXN0ZWQgc2NhbGVkIGltYWdlIGZvciBcIiArIGlkICsgXCIuICBcIiArIFwiU2NhbGluZyBpcyBlaXRoZXIgbm90IHBvc3NpYmxlIGluIHRoaXMgYnJvd3Nlciwgb3IgdGhlIGZpbGUgY291bGQgbm90IGJlIGxvY2F0ZWQuXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHFxLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSBzY2FsZXIuZ2V0RmlsZVJlY29yZHModXVpZCwgbmFtZSwgZmlsZSlbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLmJsb2IgaW5zdGFuY2VvZiBxcS5CbG9iUHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZC5ibG9iLmNyZWF0ZSgpLnRoZW4oc2NhbGluZ0VmZm9ydC5zdWNjZXNzLCBzY2FsaW5nRWZmb3J0LmZhaWx1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGlkICsgXCIgaXMgbm90IGEgc2NhbGFibGUgaW1hZ2UhXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsaW5nRWZmb3J0LmZhaWx1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NhbGluZ0VmZm9ydDtcbiAgICAgICAgfSxcbiAgICAgICAgX2RldGVybWluZU91dHB1dFR5cGU6IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RlZFR5cGUgPSBzcGVjLnJlcXVlc3RlZFR5cGUsIGRlZmF1bHRUeXBlID0gc3BlYy5kZWZhdWx0VHlwZSwgcmVmZXJlbmNlVHlwZSA9IHNwZWMucmVmVHlwZTtcbiAgICAgICAgICAgIGlmICghZGVmYXVsdFR5cGUgJiYgIXJlcXVlc3RlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmZXJlbmNlVHlwZSAhPT0gXCJpbWFnZS9qcGVnXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW1hZ2UvcG5nXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWZlcmVuY2VUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHFxLmluZGV4T2YoT2JqZWN0LmtleXMocXEuSWRlbnRpZnkucHJvdG90eXBlLlBSRVZJRVdBQkxFX01JTUVfVFlQRVMpLCByZXF1ZXN0ZWRUeXBlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RlZFR5cGUgPT09IFwiaW1hZ2UvdGlmZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxcS5zdXBwb3J0ZWRGZWF0dXJlcy50aWZmUHJldmlld3MgPyByZXF1ZXN0ZWRUeXBlIDogZGVmYXVsdFR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0TmFtZTogZnVuY3Rpb24ob3JpZ2luYWxOYW1lLCBzY2FsZWRWZXJzaW9uUHJvcGVydGllcykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICB2YXIgc3RhcnRPZkV4dCA9IG9yaWdpbmFsTmFtZS5sYXN0SW5kZXhPZihcIi5cIiksIHZlcnNpb25UeXBlID0gc2NhbGVkVmVyc2lvblByb3BlcnRpZXMudHlwZSB8fCBcImltYWdlL3BuZ1wiLCByZWZlcmVuY2VUeXBlID0gc2NhbGVkVmVyc2lvblByb3BlcnRpZXMucmVmVHlwZSwgc2NhbGVkTmFtZSA9IFwiXCIsIHNjYWxlZEV4dCA9IHFxLmdldEV4dGVuc2lvbihvcmlnaW5hbE5hbWUpLCBuYW1lQXBwZW5kYWdlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChzY2FsZWRWZXJzaW9uUHJvcGVydGllcy5uYW1lICYmIHNjYWxlZFZlcnNpb25Qcm9wZXJ0aWVzLm5hbWUudHJpbSgpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5hbWVBcHBlbmRhZ2UgPSBcIiAoXCIgKyBzY2FsZWRWZXJzaW9uUHJvcGVydGllcy5uYW1lICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRPZkV4dCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc2NhbGVkTmFtZSA9IG9yaWdpbmFsTmFtZS5zdWJzdHIoMCwgc3RhcnRPZkV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZVR5cGUgIT09IHZlcnNpb25UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlZEV4dCA9IHZlcnNpb25UeXBlLnNwbGl0KFwiL1wiKVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NhbGVkTmFtZSArPSBuYW1lQXBwZW5kYWdlICsgXCIuXCIgKyBzY2FsZWRFeHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYWxlZE5hbWUgPSBvcmlnaW5hbE5hbWUgKyBuYW1lQXBwZW5kYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNjYWxlZE5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRTb3J0ZWRTaXplczogZnVuY3Rpb24oc2l6ZXMpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgc2l6ZXMgPSBxcS5leHRlbmQoW10sIHNpemVzKTtcbiAgICAgICAgICAgIHJldHVybiBzaXplcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5tYXhTaXplID4gYi5tYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYS5tYXhTaXplIDwgYi5tYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dlbmVyYXRlU2NhbGVkSW1hZ2U6IGZ1bmN0aW9uKHNwZWMsIHNvdXJjZUZpbGUpIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBjdXN0b21SZXNpemVGdW5jdGlvbiA9IHNwZWMuY3VzdG9tUmVzaXplRnVuY3Rpb24sIGxvZyA9IHNwZWMubG9nLCBtYXhTaXplID0gc3BlYy5tYXhTaXplLCBvcmllbnQgPSBzcGVjLm9yaWVudCwgdHlwZSA9IHNwZWMudHlwZSwgcXVhbGl0eSA9IHNwZWMucXVhbGl0eSwgZmFpbGVkVGV4dCA9IHNwZWMuZmFpbGVkVGV4dCwgaW5jbHVkZUV4aWYgPSBzcGVjLmluY2x1ZGVFeGlmICYmIHNvdXJjZUZpbGUudHlwZSA9PT0gXCJpbWFnZS9qcGVnXCIgJiYgdHlwZSA9PT0gXCJpbWFnZS9qcGVnXCIsIHNjYWxpbmdFZmZvcnQgPSBuZXcgcXEuUHJvbWlzZSgpLCBpbWFnZUdlbmVyYXRvciA9IG5ldyBxcS5JbWFnZUdlbmVyYXRvcihsb2cpLCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgbG9nKFwiQXR0ZW1wdGluZyB0byBnZW5lcmF0ZSBzY2FsZWQgdmVyc2lvbiBmb3IgXCIgKyBzb3VyY2VGaWxlLm5hbWUpO1xuICAgICAgICAgICAgaW1hZ2VHZW5lcmF0b3IuZ2VuZXJhdGUoc291cmNlRmlsZSwgY2FudmFzLCB7XG4gICAgICAgICAgICAgICAgbWF4U2l6ZTogbWF4U2l6ZSxcbiAgICAgICAgICAgICAgICBvcmllbnQ6IG9yaWVudCxcbiAgICAgICAgICAgICAgICBjdXN0b21SZXNpemVGdW5jdGlvbjogY3VzdG9tUmVzaXplRnVuY3Rpb25cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlZEltYWdlRGF0YVVyaSA9IGNhbnZhcy50b0RhdGFVUkwodHlwZSwgcXVhbGl0eSksIHNpZ25hbFN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwiU3VjY2VzcyBnZW5lcmF0aW5nIHNjYWxlZCB2ZXJzaW9uIGZvciBcIiArIHNvdXJjZUZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9iID0gcXEuZGF0YVVyaVRvQmxvYihzY2FsZWRJbWFnZURhdGFVcmkpO1xuICAgICAgICAgICAgICAgICAgICBzY2FsaW5nRWZmb3J0LnN1Y2Nlc3MoYmxvYik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZUV4aWYpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5zZXJ0RXhpZkhlYWRlcihzb3VyY2VGaWxlLCBzY2FsZWRJbWFnZURhdGFVcmksIGxvZykudGhlbihmdW5jdGlvbihzY2FsZWRJbWFnZURhdGFVcmlXaXRoRXhpZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkSW1hZ2VEYXRhVXJpID0gc2NhbGVkSW1hZ2VEYXRhVXJpV2l0aEV4aWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWxTdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFwiUHJvYmxlbSBpbnNlcnRpbmcgRVhJRiBoZWFkZXIgaW50byBzY2FsZWQgaW1hZ2UuICBVc2luZyBzY2FsZWQgaW1hZ2Ugdy9vdXQgRVhJRiBkYXRhLlwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsU3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWxTdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiRmFpbGVkIGF0dGVtcHQgdG8gZ2VuZXJhdGUgc2NhbGVkIHZlcnNpb24gZm9yIFwiICsgc291cmNlRmlsZS5uYW1lLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHNjYWxpbmdFZmZvcnQuZmFpbHVyZShmYWlsZWRUZXh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxpbmdFZmZvcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIF9pbnNlcnRFeGlmSGVhZGVyOiBmdW5jdGlvbihvcmlnaW5hbEltYWdlLCBzY2FsZWRJbWFnZURhdGFVcmksIGxvZykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKSwgaW5zZXJ0aW9uRWZmb3J0ID0gbmV3IHFxLlByb21pc2UoKSwgb3JpZ2luYWxJbWFnZURhdGFVcmkgPSBcIlwiO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsSW1hZ2VEYXRhVXJpID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25FZmZvcnQuc3VjY2VzcyhxcS5FeGlmUmVzdG9yZXIucmVzdG9yZShvcmlnaW5hbEltYWdlRGF0YVVyaSwgc2NhbGVkSW1hZ2VEYXRhVXJpKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBsb2coXCJQcm9ibGVtIHJlYWRpbmcgXCIgKyBvcmlnaW5hbEltYWdlLm5hbWUgKyBcIiBkdXJpbmcgYXR0ZW1wdCB0byB0cmFuc2ZlciBFWElGIGRhdGEgdG8gc2NhbGVkIHZlcnNpb24uXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgaW5zZXJ0aW9uRWZmb3J0LmZhaWx1cmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChvcmlnaW5hbEltYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnRpb25FZmZvcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIF9kYXRhVXJpVG9CbG9iOiBmdW5jdGlvbihkYXRhVXJpKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIHZhciBieXRlU3RyaW5nLCBtaW1lU3RyaW5nLCBhcnJheUJ1ZmZlciwgaW50QXJyYXk7XG4gICAgICAgICAgICBpZiAoZGF0YVVyaS5zcGxpdChcIixcIilbMF0uaW5kZXhPZihcImJhc2U2NFwiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZVN0cmluZyA9IGF0b2IoZGF0YVVyaS5zcGxpdChcIixcIilbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBieXRlU3RyaW5nID0gZGVjb2RlVVJJKGRhdGFVcmkuc3BsaXQoXCIsXCIpWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pbWVTdHJpbmcgPSBkYXRhVXJpLnNwbGl0KFwiLFwiKVswXS5zcGxpdChcIjpcIilbMV0uc3BsaXQoXCI7XCIpWzBdO1xuICAgICAgICAgICAgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgICAgICAgICAgaW50QXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICBxcS5lYWNoKGJ5dGVTdHJpbmcsIGZ1bmN0aW9uKGlkeCwgY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgaW50QXJyYXlbaWR4XSA9IGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQmxvYihhcnJheUJ1ZmZlciwgbWltZVN0cmluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9jcmVhdGVCbG9iOiBmdW5jdGlvbihkYXRhLCBtaW1lKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIHZhciBCbG9iQnVpbGRlciA9IHdpbmRvdy5CbG9iQnVpbGRlciB8fCB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8IHdpbmRvdy5NU0Jsb2JCdWlsZGVyLCBibG9iQnVpbGRlciA9IEJsb2JCdWlsZGVyICYmIG5ldyBCbG9iQnVpbGRlcigpO1xuICAgICAgICAgICAgaWYgKGJsb2JCdWlsZGVyKSB7XG4gICAgICAgICAgICAgICAgYmxvYkJ1aWxkZXIuYXBwZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9iQnVpbGRlci5nZXRCbG9iKG1pbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2IoWyBkYXRhIF0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbWltZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcXEuRXhpZlJlc3RvcmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBFeGlmUmVzdG9yZXIgPSB7fTtcbiAgICAgICAgRXhpZlJlc3RvcmVyLktFWV9TVFIgPSBcIkFCQ0RFRkdISUpLTE1OT1BcIiArIFwiUVJTVFVWV1hZWmFiY2RlZlwiICsgXCJnaGlqa2xtbm9wcXJzdHV2XCIgKyBcInd4eXowMTIzNDU2Nzg5Ky9cIiArIFwiPVwiO1xuICAgICAgICBFeGlmUmVzdG9yZXIuZW5jb2RlNjQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFwiXCIsIGNocjEsIGNocjIsIGNocjMgPSBcIlwiLCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0ID0gXCJcIiwgaSA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgICAgICAgICAgICAgY2hyMiA9IGlucHV0W2krK107XG4gICAgICAgICAgICAgICAgY2hyMyA9IGlucHV0W2krK107XG4gICAgICAgICAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgICAgICAgICBlbmMyID0gKGNocjEgJiAzKSA8PCA0IHwgY2hyMiA+PiA0O1xuICAgICAgICAgICAgICAgIGVuYzMgPSAoY2hyMiAmIDE1KSA8PCAyIHwgY2hyMyA+PiA2O1xuICAgICAgICAgICAgICAgIGVuYzQgPSBjaHIzICYgNjM7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGNocjIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTihjaHIzKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmM0ID0gNjQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jMSkgKyB0aGlzLktFWV9TVFIuY2hhckF0KGVuYzIpICsgdGhpcy5LRVlfU1RSLmNoYXJBdChlbmMzKSArIHRoaXMuS0VZX1NUUi5jaGFyQXQoZW5jNCk7XG4gICAgICAgICAgICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gXCJcIjtcbiAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICAgICAgRXhpZlJlc3RvcmVyLnJlc3RvcmUgPSBmdW5jdGlvbihvcmlnRmlsZUJhc2U2NCwgcmVzaXplZEZpbGVCYXNlNjQpIHtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZEJhc2U2NEhlYWRlciA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxcIjtcbiAgICAgICAgICAgIGlmICghb3JpZ0ZpbGVCYXNlNjQubWF0Y2goZXhwZWN0ZWRCYXNlNjRIZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc2l6ZWRGaWxlQmFzZTY0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJhd0ltYWdlID0gdGhpcy5kZWNvZGU2NChvcmlnRmlsZUJhc2U2NC5yZXBsYWNlKGV4cGVjdGVkQmFzZTY0SGVhZGVyLCBcIlwiKSk7XG4gICAgICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNsaWNlMlNlZ21lbnRzKHJhd0ltYWdlKTtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHRoaXMuZXhpZk1hbmlwdWxhdGlvbihyZXNpemVkRmlsZUJhc2U2NCwgc2VnbWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkQmFzZTY0SGVhZGVyICsgdGhpcy5lbmNvZGU2NChpbWFnZSk7XG4gICAgICAgIH07XG4gICAgICAgIEV4aWZSZXN0b3Jlci5leGlmTWFuaXB1bGF0aW9uID0gZnVuY3Rpb24ocmVzaXplZEZpbGVCYXNlNjQsIHNlZ21lbnRzKSB7XG4gICAgICAgICAgICB2YXIgZXhpZkFycmF5ID0gdGhpcy5nZXRFeGlmQXJyYXkoc2VnbWVudHMpLCBuZXdJbWFnZUFycmF5ID0gdGhpcy5pbnNlcnRFeGlmKHJlc2l6ZWRGaWxlQmFzZTY0LCBleGlmQXJyYXkpLCBhQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmV3SW1hZ2VBcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gYUJ1ZmZlcjtcbiAgICAgICAgfTtcbiAgICAgICAgRXhpZlJlc3RvcmVyLmdldEV4aWZBcnJheSA9IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG4gICAgICAgICAgICB2YXIgc2VnO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzZWdtZW50cy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgICAgIHNlZyA9IHNlZ21lbnRzW3hdO1xuICAgICAgICAgICAgICAgIGlmIChzZWdbMF0gPT0gMjU1ICYgc2VnWzFdID09IDIyNSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgRXhpZlJlc3RvcmVyLmluc2VydEV4aWYgPSBmdW5jdGlvbihyZXNpemVkRmlsZUJhc2U2NCwgZXhpZkFycmF5KSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2VEYXRhID0gcmVzaXplZEZpbGVCYXNlNjQucmVwbGFjZShcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsXCIsIFwiXCIpLCBidWYgPSB0aGlzLmRlY29kZTY0KGltYWdlRGF0YSksIHNlcGFyYXRlUG9pbnQgPSBidWYuaW5kZXhPZigyNTUsIDMpLCBtYWUgPSBidWYuc2xpY2UoMCwgc2VwYXJhdGVQb2ludCksIGF0byA9IGJ1Zi5zbGljZShzZXBhcmF0ZVBvaW50KSwgYXJyYXkgPSBtYWU7XG4gICAgICAgICAgICBhcnJheSA9IGFycmF5LmNvbmNhdChleGlmQXJyYXkpO1xuICAgICAgICAgICAgYXJyYXkgPSBhcnJheS5jb25jYXQoYXRvKTtcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfTtcbiAgICAgICAgRXhpZlJlc3RvcmVyLnNsaWNlMlNlZ21lbnRzID0gZnVuY3Rpb24ocmF3SW1hZ2VBcnJheSkge1xuICAgICAgICAgICAgdmFyIGhlYWQgPSAwLCBzZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocmF3SW1hZ2VBcnJheVtoZWFkXSA9PSAyNTUgJiByYXdJbWFnZUFycmF5W2hlYWQgKyAxXSA9PSAyMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyYXdJbWFnZUFycmF5W2hlYWRdID09IDI1NSAmIHJhd0ltYWdlQXJyYXlbaGVhZCArIDFdID09IDIxNikge1xuICAgICAgICAgICAgICAgICAgICBoZWFkICs9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHJhd0ltYWdlQXJyYXlbaGVhZCArIDJdICogMjU2ICsgcmF3SW1hZ2VBcnJheVtoZWFkICsgM10sIGVuZFBvaW50ID0gaGVhZCArIGxlbmd0aCArIDIsIHNlZyA9IHJhd0ltYWdlQXJyYXkuc2xpY2UoaGVhZCwgZW5kUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHNlZyk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWQgPSBlbmRQb2ludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhlYWQgPiByYXdJbWFnZUFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VnbWVudHM7XG4gICAgICAgIH07XG4gICAgICAgIEV4aWZSZXN0b3Jlci5kZWNvZGU2NCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gXCJcIiwgY2hyMSwgY2hyMiwgY2hyMyA9IFwiXCIsIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQgPSBcIlwiLCBpID0gMCwgYnVmID0gW107XG4gICAgICAgICAgICB2YXIgYmFzZTY0dGVzdCA9IC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZztcbiAgICAgICAgICAgIGlmIChiYXNlNjR0ZXN0LmV4ZWMoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgd2VyZSBpbnZhbGlkIGJhc2U2NCBjaGFyYWN0ZXJzIGluIHRoZSBpbnB1dCB0ZXh0LiAgXCIgKyBcIlZhbGlkIGJhc2U2NCBjaGFyYWN0ZXJzIGFyZSBBLVosIGEteiwgMC05LCAnKycsICcvJyxhbmQgJz0nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgXCJcIik7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgZW5jMSA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgICAgICAgICBlbmMyID0gdGhpcy5LRVlfU1RSLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICAgICAgICAgIGVuYzMgPSB0aGlzLktFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgICAgICAgICAgZW5jNCA9IHRoaXMuS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgICAgICAgICBjaHIxID0gZW5jMSA8PCAyIHwgZW5jMiA+PiA0O1xuICAgICAgICAgICAgICAgIGNocjIgPSAoZW5jMiAmIDE1KSA8PCA0IHwgZW5jMyA+PiAyO1xuICAgICAgICAgICAgICAgIGNocjMgPSAoZW5jMyAmIDMpIDw8IDYgfCBlbmM0O1xuICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKGNocjEpO1xuICAgICAgICAgICAgICAgIGlmIChlbmMzICE9IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKGNocjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW5jNCAhPSA2NCkge1xuICAgICAgICAgICAgICAgICAgICBidWYucHVzaChjaHIzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gXCJcIjtcbiAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEV4aWZSZXN0b3JlcjtcbiAgICB9KCk7XG4gICAgcXEuVG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBnZXRTaXplKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgcGVyRmlsZVByb2dyZXNzID0ge30sIHRvdGFsTG9hZGVkID0gMCwgdG90YWxTaXplID0gMCwgbGFzdExvYWRlZFNlbnQgPSAtMSwgbGFzdFRvdGFsU2VudCA9IC0xLCBjYWxsYmFja1Byb3h5ID0gZnVuY3Rpb24obG9hZGVkLCB0b3RhbCkge1xuICAgICAgICAgICAgaWYgKGxvYWRlZCAhPT0gbGFzdExvYWRlZFNlbnQgfHwgdG90YWwgIT09IGxhc3RUb3RhbFNlbnQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhsb2FkZWQsIHRvdGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RMb2FkZWRTZW50ID0gbG9hZGVkO1xuICAgICAgICAgICAgbGFzdFRvdGFsU2VudCA9IHRvdGFsO1xuICAgICAgICB9LCBub1JldHJ5YWJsZUZpbGVzID0gZnVuY3Rpb24oZmFpbGVkLCByZXRyeWFibGUpIHtcbiAgICAgICAgICAgIHZhciBub25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHFxLmVhY2goZmFpbGVkLCBmdW5jdGlvbihpZHgsIGZhaWxlZElkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHFxLmluZGV4T2YocmV0cnlhYmxlLCBmYWlsZWRJZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBub25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBub25lO1xuICAgICAgICB9LCBvbkNhbmNlbCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICB1cGRhdGVUb3RhbFByb2dyZXNzKGlkLCAtMSwgLTEpO1xuICAgICAgICAgICAgZGVsZXRlIHBlckZpbGVQcm9ncmVzc1tpZF07XG4gICAgICAgIH0sIG9uQWxsQ29tcGxldGUgPSBmdW5jdGlvbihzdWNjZXNzZnVsLCBmYWlsZWQsIHJldHJ5YWJsZSkge1xuICAgICAgICAgICAgaWYgKGZhaWxlZC5sZW5ndGggPT09IDAgfHwgbm9SZXRyeWFibGVGaWxlcyhmYWlsZWQsIHJldHJ5YWJsZSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja1Byb3h5KHRvdGFsU2l6ZSwgdG90YWxTaXplKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG9uTmV3ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gZ2V0U2l6ZShpZCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb3RhbFByb2dyZXNzKGlkLCAwLCBzaXplKTtcbiAgICAgICAgICAgICAgICBwZXJGaWxlUHJvZ3Jlc3NbaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiBzaXplXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdXBkYXRlVG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKGlkLCBuZXdMb2FkZWQsIG5ld1RvdGFsKSB7XG4gICAgICAgICAgICB2YXIgb2xkTG9hZGVkID0gcGVyRmlsZVByb2dyZXNzW2lkXSA/IHBlckZpbGVQcm9ncmVzc1tpZF0ubG9hZGVkIDogMCwgb2xkVG90YWwgPSBwZXJGaWxlUHJvZ3Jlc3NbaWRdID8gcGVyRmlsZVByb2dyZXNzW2lkXS50b3RhbCA6IDA7XG4gICAgICAgICAgICBpZiAobmV3TG9hZGVkID09PSAtMSAmJiBuZXdUb3RhbCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0b3RhbExvYWRlZCAtPSBvbGRMb2FkZWQ7XG4gICAgICAgICAgICAgICAgdG90YWxTaXplIC09IG9sZFRvdGFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3TG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTG9hZGVkICs9IG5ld0xvYWRlZCAtIG9sZExvYWRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBuZXdUb3RhbCAtIG9sZFRvdGFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrUHJveHkodG90YWxMb2FkZWQsIHRvdGFsU2l6ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBvbkFsbENvbXBsZXRlOiBvbkFsbENvbXBsZXRlLFxuICAgICAgICAgICAgb25TdGF0dXNDaGFuZ2U6IGZ1bmN0aW9uKGlkLCBvbGRTdGF0dXMsIG5ld1N0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0dXMgPT09IHFxLnN0YXR1cy5DQU5DRUxFRCB8fCBuZXdTdGF0dXMgPT09IHFxLnN0YXR1cy5SRUpFQ1RFRCkge1xuICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbChpZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdTdGF0dXMgPT09IHFxLnN0YXR1cy5TVUJNSVRUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTmV3KGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25JbmRpdmlkdWFsUHJvZ3Jlc3M6IGZ1bmN0aW9uKGlkLCBsb2FkZWQsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVG90YWxQcm9ncmVzcyhpZCwgbG9hZGVkLCB0b3RhbCk7XG4gICAgICAgICAgICAgICAgcGVyRmlsZVByb2dyZXNzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiBsb2FkZWQsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25OZXdTaXplOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIG9uTmV3KGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcGVyRmlsZVByb2dyZXNzID0ge307XG4gICAgICAgICAgICAgICAgdG90YWxMb2FkZWQgPSAwO1xuICAgICAgICAgICAgICAgIHRvdGFsU2l6ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuUGFzdGVTdXBwb3J0ID0gZnVuY3Rpb24obykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIG9wdGlvbnMsIGRldGFjaFBhc3RlSGFuZGxlcjtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHRhcmdldEVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIGxldmVsKSB7fSxcbiAgICAgICAgICAgICAgICBwYXN0ZVJlY2VpdmVkOiBmdW5jdGlvbihibG9iKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBpc0ltYWdlKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnR5cGUgJiYgaXRlbS50eXBlLmluZGV4T2YoXCJpbWFnZS9cIikgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJQYXN0ZUhhbmRsZXIoKSB7XG4gICAgICAgICAgICBkZXRhY2hQYXN0ZUhhbmRsZXIgPSBxcShvcHRpb25zLnRhcmdldEVsZW1lbnQpLmF0dGFjaChcInBhc3RlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaXBib2FyZERhdGEgPSBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgICAgICAgICAgICAgIGlmIChjbGlwYm9hcmREYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxLmVhY2goY2xpcGJvYXJkRGF0YS5pdGVtcywgZnVuY3Rpb24oaWR4LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbWFnZShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9iID0gaXRlbS5nZXRBc0ZpbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrcy5wYXN0ZVJlY2VpdmVkKGJsb2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bnJlZ2lzdGVyUGFzdGVIYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKGRldGFjaFBhc3RlSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRldGFjaFBhc3RlSGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHFxLmV4dGVuZChvcHRpb25zLCBvKTtcbiAgICAgICAgcmVnaXN0ZXJQYXN0ZUhhbmRsZXIoKTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyUGFzdGVIYW5kbGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcXEuRm9ybVN1cHBvcnQgPSBmdW5jdGlvbihvcHRpb25zLCBzdGFydFVwbG9hZCwgbG9nKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGludGVyY2VwdFN1Ym1pdCA9IG9wdGlvbnMuaW50ZXJjZXB0U3VibWl0LCBmb3JtRWwgPSBvcHRpb25zLmVsZW1lbnQsIGF1dG9VcGxvYWQgPSBvcHRpb25zLmF1dG9VcGxvYWQ7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBuZXdFbmRwb2ludDogbnVsbCxcbiAgICAgICAgICAgIG5ld0F1dG9VcGxvYWQ6IGF1dG9VcGxvYWQsXG4gICAgICAgICAgICBhdHRhY2hlZFRvRm9ybTogZmFsc2UsXG4gICAgICAgICAgICBnZXRGb3JtSW5wdXRzQXNPYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JtRWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2Zvcm0yT2JqKGZvcm1FbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBkZXRlcm1pbmVOZXdFbmRwb2ludChmb3JtRWwpIHtcbiAgICAgICAgICAgIGlmIChmb3JtRWwuZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5uZXdFbmRwb2ludCA9IGZvcm1FbC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtKGZvcm1FbCwgbmF0aXZlU3VibWl0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybUVsLmNoZWNrVmFsaWRpdHkgJiYgIWZvcm1FbC5jaGVja1ZhbGlkaXR5KCkpIHtcbiAgICAgICAgICAgICAgICBsb2coXCJGb3JtIGRpZCBub3QgcGFzcyB2YWxpZGF0aW9uIGNoZWNrcyAtIHdpbGwgbm90IHVwbG9hZC5cIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBuYXRpdmVTdWJtaXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVVcGxvYWRPblN1Ym1pdChmb3JtRWwpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVTdWJtaXQgPSBmb3JtRWwuc3VibWl0O1xuICAgICAgICAgICAgcXEoZm9ybUVsKS5hdHRhY2goXCJzdWJtaXRcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUZvcm0oZm9ybUVsLCBuYXRpdmVTdWJtaXQpICYmIHN0YXJ0VXBsb2FkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcm1FbC5zdWJtaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUZvcm0oZm9ybUVsLCBuYXRpdmVTdWJtaXQpICYmIHN0YXJ0VXBsb2FkKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRldGVybWluZUZvcm1FbChmb3JtRWwpIHtcbiAgICAgICAgICAgIGlmIChmb3JtRWwpIHtcbiAgICAgICAgICAgICAgICBpZiAocXEuaXNTdHJpbmcoZm9ybUVsKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb3JtRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm9ybUVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIkF0dGFjaGluZyB0byBmb3JtIGVsZW1lbnQuXCIpO1xuICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmVOZXdFbmRwb2ludChmb3JtRWwpO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcmNlcHRTdWJtaXQgJiYgbWF5YmVVcGxvYWRPblN1Ym1pdChmb3JtRWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtRWw7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybUVsID0gZGV0ZXJtaW5lRm9ybUVsKGZvcm1FbCk7XG4gICAgICAgIHRoaXMuYXR0YWNoZWRUb0Zvcm0gPSAhIWZvcm1FbDtcbiAgICB9O1xuICAgIHFxLmV4dGVuZChxcS5Gb3JtU3VwcG9ydC5wcm90b3R5cGUsIHtcbiAgICAgICAgX2Zvcm0yT2JqOiBmdW5jdGlvbihmb3JtKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIHZhciBvYmogPSB7fSwgbm90SXJyZWxldmFudFR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlycmVsZXZhbnRUeXBlcyA9IFsgXCJidXR0b25cIiwgXCJpbWFnZVwiLCBcInJlc2V0XCIsIFwic3VibWl0XCIgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEuaW5kZXhPZihpcnJlbGV2YW50VHlwZXMsIHR5cGUudG9Mb3dlckNhc2UoKSkgPCAwO1xuICAgICAgICAgICAgfSwgcmFkaW9PckNoZWNrYm94ID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxcS5pbmRleE9mKFsgXCJjaGVja2JveFwiLCBcInJhZGlvXCIgXSwgdHlwZS50b0xvd2VyQ2FzZSgpKSA+PSAwO1xuICAgICAgICAgICAgfSwgaWdub3JlVmFsdWUgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIGlmIChyYWRpb09yQ2hlY2tib3goZWwudHlwZSkgJiYgIWVsLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbC5kaXNhYmxlZCAmJiBlbC50eXBlLnRvTG93ZXJDYXNlKCkgIT09IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICB9LCBzZWxlY3RWYWx1ZSA9IGZ1bmN0aW9uKHNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChxcShzZWxlY3QpLmNoaWxkcmVuKCksIGZ1bmN0aW9uKGlkeCwgY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJvcHRpb25cIiAmJiBjaGlsZC5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjaGlsZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBxcS5lYWNoKGZvcm0uZWxlbWVudHMsIGZ1bmN0aW9uKGlkeCwgZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHFxLmlzSW5wdXQoZWwsIHRydWUpIHx8IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0YXJlYVwiKSAmJiBub3RJcnJlbGV2YW50VHlwZShlbC50eXBlKSAmJiAhaWdub3JlVmFsdWUoZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtlbC5uYW1lXSA9IGVsLnZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInNlbGVjdFwiICYmICFpZ25vcmVWYWx1ZShlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VsZWN0VmFsdWUoZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtlbC5uYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcXEudHJhZGl0aW9uYWwgPSBxcS50cmFkaXRpb25hbCB8fCB7fTtcbiAgICBxcS50cmFkaXRpb25hbC5Gb3JtVXBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uKG9wdGlvbnMsIHByb3h5KSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMsIGdldE5hbWUgPSBwcm94eS5nZXROYW1lLCBnZXRVdWlkID0gcHJveHkuZ2V0VXVpZCwgbG9nID0gcHJveHkubG9nO1xuICAgICAgICBmdW5jdGlvbiBnZXRJZnJhbWVDb250ZW50SnNvbihpZCwgaWZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIGRvYywgaW5uZXJIdG1sO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkb2MgPSBpZnJhbWUuY29udGVudERvY3VtZW50IHx8IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgICAgICAgICAgICAgIGlubmVySHRtbCA9IGRvYy5ib2R5LmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICBsb2coXCJjb252ZXJ0aW5nIGlmcmFtZSdzIGlubmVySFRNTCB0byBKU09OXCIpO1xuICAgICAgICAgICAgICAgIGxvZyhcImlubmVySFRNTCA9IFwiICsgaW5uZXJIdG1sKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJIdG1sICYmIGlubmVySHRtbC5tYXRjaCgvXjxwcmUvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJIdG1sID0gZG9jLmJvZHkuZmlyc3RDaGlsZC5maXJzdENoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBoYW5kbGVyLl9wYXJzZUpzb25SZXNwb25zZShpbm5lckh0bWwpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2coXCJFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gcGFyc2UgZm9ybSB1cGxvYWQgcmVzcG9uc2UgKFwiICsgZXJyb3IubWVzc2FnZSArIFwiKVwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRm9ybShpZCwgaWZyYW1lKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gb3B0aW9ucy5wYXJhbXNTdG9yZS5nZXQoaWQpLCBtZXRob2QgPSBvcHRpb25zLm1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiID8gXCJHRVRcIiA6IFwiUE9TVFwiLCBlbmRwb2ludCA9IG9wdGlvbnMuZW5kcG9pbnRTdG9yZS5nZXQoaWQpLCBuYW1lID0gZ2V0TmFtZShpZCk7XG4gICAgICAgICAgICBwYXJhbXNbb3B0aW9ucy51dWlkTmFtZV0gPSBnZXRVdWlkKGlkKTtcbiAgICAgICAgICAgIHBhcmFtc1tvcHRpb25zLmZpbGVuYW1lUGFyYW1dID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLl9pbml0Rm9ybUZvclVwbG9hZCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IGVuZHBvaW50LFxuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgIHBhcmFtc0luQm9keTogb3B0aW9ucy5wYXJhbXNJbkJvZHksXG4gICAgICAgICAgICAgICAgdGFyZ2V0TmFtZTogaWZyYW1lLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBsb2FkRmlsZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBoYW5kbGVyLmdldElucHV0KGlkKSwgaWZyYW1lID0gaGFuZGxlci5fY3JlYXRlSWZyYW1lKGlkKSwgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCksIGZvcm07XG4gICAgICAgICAgICBmb3JtID0gY3JlYXRlRm9ybShpZCwgaWZyYW1lKTtcbiAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgICAgaGFuZGxlci5fYXR0YWNoTG9hZEV2ZW50KGlmcmFtZSwgZnVuY3Rpb24ocmVzcG9uc2VGcm9tTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGxvZyhcImlmcmFtZSBsb2FkZWRcIik7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gcmVzcG9uc2VGcm9tTWVzc2FnZSA/IHJlc3BvbnNlRnJvbU1lc3NhZ2UgOiBnZXRJZnJhbWVDb250ZW50SnNvbihpZCwgaWZyYW1lKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLl9kZXRhY2hMb2FkRXZlbnQoaWQpO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5jb3JzLmV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxKGlmcmFtZSkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2Uuc3VjY2VzcyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvZyhcIlNlbmRpbmcgdXBsb2FkIHJlcXVlc3QgZm9yIFwiICsgaWQpO1xuICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICAgICAgICAgIHFxKGZvcm0pLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCBuZXcgcXEuRm9ybVVwbG9hZEhhbmRsZXIoe1xuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGlzQ29yczogb3B0aW9ucy5jb3JzLmV4cGVjdGVkLFxuICAgICAgICAgICAgICAgIGlucHV0TmFtZTogb3B0aW9ucy5pbnB1dE5hbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm94eToge1xuICAgICAgICAgICAgICAgIG9uQ2FuY2VsOiBvcHRpb25zLm9uQ2FuY2VsLFxuICAgICAgICAgICAgICAgIGdldE5hbWU6IGdldE5hbWUsXG4gICAgICAgICAgICAgICAgZ2V0VXVpZDogZ2V0VXVpZCxcbiAgICAgICAgICAgICAgICBsb2c6IGxvZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBxcS50cmFkaXRpb25hbCA9IHFxLnRyYWRpdGlvbmFsIHx8IHt9O1xuICAgIHFxLnRyYWRpdGlvbmFsLlhoclVwbG9hZEhhbmRsZXIgPSBmdW5jdGlvbihzcGVjLCBwcm94eSkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLCBnZXROYW1lID0gcHJveHkuZ2V0TmFtZSwgZ2V0U2l6ZSA9IHByb3h5LmdldFNpemUsIGdldFV1aWQgPSBwcm94eS5nZXRVdWlkLCBsb2cgPSBwcm94eS5sb2csIG11bHRpcGFydCA9IHNwZWMuZm9yY2VNdWx0aXBhcnQgfHwgc3BlYy5wYXJhbXNJbkJvZHksIGFkZENodW5raW5nU3BlY2lmaWNQYXJhbXMgPSBmdW5jdGlvbihpZCwgcGFyYW1zLCBjaHVua0RhdGEpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gZ2V0U2l6ZShpZCksIG5hbWUgPSBnZXROYW1lKGlkKTtcbiAgICAgICAgICAgIGlmICghc3BlYy5vbWl0RGVmYXVsdFBhcmFtcykge1xuICAgICAgICAgICAgICAgIHBhcmFtc1tzcGVjLmNodW5raW5nLnBhcmFtTmFtZXMucGFydEluZGV4XSA9IGNodW5rRGF0YS5wYXJ0O1xuICAgICAgICAgICAgICAgIHBhcmFtc1tzcGVjLmNodW5raW5nLnBhcmFtTmFtZXMucGFydEJ5dGVPZmZzZXRdID0gY2h1bmtEYXRhLnN0YXJ0O1xuICAgICAgICAgICAgICAgIHBhcmFtc1tzcGVjLmNodW5raW5nLnBhcmFtTmFtZXMuY2h1bmtTaXplXSA9IGNodW5rRGF0YS5zaXplO1xuICAgICAgICAgICAgICAgIHBhcmFtc1tzcGVjLmNodW5raW5nLnBhcmFtTmFtZXMudG90YWxQYXJ0c10gPSBjaHVua0RhdGEuY291bnQ7XG4gICAgICAgICAgICAgICAgcGFyYW1zW3NwZWMudG90YWxGaWxlU2l6ZU5hbWVdID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdWx0aXBhcnQgJiYgIXNwZWMub21pdERlZmF1bHRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbc3BlYy5maWxlbmFtZVBhcmFtXSA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGFsbENodW5rc0RvbmVSZXF1ZXN0ZXIgPSBuZXcgcXEudHJhZGl0aW9uYWwuQWxsQ2h1bmtzRG9uZUFqYXhSZXF1ZXN0ZXIoe1xuICAgICAgICAgICAgY29yczogc3BlYy5jb3JzLFxuICAgICAgICAgICAgZW5kcG9pbnQ6IHNwZWMuY2h1bmtpbmcuc3VjY2Vzcy5lbmRwb2ludCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHNwZWMuY2h1bmtpbmcuc3VjY2Vzcy5oZWFkZXJzLFxuICAgICAgICAgICAganNvblBheWxvYWQ6IHNwZWMuY2h1bmtpbmcuc3VjY2Vzcy5qc29uUGF5bG9hZCxcbiAgICAgICAgICAgIGxvZzogbG9nLFxuICAgICAgICAgICAgbWV0aG9kOiBzcGVjLmNodW5raW5nLnN1Y2Nlc3MubWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBzcGVjLmNodW5raW5nLnN1Y2Nlc3MucGFyYW1zXG4gICAgICAgIH0pLCBjcmVhdGVSZWFkeVN0YXRlQ2hhbmdlZEhhbmRsZXIgPSBmdW5jdGlvbihpZCwgeGhyKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvblVwbG9hZE9yQ2h1bmtDb21wbGV0ZShpZCwgeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MocmVzdWx0LnJlc3BvbnNlLCB4aHIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKHJlc3VsdC5yZXNwb25zZSwgeGhyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfSwgZ2V0Q2h1bmtzQ29tcGxldGVQYXJhbXMgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHNwZWMucGFyYW1zU3RvcmUuZ2V0KGlkKSwgbmFtZSA9IGdldE5hbWUoaWQpLCBzaXplID0gZ2V0U2l6ZShpZCk7XG4gICAgICAgICAgICBwYXJhbXNbc3BlYy51dWlkTmFtZV0gPSBnZXRVdWlkKGlkKTtcbiAgICAgICAgICAgIHBhcmFtc1tzcGVjLmZpbGVuYW1lUGFyYW1dID0gbmFtZTtcbiAgICAgICAgICAgIHBhcmFtc1tzcGVjLnRvdGFsRmlsZVNpemVOYW1lXSA9IHNpemU7XG4gICAgICAgICAgICBwYXJhbXNbc3BlYy5jaHVua2luZy5wYXJhbU5hbWVzLnRvdGFsUGFydHNdID0gaGFuZGxlci5fZ2V0VG90YWxDaHVua3MoaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfSwgaXNFcnJvclVwbG9hZFJlc3BvbnNlID0gZnVuY3Rpb24oeGhyLCByZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHFxLmluZGV4T2YoWyAyMDAsIDIwMSwgMjAyLCAyMDMsIDIwNCBdLCB4aHIuc3RhdHVzKSA8IDAgfHwgc3BlYy5yZXF1aXJlU3VjY2Vzc0pzb24gJiYgIXJlc3BvbnNlLnN1Y2Nlc3MgfHwgcmVzcG9uc2UucmVzZXQ7XG4gICAgICAgIH0sIG9uVXBsb2FkT3JDaHVua0NvbXBsZXRlID0gZnVuY3Rpb24oaWQsIHhocikge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICAgICAgbG9nKFwieGhyIC0gc2VydmVyIHJlc3BvbnNlIHJlY2VpdmVkIGZvciBcIiArIGlkKTtcbiAgICAgICAgICAgIGxvZyhcInJlc3BvbnNlVGV4dCA9IFwiICsgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICByZXNwb25zZSA9IHBhcnNlUmVzcG9uc2UodHJ1ZSwgeGhyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogIWlzRXJyb3JVcGxvYWRSZXNwb25zZSh4aHIsIHJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHBhcnNlUmVzcG9uc2UgPSBmdW5jdGlvbih1cGxvYWQsIHhocikge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0ge307XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJSZWNlaXZlZCByZXNwb25zZSBzdGF0dXMge30gd2l0aCBib2R5OiB7fVwiLCB4aHIuc3RhdHVzLCB4aHIucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBxcS5wYXJzZUpzb24oeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHVwbG9hZCAmJiBzcGVjLnJlcXVpcmVTdWNjZXNzSnNvbiAmJiBsb2coXCJFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gcGFyc2UgeGhyIHJlc3BvbnNlIHRleHQgKFwiICsgZXJyb3IubWVzc2FnZSArIFwiKVwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9LCBzZW5kQ2h1bmtzQ29tcGxldGVSZXF1ZXN0ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHFxLlByb21pc2UoKTtcbiAgICAgICAgICAgIGFsbENodW5rc0RvbmVSZXF1ZXN0ZXIuY29tcGxldGUoaWQsIGhhbmRsZXIuX2NyZWF0ZVhocihpZCksIGdldENodW5rc0NvbXBsZXRlUGFyYW1zKGlkKSwgc3BlYy5jdXN0b21IZWFkZXJzLmdldChpZCkpLnRoZW4oZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKHBhcnNlUmVzcG9uc2UoZmFsc2UsIHhociksIHhocik7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLmZhaWx1cmUocGFyc2VSZXNwb25zZShmYWxzZSwgeGhyKSwgeGhyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH0sIHNldFBhcmFtc0FuZEdldEVudGl0eVRvU2VuZCA9IGZ1bmN0aW9uKGVudGl0eVRvU2VuZFBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGZpbGVPckJsb2IgPSBlbnRpdHlUb1NlbmRQYXJhbXMuZmlsZU9yQmxvYjtcbiAgICAgICAgICAgIHZhciBpZCA9IGVudGl0eVRvU2VuZFBhcmFtcy5pZDtcbiAgICAgICAgICAgIHZhciB4aHIgPSBlbnRpdHlUb1NlbmRQYXJhbXMueGhyO1xuICAgICAgICAgICAgdmFyIHhock92ZXJyaWRlcyA9IGVudGl0eVRvU2VuZFBhcmFtcy54aHJPdmVycmlkZXMgfHwge307XG4gICAgICAgICAgICB2YXIgY3VzdG9tUGFyYW1zID0gZW50aXR5VG9TZW5kUGFyYW1zLmN1c3RvbVBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0UGFyYW1zID0gZW50aXR5VG9TZW5kUGFyYW1zLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgIHZhciB4aHJPdmVycmlkZVBhcmFtcyA9IHhock92ZXJyaWRlcy5wYXJhbXMgfHwge307XG4gICAgICAgICAgICB2YXIgcGFyYW1zO1xuICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gbXVsdGlwYXJ0ID8gbmV3IEZvcm1EYXRhKCkgOiBudWxsLCBtZXRob2QgPSB4aHJPdmVycmlkZXMubWV0aG9kIHx8IHNwZWMubWV0aG9kLCBlbmRwb2ludCA9IHhock92ZXJyaWRlcy5lbmRwb2ludCB8fCBzcGVjLmVuZHBvaW50U3RvcmUuZ2V0KGlkKSwgbmFtZSA9IGdldE5hbWUoaWQpLCBzaXplID0gZ2V0U2l6ZShpZCk7XG4gICAgICAgICAgICBpZiAoc3BlYy5vbWl0RGVmYXVsdFBhcmFtcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHFxLmV4dGVuZCh7fSwgY3VzdG9tUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBxcS5leHRlbmQocGFyYW1zLCB4aHJPdmVycmlkZVBhcmFtcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHFxLmV4dGVuZCh7fSwgY3VzdG9tUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBxcS5leHRlbmQocGFyYW1zLCB4aHJPdmVycmlkZVBhcmFtcyk7XG4gICAgICAgICAgICAgICAgcXEuZXh0ZW5kKHBhcmFtcywgZGVmYXVsdFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgcGFyYW1zW3NwZWMudXVpZE5hbWVdID0gZ2V0VXVpZChpZCk7XG4gICAgICAgICAgICAgICAgcGFyYW1zW3NwZWMuZmlsZW5hbWVQYXJhbV0gPSBuYW1lO1xuICAgICAgICAgICAgICAgIGlmIChtdWx0aXBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW3NwZWMudG90YWxGaWxlU2l6ZU5hbWVdID0gc2l6ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFzcGVjLnBhcmFtc0luQm9keSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbc3BlYy5pbnB1dE5hbWVdID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNwZWMucGFyYW1zSW5Cb2R5KSB7XG4gICAgICAgICAgICAgICAgZW5kcG9pbnQgPSBxcS5vYmoydXJsKHBhcmFtcywgZW5kcG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeGhyLm9wZW4obWV0aG9kLCBlbmRwb2ludCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoc3BlYy5jb3JzLmV4cGVjdGVkICYmIHNwZWMuY29ycy5zZW5kQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdWx0aXBhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5wYXJhbXNJbkJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEub2JqMkZvcm1EYXRhKHBhcmFtcywgZm9ybURhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoc3BlYy5pbnB1dE5hbWUsIGZpbGVPckJsb2IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlT3JCbG9iO1xuICAgICAgICB9LCBzZXRVcGxvYWRIZWFkZXJzID0gZnVuY3Rpb24oaGVhZGVyc09wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJPdmVycmlkZXMgPSBoZWFkZXJzT3B0aW9ucy5oZWFkZXJPdmVycmlkZXM7XG4gICAgICAgICAgICB2YXIgaWQgPSBoZWFkZXJzT3B0aW9ucy5pZDtcbiAgICAgICAgICAgIHZhciB4aHIgPSBoZWFkZXJzT3B0aW9ucy54aHI7XG4gICAgICAgICAgICBpZiAoaGVhZGVyT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgcXEuZWFjaChoZWFkZXJPdmVycmlkZXMsIGZ1bmN0aW9uKGhlYWRlck5hbWUsIGhlYWRlclZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWUsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IHNwZWMuY3VzdG9tSGVhZGVycy5nZXQoaWQpLCBmaWxlT3JCbG9iID0gaGFuZGxlci5nZXRGaWxlKGlkKTtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJYLVJlcXVlc3RlZC1XaXRoXCIsIFwiWE1MSHR0cFJlcXVlc3RcIik7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDYWNoZS1Db250cm9sXCIsIFwibm8tY2FjaGVcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFtdWx0aXBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1NaW1lLVR5cGVcIiwgZmlsZU9yQmxvYi50eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXEuZWFjaChleHRyYUhlYWRlcnMsIGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBxcS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgdXBsb2FkQ2h1bms6IGZ1bmN0aW9uKHVwbG9hZENodW5rUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdXBsb2FkQ2h1bmtQYXJhbXMuaWQ7XG4gICAgICAgICAgICAgICAgdmFyIGNodW5rSWR4ID0gdXBsb2FkQ2h1bmtQYXJhbXMuY2h1bmtJZHg7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJyaWRlcyA9IHVwbG9hZENodW5rUGFyYW1zLm92ZXJyaWRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdW1pbmcgPSB1cGxvYWRDaHVua1BhcmFtcy5yZXN1bWluZztcbiAgICAgICAgICAgICAgICB2YXIgY2h1bmtEYXRhID0gaGFuZGxlci5fZ2V0Q2h1bmtEYXRhKGlkLCBjaHVua0lkeCksIHhociA9IGhhbmRsZXIuX2NyZWF0ZVhocihpZCwgY2h1bmtJZHgpLCBwcm9taXNlLCB0b1NlbmQsIGN1c3RvbVBhcmFtcywgcGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IGNyZWF0ZVJlYWR5U3RhdGVDaGFuZ2VkSGFuZGxlcihpZCwgeGhyKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLl9yZWdpc3RlclByb2dyZXNzSGFuZGxlcihpZCwgY2h1bmtJZHgsIGNodW5rRGF0YS5zaXplKTtcbiAgICAgICAgICAgICAgICBjdXN0b21QYXJhbXMgPSBzcGVjLnBhcmFtc1N0b3JlLmdldChpZCk7XG4gICAgICAgICAgICAgICAgYWRkQ2h1bmtpbmdTcGVjaWZpY1BhcmFtcyhpZCwgcGFyYW1zLCBjaHVua0RhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bWluZykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbc3BlYy5yZXN1bWUucGFyYW1OYW1lcy5yZXN1bWluZ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b1NlbmQgPSBzZXRQYXJhbXNBbmRHZXRFbnRpdHlUb1NlbmQoe1xuICAgICAgICAgICAgICAgICAgICBmaWxlT3JCbG9iOiBjaHVua0RhdGEuYmxvYixcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21QYXJhbXM6IGN1c3RvbVBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHhocjogeGhyLFxuICAgICAgICAgICAgICAgICAgICB4aHJPdmVycmlkZXM6IG92ZXJyaWRlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNldFVwbG9hZEhlYWRlcnMoe1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJPdmVycmlkZXM6IG92ZXJyaWRlcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHhocjogeGhyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgeGhyLnNlbmQodG9TZW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGxvYWRGaWxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlT3JCbG9iID0gaGFuZGxlci5nZXRGaWxlKGlkKSwgcHJvbWlzZSwgeGhyLCBjdXN0b21QYXJhbXMsIHRvU2VuZDtcbiAgICAgICAgICAgICAgICB4aHIgPSBoYW5kbGVyLl9jcmVhdGVYaHIoaWQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuX3JlZ2lzdGVyUHJvZ3Jlc3NIYW5kbGVyKGlkKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gY3JlYXRlUmVhZHlTdGF0ZUNoYW5nZWRIYW5kbGVyKGlkLCB4aHIpO1xuICAgICAgICAgICAgICAgIGN1c3RvbVBhcmFtcyA9IHNwZWMucGFyYW1zU3RvcmUuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICB0b1NlbmQgPSBzZXRQYXJhbXNBbmRHZXRFbnRpdHlUb1NlbmQoe1xuICAgICAgICAgICAgICAgICAgICBmaWxlT3JCbG9iOiBmaWxlT3JCbG9iLFxuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVBhcmFtczogY3VzdG9tUGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICB4aHI6IHhoclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNldFVwbG9hZEhlYWRlcnMoe1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHhocjogeGhyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgeGhyLnNlbmQodG9TZW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCBuZXcgcXEuWGhyVXBsb2FkSGFuZGxlcih7XG4gICAgICAgICAgICBvcHRpb25zOiBxcS5leHRlbmQoe1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogXCJ0cmFkaXRpb25hbFwiXG4gICAgICAgICAgICB9LCBzcGVjKSxcbiAgICAgICAgICAgIHByb3h5OiBxcS5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGdldEVuZHBvaW50OiBzcGVjLmVuZHBvaW50U3RvcmUuZ2V0XG4gICAgICAgICAgICB9LCBwcm94eSlcbiAgICAgICAgfSkpO1xuICAgICAgICBxcS5vdmVycmlkZSh0aGlzLCBmdW5jdGlvbihzdXBlcl8pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmluYWxpemVDaHVua3M6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5Lm9uRmluYWxpemluZyhpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjLmNodW5raW5nLnN1Y2Nlc3MuZW5kcG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kQ2h1bmtzQ29tcGxldGVSZXF1ZXN0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlcl8uZmluYWxpemVDaHVua3MoaWQsIHFxLmJpbmQocGFyc2VSZXNwb25zZSwgdGhpcywgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBxcS50cmFkaXRpb25hbC5BbGxDaHVua3NEb25lQWpheFJlcXVlc3RlciA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciByZXF1ZXN0ZXIsIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjb3JzOiB7XG4gICAgICAgICAgICAgICAgYWxsb3dYZHI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZW5kQ3JlZGVudGlhbHM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kcG9pbnQ6IG51bGwsXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKHN0ciwgbGV2ZWwpIHt9LFxuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIlxuICAgICAgICB9LCBwcm9taXNlcyA9IHt9LCBlbmRwb2ludEhhbmRsZXIgPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHFxLmlzRnVuY3Rpb24ob3B0aW9ucy5lbmRwb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZW5kcG9pbnQoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5lbmRwb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEuZXh0ZW5kKG9wdGlvbnMsIG8pO1xuICAgICAgICByZXF1ZXN0ZXIgPSBxcS5leHRlbmQodGhpcywgbmV3IHFxLkFqYXhSZXF1ZXN0ZXIoe1xuICAgICAgICAgICAgYWNjZXB0SGVhZGVyOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBvcHRpb25zLmpzb25QYXlsb2FkID8gXCJhcHBsaWNhdGlvbi9qc29uXCIgOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgICAgICAgICAgdmFsaWRNZXRob2RzOiBbIG9wdGlvbnMubWV0aG9kIF0sXG4gICAgICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgZW5kcG9pbnRTdG9yZTogZW5kcG9pbnRIYW5kbGVyLFxuICAgICAgICAgICAgYWxsb3dYUmVxdWVzdGVkV2l0aEFuZENhY2hlQ29udHJvbDogZmFsc2UsXG4gICAgICAgICAgICBjb3JzOiBvcHRpb25zLmNvcnMsXG4gICAgICAgICAgICBsb2c6IG9wdGlvbnMubG9nLFxuICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oaWQsIHhociwgaXNFcnJvcikge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gcHJvbWlzZXNbaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9taXNlc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5mYWlsdXJlKHhocik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKHhocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCB7XG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oaWQsIHhociwgcGFyYW1zLCBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9nKFwiU3VibWl0dGluZyBBbGwgQ2h1bmtzIERvbmUgcmVxdWVzdCBmb3IgXCIgKyBpZCk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbaWRdID0gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZXIuaW5pdFRyYW5zcG9ydChpZCkud2l0aFBhcmFtcyhvcHRpb25zLnBhcmFtcyhpZCkgfHwgcGFyYW1zKS53aXRoSGVhZGVycyhvcHRpb25zLmhlYWRlcnMoaWQpIHx8IGhlYWRlcnMpLnNlbmQoeGhyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBxcS5EcmFnQW5kRHJvcCA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBvcHRpb25zLCBISURFX1pPTkVTX0VWRU5UX05BTUUgPSBcInFxLWhpZGV6b25lc1wiLCBISURFX0JFRk9SRV9FTlRFUl9BVFRSID0gXCJxcS1oaWRlLWRyb3B6b25lXCIsIHVwbG9hZERyb3Bab25lcyA9IFtdLCBkcm9wcGVkRmlsZXMgPSBbXSwgZGlzcG9zZVN1cHBvcnQgPSBuZXcgcXEuRGlzcG9zZVN1cHBvcnQoKTtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRyb3Bab25lRWxlbWVudHM6IFtdLFxuICAgICAgICAgICAgYWxsb3dNdWx0aXBsZUl0ZW1zOiB0cnVlLFxuICAgICAgICAgICAgY2xhc3Nlczoge1xuICAgICAgICAgICAgICAgIGRyb3BBY3RpdmU6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxsYmFja3M6IG5ldyBxcS5EcmFnQW5kRHJvcC5jYWxsYmFja3MoKVxuICAgICAgICB9O1xuICAgICAgICBxcS5leHRlbmQob3B0aW9ucywgbywgdHJ1ZSk7XG4gICAgICAgIGZ1bmN0aW9uIHVwbG9hZERyb3BwZWRGaWxlcyhmaWxlcywgdXBsb2FkRHJvcFpvbmUpIHtcbiAgICAgICAgICAgIHZhciBmaWxlc0FzQXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmaWxlcyk7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrcy5kcm9wTG9nKFwiR3JhYmJlZCBcIiArIGZpbGVzLmxlbmd0aCArIFwiIGRyb3BwZWQgZmlsZXMuXCIpO1xuICAgICAgICAgICAgdXBsb2FkRHJvcFpvbmUuZHJvcERpc2FibGVkKGZhbHNlKTtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2tzLnByb2Nlc3NpbmdEcm9wcGVkRmlsZXNDb21wbGV0ZShmaWxlc0FzQXJyYXksIHVwbG9hZERyb3Bab25lLmdldEVsZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJhdmVyc2VGaWxlVHJlZShlbnRyeSkge1xuICAgICAgICAgICAgdmFyIHBhcnNlRW50cnlQcm9taXNlID0gbmV3IHFxLlByb21pc2UoKTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5maWxlKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZS5xcVBhdGggPSBleHRyYWN0RGlyZWN0b3J5UGF0aChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGRyb3BwZWRGaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUVudHJ5UHJvbWlzZS5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZmlsZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2tzLmRyb3BMb2coXCJQcm9ibGVtIHBhcnNpbmcgJ1wiICsgZW50cnkuZnVsbFBhdGggKyBcIicuICBGaWxlRXJyb3IgY29kZSBcIiArIGZpbGVFcnJvci5jb2RlICsgXCIuXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRW50cnlQcm9taXNlLmZhaWx1cmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBnZXRGaWxlc0luRGlyZWN0b3J5KGVudHJ5KS50aGVuKGZ1bmN0aW9uIGFsbEVudHJpZXNSZWFkKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJpZXNMZWZ0ID0gZW50cmllcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHFxLmVhY2goZW50cmllcywgZnVuY3Rpb24oaWR4LCBlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VGaWxlVHJlZShlbnRyeSkuZG9uZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzTGVmdCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUVudHJ5UHJvbWlzZS5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUVudHJ5UHJvbWlzZS5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiByZWFkRmFpbHVyZShmaWxlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFja3MuZHJvcExvZyhcIlByb2JsZW0gcGFyc2luZyAnXCIgKyBlbnRyeS5mdWxsUGF0aCArIFwiJy4gIEZpbGVFcnJvciBjb2RlIFwiICsgZmlsZUVycm9yLmNvZGUgKyBcIi5cIiwgXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VFbnRyeVByb21pc2UuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRW50cnlQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGV4dHJhY3REaXJlY3RvcnlQYXRoKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGVudHJ5Lm5hbWUsIGZ1bGxQYXRoID0gZW50cnkuZnVsbFBhdGgsIGluZGV4T2ZOYW1lSW5GdWxsUGF0aCA9IGZ1bGxQYXRoLmxhc3RJbmRleE9mKG5hbWUpO1xuICAgICAgICAgICAgZnVsbFBhdGggPSBmdWxsUGF0aC5zdWJzdHIoMCwgaW5kZXhPZk5hbWVJbkZ1bGxQYXRoKTtcbiAgICAgICAgICAgIGlmIChmdWxsUGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgZnVsbFBhdGggPSBmdWxsUGF0aC5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVsbFBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RmlsZXNJbkRpcmVjdG9yeShlbnRyeSwgcmVhZGVyLCBhY2N1bUVudHJpZXMsIGV4aXN0aW5nUHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBleGlzdGluZ1Byb21pc2UgfHwgbmV3IHFxLlByb21pc2UoKSwgZGlyUmVhZGVyID0gcmVhZGVyIHx8IGVudHJ5LmNyZWF0ZVJlYWRlcigpO1xuICAgICAgICAgICAgZGlyUmVhZGVyLnJlYWRFbnRyaWVzKGZ1bmN0aW9uIHJlYWRTdWNjZXNzKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RW50cmllcyA9IGFjY3VtRW50cmllcyA/IGFjY3VtRW50cmllcy5jb25jYXQoZW50cmllcykgOiBlbnRyaWVzO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RmlsZXNJbkRpcmVjdG9yeShlbnRyeSwgZGlyUmVhZGVyLCBuZXdFbnRyaWVzLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdWNjZXNzKG5ld0VudHJpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHByb21pc2UuZmFpbHVyZSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVEYXRhVHJhbnNmZXIoZGF0YVRyYW5zZmVyLCB1cGxvYWREcm9wWm9uZSkge1xuICAgICAgICAgICAgdmFyIHBlbmRpbmdGb2xkZXJQcm9taXNlcyA9IFtdLCBoYW5kbGVEYXRhVHJhbnNmZXJQcm9taXNlID0gbmV3IHFxLlByb21pc2UoKTtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2tzLnByb2Nlc3NpbmdEcm9wcGVkRmlsZXMoKTtcbiAgICAgICAgICAgIHVwbG9hZERyb3Bab25lLmRyb3BEaXNhYmxlZCh0cnVlKTtcbiAgICAgICAgICAgIGlmIChkYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoID4gMSAmJiAhb3B0aW9ucy5hbGxvd011bHRpcGxlSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrcy5wcm9jZXNzaW5nRHJvcHBlZEZpbGVzQ29tcGxldGUoW10pO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2tzLmRyb3BFcnJvcihcInRvb01hbnlGaWxlc0Vycm9yXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgIHVwbG9hZERyb3Bab25lLmRyb3BEaXNhYmxlZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlRGF0YVRyYW5zZmVyUHJvbWlzZS5mYWlsdXJlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyb3BwZWRGaWxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChxcS5pc0ZvbGRlckRyb3BTdXBwb3J0ZWQoZGF0YVRyYW5zZmVyKSkge1xuICAgICAgICAgICAgICAgICAgICBxcS5lYWNoKGRhdGFUcmFuc2Zlci5pdGVtcywgZnVuY3Rpb24oaWR4LCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBpdGVtLndlYmtpdEdldEFzRW50cnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcHBlZEZpbGVzLnB1c2goaXRlbS5nZXRBc0ZpbGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0ZvbGRlclByb21pc2VzLnB1c2godHJhdmVyc2VGaWxlVHJlZShlbnRyeSkuZG9uZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdGb2xkZXJQcm9taXNlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nRm9sZGVyUHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRGF0YVRyYW5zZmVyUHJvbWlzZS5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3BwZWRGaWxlcyA9IGRhdGFUcmFuc2Zlci5maWxlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdGb2xkZXJQcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRGF0YVRyYW5zZmVyUHJvbWlzZS5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZURhdGFUcmFuc2ZlclByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBEcm9wem9uZShkcm9wQXJlYSkge1xuICAgICAgICAgICAgdmFyIGRyb3Bab25lID0gbmV3IHFxLlVwbG9hZERyb3Bab25lKHtcbiAgICAgICAgICAgICAgICBISURFX1pPTkVTX0VWRU5UX05BTUU6IEhJREVfWk9ORVNfRVZFTlRfTkFNRSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBkcm9wQXJlYSxcbiAgICAgICAgICAgICAgICBvbkVudGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxKGRyb3BBcmVhKS5hZGRDbGFzcyhvcHRpb25zLmNsYXNzZXMuZHJvcEFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkxlYXZlTm90RGVzY2VuZGFudHM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEoZHJvcEFyZWEpLnJlbW92ZUNsYXNzKG9wdGlvbnMuY2xhc3Nlcy5kcm9wQWN0aXZlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uRHJvcDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVEYXRhVHJhbnNmZXIoZS5kYXRhVHJhbnNmZXIsIGRyb3Bab25lKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkRHJvcHBlZEZpbGVzKGRyb3BwZWRGaWxlcywgZHJvcFpvbmUpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2tzLmRyb3BMb2coXCJEcm9wIGV2ZW50IERhdGFUcmFuc2ZlciBwYXJzaW5nIGZhaWxlZC4gIE5vIGZpbGVzIHdpbGwgYmUgdXBsb2FkZWQuXCIsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlzcG9zZVN1cHBvcnQuYWRkRGlzcG9zZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZHJvcFpvbmUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxcShkcm9wQXJlYSkuaGFzQXR0cmlidXRlKEhJREVfQkVGT1JFX0VOVEVSX0FUVFIpICYmIHFxKGRyb3BBcmVhKS5oaWRlKCk7XG4gICAgICAgICAgICB1cGxvYWREcm9wWm9uZXMucHVzaChkcm9wWm9uZSk7XG4gICAgICAgICAgICByZXR1cm4gZHJvcFpvbmU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNGaWxlRHJhZyhkcmFnRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBmaWxlRHJhZztcbiAgICAgICAgICAgIHFxLmVhY2goZHJhZ0V2ZW50LmRhdGFUcmFuc2Zlci50eXBlcywgZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSBcIkZpbGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZURyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZURyYWc7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbGVhdmluZ0RvY3VtZW50T3V0KGUpIHtcbiAgICAgICAgICAgIGlmIChxcS5zYWZhcmkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLnggPCAwIHx8IGUueSA8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZS54ID09PSAwICYmIGUueSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cERyYWdEcm9wKCkge1xuICAgICAgICAgICAgdmFyIGRyb3Bab25lcyA9IG9wdGlvbnMuZHJvcFpvbmVFbGVtZW50cywgbWF5YmVIaWRlRHJvcFpvbmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChkcm9wWm9uZXMsIGZ1bmN0aW9uKGlkeCwgZHJvcFpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFxKGRyb3Bab25lKS5oYXNBdHRyaWJ1dGUoSElERV9CRUZPUkVfRU5URVJfQVRUUikgJiYgcXEoZHJvcFpvbmUpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFxKGRyb3Bab25lKS5yZW1vdmVDbGFzcyhvcHRpb25zLmNsYXNzZXMuZHJvcEFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBxcS5lYWNoKGRyb3Bab25lcywgZnVuY3Rpb24oaWR4LCBkcm9wWm9uZSkge1xuICAgICAgICAgICAgICAgIHZhciB1cGxvYWREcm9wWm9uZSA9IHNldHVwRHJvcHpvbmUoZHJvcFpvbmUpO1xuICAgICAgICAgICAgICAgIGlmIChkcm9wWm9uZXMubGVuZ3RoICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLmZpbGVEcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VTdXBwb3J0LmF0dGFjaChkb2N1bWVudCwgXCJkcmFnZW50ZXJcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1cGxvYWREcm9wWm9uZS5kcm9wRGlzYWJsZWQoKSAmJiBpc0ZpbGVEcmFnKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXEuZWFjaChkcm9wWm9uZXMsIGZ1bmN0aW9uKGlkeCwgZHJvcFpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRyb3Bab25lIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgcXEoZHJvcFpvbmUpLmhhc0F0dHJpYnV0ZShISURFX0JFRk9SRV9FTlRFUl9BVFRSKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXEoZHJvcFpvbmUpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJibG9ja1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3Bvc2VTdXBwb3J0LmF0dGFjaChkb2N1bWVudCwgXCJkcmFnbGVhdmVcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChsZWF2aW5nRG9jdW1lbnRPdXQoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVIaWRlRHJvcFpvbmVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2gocXEoZG9jdW1lbnQpLmNoaWxkcmVuKClbMF0sIFwibW91c2VlbnRlclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVIaWRlRHJvcFpvbmVzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3Bvc2VTdXBwb3J0LmF0dGFjaChkb2N1bWVudCwgXCJkcm9wXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaWxlRHJhZyhlKSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIG1heWJlSGlkZURyb3Bab25lcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlzcG9zZVN1cHBvcnQuYXR0YWNoKGRvY3VtZW50LCBISURFX1pPTkVTX0VWRU5UX05BTUUsIG1heWJlSGlkZURyb3Bab25lcyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dXBEcmFnRHJvcCgpO1xuICAgICAgICBxcS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgc2V0dXBFeHRyYURyb3B6b25lOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kcm9wWm9uZUVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgc2V0dXBEcm9wem9uZShlbGVtZW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVEcm9wem9uZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBpLCBkenMgPSBvcHRpb25zLmRyb3Bab25lRWxlbWVudHM7XG4gICAgICAgICAgICAgICAgZm9yIChpIGluIGR6cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHpzW2ldID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHpzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgcXEuZWFjaCh1cGxvYWREcm9wWm9uZXMsIGZ1bmN0aW9uKGlkeCwgZHJvcFpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJvcFpvbmUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdGVzdGluZyA9IHt9O1xuICAgICAgICB0aGlzLl90ZXN0aW5nLmV4dHJhY3REaXJlY3RvcnlQYXRoID0gZXh0cmFjdERpcmVjdG9yeVBhdGg7XG4gICAgfTtcbiAgICBxcS5EcmFnQW5kRHJvcC5jYWxsYmFja3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9jZXNzaW5nRHJvcHBlZEZpbGVzOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgcHJvY2Vzc2luZ0Ryb3BwZWRGaWxlc0NvbXBsZXRlOiBmdW5jdGlvbihmaWxlcywgdGFyZ2V0RWwpIHt9LFxuICAgICAgICAgICAgZHJvcEVycm9yOiBmdW5jdGlvbihjb2RlLCBlcnJvclNwZWNpZmljcykge1xuICAgICAgICAgICAgICAgIHFxLmxvZyhcIkRyYWcgJiBkcm9wIGVycm9yIGNvZGUgJ1wiICsgY29kZSArIFwiIHdpdGggdGhlc2Ugc3BlY2lmaWNzOiAnXCIgKyBlcnJvclNwZWNpZmljcyArIFwiJ1wiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRyb3BMb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIGxldmVsKSB7XG4gICAgICAgICAgICAgICAgcXEubG9nKG1lc3NhZ2UsIGxldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHFxLlVwbG9hZERyb3Bab25lID0gZnVuY3Rpb24obykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGRpc3Bvc2VTdXBwb3J0ID0gbmV3IHFxLkRpc3Bvc2VTdXBwb3J0KCksIG9wdGlvbnMsIGVsZW1lbnQsIHByZXZlbnREcm9wLCBkcm9wT3V0c2lkZURpc2FibGVkO1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZWxlbWVudDogbnVsbCxcbiAgICAgICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uKGUpIHt9LFxuICAgICAgICAgICAgb25MZWF2ZTogZnVuY3Rpb24oZSkge30sXG4gICAgICAgICAgICBvbkxlYXZlTm90RGVzY2VuZGFudHM6IGZ1bmN0aW9uKGUpIHt9LFxuICAgICAgICAgICAgb25Ecm9wOiBmdW5jdGlvbihlKSB7fVxuICAgICAgICB9O1xuICAgICAgICBxcS5leHRlbmQob3B0aW9ucywgbyk7XG4gICAgICAgIGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG4gICAgICAgIGZ1bmN0aW9uIGRyYWdvdmVyU2hvdWxkQmVDYW5jZWxlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBxcS5zYWZhcmkoKSB8fCBxcS5maXJlZm94KCkgJiYgcXEud2luZG93cygpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRpc2FibGVEcm9wT3V0c2lkZShlKSB7XG4gICAgICAgICAgICBpZiAoIWRyb3BPdXRzaWRlRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ292ZXJTaG91bGRCZUNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VTdXBwb3J0LmF0dGFjaChkb2N1bWVudCwgXCJkcmFnb3ZlclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VTdXBwb3J0LmF0dGFjaChkb2N1bWVudCwgXCJkcmFnb3ZlclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHJvcE91dHNpZGVEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNWYWxpZEZpbGVEcmFnKGUpIHtcbiAgICAgICAgICAgIGlmICghcXEuc3VwcG9ydGVkRmVhdHVyZXMuZmlsZURyb3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZWZmZWN0VGVzdCwgZHQgPSBlLmRhdGFUcmFuc2ZlciwgaXNTYWZhcmkgPSBxcS5zYWZhcmkoKTtcbiAgICAgICAgICAgIGVmZmVjdFRlc3QgPSBxcS5pZSgpICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLmZpbGVEcm9wID8gdHJ1ZSA6IGR0LmVmZmVjdEFsbG93ZWQgIT09IFwibm9uZVwiO1xuICAgICAgICAgICAgcmV0dXJuIGR0ICYmIGVmZmVjdFRlc3QgJiYgKGR0LmZpbGVzICYmIGR0LmZpbGVzLmxlbmd0aCB8fCAhaXNTYWZhcmkgJiYgZHQudHlwZXMuY29udGFpbnMgJiYgZHQudHlwZXMuY29udGFpbnMoXCJGaWxlc1wiKSB8fCBkdC50eXBlcy5pbmNsdWRlcyAmJiBkdC50eXBlcy5pbmNsdWRlcyhcIkZpbGVzXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc09yU2V0RHJvcERpc2FibGVkKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcmV2ZW50RHJvcCA9IGlzRGlzYWJsZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldmVudERyb3A7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpZ2dlckhpZGV6b25lc0V2ZW50KCkge1xuICAgICAgICAgICAgdmFyIGhpZGVab25lc0V2ZW50O1xuICAgICAgICAgICAgZnVuY3Rpb24gdHJpZ2dlclVzaW5nT2xkQXBpKCkge1xuICAgICAgICAgICAgICAgIGhpZGVab25lc0V2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICAgICAgICAgICAgICBoaWRlWm9uZXNFdmVudC5pbml0RXZlbnQob3B0aW9ucy5ISURFX1pPTkVTX0VWRU5UX05BTUUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdpbmRvdy5DdXN0b21FdmVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZGVab25lc0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KG9wdGlvbnMuSElERV9aT05FU19FVkVOVF9OQU1FKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlclVzaW5nT2xkQXBpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVXNpbmdPbGRBcGkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoaGlkZVpvbmVzRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcbiAgICAgICAgICAgIGRpc3Bvc2VTdXBwb3J0LmF0dGFjaChlbGVtZW50LCBcImRyYWdvdmVyXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWxlRHJhZyhlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlZmZlY3QgPSBxcS5pZSgpICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLmZpbGVEcm9wID8gbnVsbCA6IGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdCA9PT0gXCJtb3ZlXCIgfHwgZWZmZWN0ID09PSBcImxpbmtNb3ZlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibW92ZVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcImNvcHlcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3Bvc2VTdXBwb3J0LmF0dGFjaChlbGVtZW50LCBcImRyYWdlbnRlclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc09yU2V0RHJvcERpc2FibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRmlsZURyYWcoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRW50ZXIoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwb3NlU3VwcG9ydC5hdHRhY2goZWxlbWVudCwgXCJkcmFnbGVhdmVcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpbGVEcmFnKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vbkxlYXZlKGUpO1xuICAgICAgICAgICAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICAgICAgICAgICAgaWYgKHFxKHRoaXMpLmNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vbkxlYXZlTm90RGVzY2VuZGFudHMoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3Bvc2VTdXBwb3J0LmF0dGFjaChlbGVtZW50LCBcImRyb3BcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNPclNldERyb3BEaXNhYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpbGVEcmFnKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRHJvcChlKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckhpZGV6b25lc0V2ZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzYWJsZURyb3BPdXRzaWRlKCk7XG4gICAgICAgIGF0dGFjaEV2ZW50cygpO1xuICAgICAgICBxcS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgZHJvcERpc2FibGVkOiBmdW5jdGlvbihpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzT3JTZXREcm9wRGlzYWJsZWQoaXNEaXNhYmxlZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZVN1cHBvcnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdGVzdGluZyA9IHt9O1xuICAgICAgICB0aGlzLl90ZXN0aW5nLmlzVmFsaWRGaWxlRHJhZyA9IGlzVmFsaWRGaWxlRHJhZztcbiAgICB9O1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHFxLnVpUHVibGljQXBpID0ge1xuICAgICAgICAgICAgYWRkSW5pdGlhbEZpbGVzOiBmdW5jdGlvbihjYW5uZWRGaWxlTGlzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuYWRkSW5pdGlhbEZpbGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5hZGRDYWNoZVRvRG9tKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXJTdG9yZWRGaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5jbGVhclN0b3JlZEZpbGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5jbGVhckZpbGVzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkRXh0cmFEcm9wem9uZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RuZCAmJiB0aGlzLl9kbmQuc2V0dXBFeHRyYURyb3B6b25lKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZUV4dHJhRHJvcHpvbmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZG5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kbmQucmVtb3ZlRHJvcHpvbmUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEl0ZW1CeUZpbGVJZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3RlbXBsYXRpbmcuaXNIaWRkZW5Gb3JldmVyKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGluZy5nZXRGaWxlQ29udGFpbmVyKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUucmVzZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmJ1dHRvbiAmJiB0aGlzLl90ZW1wbGF0aW5nLmdldEJ1dHRvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRCdXR0b25JZCA9IHRoaXMuX2NyZWF0ZVVwbG9hZEJ1dHRvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLl90ZW1wbGF0aW5nLmdldEJ1dHRvbigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRoaXMuX29wdGlvbnMudGV4dC5maWxlSW5wdXRUaXRsZVxuICAgICAgICAgICAgICAgICAgICB9KS5nZXRCdXR0b25JZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZG5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RuZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RuZCA9IHRoaXMuX3NldHVwRHJhZ0FuZERyb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxGaWxlc0luQmF0Y2ggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGVzSW5CYXRjaEFkZGVkVG9VaSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0dXBDbGlja0FuZEVkaXRFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0TmFtZTogZnVuY3Rpb24oaWQsIG5ld05hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkRmlsZW5hbWUgPSB0aGlzLl9vcHRpb25zLmZvcm1hdEZpbGVOYW1lKG5ld05hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuc2V0TmFtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcudXBkYXRlRmlsZW5hbWUoaWQsIGZvcm1hdHRlZEZpbGVuYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXVzZVVwbG9hZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF1c2VkID0gdGhpcy5fcGFyZW50LnByb3RvdHlwZS5wYXVzZVVwbG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHBhdXNlZCAmJiB0aGlzLl90ZW1wbGF0aW5nLnVwbG9hZFBhdXNlZChpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdXNlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250aW51ZVVwbG9hZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGludWVkID0gdGhpcy5fcGFyZW50LnByb3RvdHlwZS5jb250aW51ZVVwbG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlZCAmJiB0aGlzLl90ZW1wbGF0aW5nLnVwbG9hZENvbnRpbnVlZChpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRpbnVlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJZDogZnVuY3Rpb24oZmlsZUNvbnRhaW5lck9yQ2hpbGRFbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0aW5nLmdldEZpbGVJZChmaWxlQ29udGFpbmVyT3JDaGlsZEVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXREcm9wVGFyZ2V0OiBmdW5jdGlvbihmaWxlSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZ2V0RmlsZShmaWxlSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLnFxRHJvcFRhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcXEudWlQcml2YXRlQXBpID0ge1xuICAgICAgICAgICAgX2dldEJ1dHRvbjogZnVuY3Rpb24oYnV0dG9uSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fZ2V0QnV0dG9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKCFidXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbklkID09PSB0aGlzLl9kZWZhdWx0QnV0dG9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbiA9IHRoaXMuX3RlbXBsYXRpbmcuZ2V0QnV0dG9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfcmVtb3ZlRmlsZUl0ZW06IGZ1bmN0aW9uKGZpbGVJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcucmVtb3ZlRmlsZShmaWxlSWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZXR1cENsaWNrQW5kRWRpdEV2ZW50SGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGVCdXR0b25zQ2xpY2tIYW5kbGVyID0gcXEuRmlsZUJ1dHRvbnNDbGlja0hhbmRsZXIgJiYgdGhpcy5fYmluZEZpbGVCdXR0b25zQ2xpY2tFdmVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzaW5FdmVudFN1cHBvcnRlZCA9ICFxcS5maXJlZm94KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzRWRpdEZpbGVuYW1lRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGVuYW1lQ2xpY2tIYW5kbGVyID0gdGhpcy5fYmluZEZpbGVuYW1lQ2xpY2tFdmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWxlbmFtZUlucHV0Rm9jdXNJbkhhbmRsZXIgPSB0aGlzLl9iaW5kRmlsZW5hbWVJbnB1dEZvY3VzSW5FdmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWxlbmFtZUlucHV0Rm9jdXNIYW5kbGVyID0gdGhpcy5fYmluZEZpbGVuYW1lSW5wdXRGb2N1c0V2ZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zZXR1cERyYWdBbmREcm9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGRyb3Bab25lRWxlbWVudHMgPSB0aGlzLl9vcHRpb25zLmRyYWdBbmREcm9wLmV4dHJhRHJvcHpvbmVzLCB0ZW1wbGF0aW5nID0gdGhpcy5fdGVtcGxhdGluZywgZGVmYXVsdERyb3Bab25lID0gdGVtcGxhdGluZy5nZXREcm9wWm9uZSgpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHREcm9wWm9uZSAmJiBkcm9wWm9uZUVsZW1lbnRzLnB1c2goZGVmYXVsdERyb3Bab25lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHFxLkRyYWdBbmREcm9wKHtcbiAgICAgICAgICAgICAgICAgICAgZHJvcFpvbmVFbGVtZW50czogZHJvcFpvbmVFbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dNdWx0aXBsZUl0ZW1zOiB0aGlzLl9vcHRpb25zLm11bHRpcGxlLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wQWN0aXZlOiB0aGlzLl9vcHRpb25zLmNsYXNzZXMuZHJvcEFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdEcm9wcGVkRmlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRpbmcuc2hvd0Ryb3BQcm9jZXNzaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2luZ0Ryb3BwZWRGaWxlc0NvbXBsZXRlOiBmdW5jdGlvbihmaWxlcywgdGFyZ2V0RWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0aW5nLmhpZGVEcm9wUHJvY2Vzc2luZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFxLmVhY2goZmlsZXMsIGZ1bmN0aW9uKGlkeCwgZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnFxRHJvcFRhcmdldCA9IHRhcmdldEVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRGaWxlcyhmaWxlcywgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BFcnJvcjogZnVuY3Rpb24oY29kZSwgZXJyb3JEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faXRlbUVycm9yKGNvZGUsIGVycm9yRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcExvZzogZnVuY3Rpb24obWVzc2FnZSwgbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhtZXNzYWdlLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYmluZEZpbGVCdXR0b25zQ2xpY2tFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcXEuRmlsZUJ1dHRvbnNDbGlja0hhbmRsZXIoe1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0aW5nOiB0aGlzLl90ZW1wbGF0aW5nLFxuICAgICAgICAgICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIGx2bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2cobWVzc2FnZSwgbHZsKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25EZWxldGVGaWxlOiBmdW5jdGlvbihmaWxlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGVsZXRlRmlsZShmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbDogZnVuY3Rpb24oZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbmNlbChmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblJldHJ5OiBmdW5jdGlvbihmaWxlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmV0cnkoZmlsZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25QYXVzZTogZnVuY3Rpb24oZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBhdXNlVXBsb2FkKGZpbGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uQ29udGludWU6IGZ1bmN0aW9uKGZpbGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb250aW51ZVVwbG9hZChmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkdldE5hbWU6IGZ1bmN0aW9uKGZpbGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0TmFtZShmaWxlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2lzRWRpdEZpbGVuYW1lRW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRpbmcuaXNFZGl0RmlsZW5hbWVQb3NzaWJsZSgpICYmICF0aGlzLl9vcHRpb25zLmF1dG9VcGxvYWQgJiYgcXEuRmlsZW5hbWVDbGlja0hhbmRsZXIgJiYgcXEuRmlsZW5hbWVJbnB1dEZvY3VzSGFuZGxlciAmJiBxcS5GaWxlbmFtZUlucHV0Rm9jdXNIYW5kbGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9maWxlbmFtZUVkaXRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIHRlbXBsYXRpbmcgPSB0aGlzLl90ZW1wbGF0aW5nO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRpbmc6IHRlbXBsYXRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGxvZzogZnVuY3Rpb24obWVzc2FnZSwgbHZsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhtZXNzYWdlLCBsdmwpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkdldFVwbG9hZFN0YXR1czogZnVuY3Rpb24oZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRVcGxvYWRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogZmlsZUlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uR2V0TmFtZTogZnVuY3Rpb24oZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXROYW1lKGZpbGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uU2V0TmFtZTogZnVuY3Rpb24oaWQsIG5ld05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0TmFtZShpZCwgbmV3TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRWRpdGluZ1N0YXR1c0NoYW5nZTogZnVuY3Rpb24oaWQsIGlzRWRpdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHFxSW5wdXQgPSBxcSh0ZW1wbGF0aW5nLmdldEVkaXRJbnB1dChpZCkpLCBxcUZpbGVDb250YWluZXIgPSBxcSh0ZW1wbGF0aW5nLmdldEZpbGVDb250YWluZXIoaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxcUlucHV0LmFkZENsYXNzKFwicXEtZWRpdGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0aW5nLmhpZGVGaWxlbmFtZShpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGluZy5oaWRlRWRpdEljb24oaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxcUlucHV0LnJlbW92ZUNsYXNzKFwicXEtZWRpdGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0aW5nLnNob3dGaWxlbmFtZShpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGluZy5zaG93RWRpdEljb24oaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcXFGaWxlQ29udGFpbmVyLmFkZENsYXNzKFwicXEtdGVtcFwiKS5yZW1vdmVDbGFzcyhcInFxLXRlbXBcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblVwbG9hZFN0YXR1c0NoYW5nZTogZnVuY3Rpb24oaWQsIG9sZFN0YXR1cywgbmV3U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fb25VcGxvYWRTdGF0dXNDaGFuZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNFZGl0RmlsZW5hbWVFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RlbXBsYXRpbmcuZ2V0RmlsZUNvbnRhaW5lcihpZCkgJiYgbmV3U3RhdHVzICE9PSBxcS5zdGF0dXMuU1VCTUlUVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLm1hcmtGaWxlbmFtZUVkaXRhYmxlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuaGlkZUVkaXRJY29uKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2xkU3RhdHVzID09PSBxcS5zdGF0dXMuVVBMT0FEX1JFVFJZSU5HICYmIG5ld1N0YXR1cyA9PT0gcXEuc3RhdHVzLlVQTE9BRElORykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmhpZGVSZXRyeShpZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuc2V0U3RhdHVzVGV4dChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHFxKHRoaXMuX3RlbXBsYXRpbmcuZ2V0RmlsZUNvbnRhaW5lcihpZCkpLnJlbW92ZUNsYXNzKHRoaXMuX2NsYXNzZXMucmV0cnlpbmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3U3RhdHVzID09PSBxcS5zdGF0dXMuVVBMT0FEX0ZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmhpZGVQYXVzZShpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9iaW5kRmlsZW5hbWVJbnB1dEZvY3VzSW5FdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWMgPSBxcS5leHRlbmQoe30sIHRoaXMuX2ZpbGVuYW1lRWRpdEhhbmRsZXIoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBxcS5GaWxlbmFtZUlucHV0Rm9jdXNJbkhhbmRsZXIoc3BlYyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2JpbmRGaWxlbmFtZUlucHV0Rm9jdXNFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWMgPSBxcS5leHRlbmQoe30sIHRoaXMuX2ZpbGVuYW1lRWRpdEhhbmRsZXIoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBxcS5GaWxlbmFtZUlucHV0Rm9jdXNIYW5kbGVyKHNwZWMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9iaW5kRmlsZW5hbWVDbGlja0V2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BlYyA9IHFxLmV4dGVuZCh7fSwgdGhpcy5fZmlsZW5hbWVFZGl0SGFuZGxlcigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHFxLkZpbGVuYW1lQ2xpY2tIYW5kbGVyKHNwZWMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zdG9yZUZvckxhdGVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX3N0b3JlRm9yTGF0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmhpZGVTcGlubmVyKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25BbGxDb21wbGV0ZTogZnVuY3Rpb24oc3VjY2Vzc2Z1bCwgZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fb25BbGxDb21wbGV0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcucmVzZXRUb3RhbFByb2dyZXNzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uU3VibWl0OiBmdW5jdGlvbihpZCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlID0gdGhpcy5nZXRGaWxlKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSAmJiBmaWxlLnFxUGF0aCAmJiB0aGlzLl9vcHRpb25zLmRyYWdBbmREcm9wLnJlcG9ydERpcmVjdG9yeVBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtc1N0b3JlLmFkZFJlYWRPbmx5KGlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxcXBhdGg6IGZpbGUucXFQYXRoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQucHJvdG90eXBlLl9vblN1Ym1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvTGlzdChpZCwgbmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uU3VibWl0dGVkOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0VkaXRGaWxlbmFtZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLm1hcmtGaWxlbmFtZUVkaXRhYmxlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5zaG93RWRpdEljb24oaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ZvY3VzaW5FdmVudFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsZW5hbWVJbnB1dEZvY3VzSGFuZGxlci5hZGRIYW5kbGVyKHRoaXMuX3RlbXBsYXRpbmcuZ2V0RWRpdElucHV0KGlkKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uUHJvZ3Jlc3M6IGZ1bmN0aW9uKGlkLCBuYW1lLCBsb2FkZWQsIHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fb25Qcm9ncmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcudXBkYXRlUHJvZ3Jlc3MoaWQsIGxvYWRlZCwgdG90YWwpO1xuICAgICAgICAgICAgICAgIGlmICh0b3RhbCA9PT0gMCB8fCBNYXRoLnJvdW5kKGxvYWRlZCAvIHRvdGFsICogMTAwKSA9PT0gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuaGlkZUNhbmNlbChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuaGlkZVBhdXNlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5oaWRlUHJvZ3Jlc3MoaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnNldFN0YXR1c1RleHQoaWQsIHRoaXMuX29wdGlvbnMudGV4dC53YWl0aW5nRm9yUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5RmlsZVNpemUoaWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlGaWxlU2l6ZShpZCwgbG9hZGVkLCB0b3RhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblRvdGFsUHJvZ3Jlc3M6IGZ1bmN0aW9uKGxvYWRlZCwgdG90YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQucHJvdG90eXBlLl9vblRvdGFsUHJvZ3Jlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnVwZGF0ZVRvdGFsUHJvZ3Jlc3MobG9hZGVkLCB0b3RhbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uQ29tcGxldGU6IGZ1bmN0aW9uKGlkLCBuYW1lLCByZXN1bHQsIHhocikge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRSZXRWYWwgPSB0aGlzLl9wYXJlbnQucHJvdG90eXBlLl9vbkNvbXBsZXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRlbXBsYXRpbmcgPSB0aGlzLl90ZW1wbGF0aW5nLCBmaWxlQ29udGFpbmVyID0gdGVtcGxhdGluZy5nZXRGaWxlQ29udGFpbmVyKGlkKSwgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY29tcGxldGVVcGxvYWQocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlsZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRpbmcuc2V0U3RhdHVzVGV4dChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHFxKGZpbGVDb250YWluZXIpLnJlbW92ZUNsYXNzKHNlbGYuX2NsYXNzZXMucmV0cnlpbmcpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0aW5nLmhpZGVQcm9ncmVzcyhpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmdldFVwbG9hZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgICAgIH0pLnN0YXR1cyAhPT0gcXEuc3RhdHVzLlVQTE9BRF9GQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRpbmcuaGlkZUNhbmNlbChpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGluZy5oaWRlU3Bpbm5lcihpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fbWFya0ZpbGVBc1N1Y2Nlc3NmdWwoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXEoZmlsZUNvbnRhaW5lcikuYWRkQ2xhc3Moc2VsZi5fY2xhc3Nlcy5mYWlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRpbmcuc2hvd0NhbmNlbChpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGluZy5pc1JldHJ5UG9zc2libGUoKSAmJiAhc2VsZi5fcHJldmVudFJldHJpZXNbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXEoZmlsZUNvbnRhaW5lcikuYWRkQ2xhc3Moc2VsZi5fY2xhc3Nlcy5yZXRyeWFibGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRpbmcuc2hvd1JldHJ5KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2NvbnRyb2xGYWlsdXJlVGV4dERpc3BsYXkoaWQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFJldFZhbCBpbnN0YW5jZW9mIHFxLlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UmV0VmFsLmRvbmUoZnVuY3Rpb24obmV3UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVVwbG9hZChuZXdSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVVwbG9hZChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50UmV0VmFsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9tYXJrRmlsZUFzU3VjY2Vzc2Z1bDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGluZyA9IHRoaXMuX3RlbXBsYXRpbmc7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzRGVsZXRlUG9zc2libGUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0aW5nLnNob3dEZWxldGVCdXR0b24oaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxcSh0ZW1wbGF0aW5nLmdldEZpbGVDb250YWluZXIoaWQpKS5hZGRDbGFzcyh0aGlzLl9jbGFzc2VzLnN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21heWJlVXBkYXRlVGh1bWJuYWlsKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25VcGxvYWRQcmVwOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX29uVXBsb2FkUHJlcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuc2hvd1NwaW5uZXIoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblVwbG9hZDogZnVuY3Rpb24oaWQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50UmV0VmFsID0gdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fb25VcGxvYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnNob3dTcGlubmVyKGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50UmV0VmFsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblVwbG9hZENodW5rOiBmdW5jdGlvbihpZCwgY2h1bmtEYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fb25VcGxvYWRDaHVuay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmIChjaHVua0RhdGEucGFydEluZGV4ID4gMCAmJiB0aGlzLl9oYW5kbGVyLmlzUmVzdW1hYmxlKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmFsbG93UGF1c2UoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25DYW5jZWw6IGZ1bmN0aW9uKGlkLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fb25DYW5jZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVGaWxlSXRlbShpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dldE5vdEZpbmlzaGVkKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5yZXNldFRvdGFsUHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uQmVmb3JlQXV0b1JldHJ5OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHZhciByZXRyeU51bUZvckRpc3BsYXksIG1heEF1dG8sIHJldHJ5Tm90ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQucHJvdG90eXBlLl9vbkJlZm9yZUF1dG9SZXRyeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dDYW5jZWxMaW5rKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5yZXRyeS5zaG93QXV0b1JldHJ5Tm90ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXRyeU51bUZvckRpc3BsYXkgPSB0aGlzLl9hdXRvUmV0cmllc1tpZF07XG4gICAgICAgICAgICAgICAgICAgIG1heEF1dG8gPSB0aGlzLl9vcHRpb25zLnJldHJ5Lm1heEF1dG9BdHRlbXB0cztcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlOb3RlID0gdGhpcy5fb3B0aW9ucy5yZXRyeS5hdXRvUmV0cnlOb3RlLnJlcGxhY2UoL1xce3JldHJ5TnVtXFx9L2csIHJldHJ5TnVtRm9yRGlzcGxheSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHJ5Tm90ZSA9IHJldHJ5Tm90ZS5yZXBsYWNlKC9cXHttYXhBdXRvXFx9L2csIG1heEF1dG8pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnNldFN0YXR1c1RleHQoaWQsIHJldHJ5Tm90ZSk7XG4gICAgICAgICAgICAgICAgICAgIHFxKHRoaXMuX3RlbXBsYXRpbmcuZ2V0RmlsZUNvbnRhaW5lcihpZCkpLmFkZENsYXNzKHRoaXMuX2NsYXNzZXMucmV0cnlpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25CZWZvcmVNYW51YWxSZXRyeTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50LnByb3RvdHlwZS5fb25CZWZvcmVNYW51YWxSZXRyeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcucmVzZXRQcm9ncmVzcyhpZCk7XG4gICAgICAgICAgICAgICAgICAgIHFxKHRoaXMuX3RlbXBsYXRpbmcuZ2V0RmlsZUNvbnRhaW5lcihpZCkpLnJlbW92ZUNsYXNzKHRoaXMuX2NsYXNzZXMuZmFpbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuc2V0U3RhdHVzVGV4dChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuc2hvd1NwaW5uZXIoaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93Q2FuY2VsTGluayhpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHFxKHRoaXMuX3RlbXBsYXRpbmcuZ2V0RmlsZUNvbnRhaW5lcihpZCkpLmFkZENsYXNzKHRoaXMuX2NsYXNzZXMucmV0cnlhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5zaG93UmV0cnkoaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblN1Ym1pdERlbGV0ZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb25TdWNjZXNzQ2FsbGJhY2sgPSBxcS5iaW5kKHRoaXMuX29uU3VibWl0RGVsZXRlU3VjY2VzcywgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fb25TdWJtaXREZWxldGUuY2FsbCh0aGlzLCBpZCwgb25TdWNjZXNzQ2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vblN1Ym1pdERlbGV0ZVN1Y2Nlc3M6IGZ1bmN0aW9uKGlkLCB1dWlkLCBhZGRpdGlvbmFsTWFuZGF0ZWRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5kZWxldGVGaWxlLmZvcmNlQ29uZmlybSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaG93RGVsZXRlQ29uZmlybS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbmREZWxldGVSZXF1ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkRlbGV0ZUNvbXBsZXRlOiBmdW5jdGlvbihpZCwgeGhyLCBpc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fb25EZWxldGVDb21wbGV0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuaGlkZVNwaW5uZXIoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuc2V0U3RhdHVzVGV4dChpZCwgdGhpcy5fb3B0aW9ucy5kZWxldGVGaWxlLmRlbGV0aW5nRmFpbGVkVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuc2hvd0RlbGV0ZUJ1dHRvbihpZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlRmlsZUl0ZW0oaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2VuZERlbGV0ZVJlcXVlc3Q6IGZ1bmN0aW9uKGlkLCB1dWlkLCBhZGRpdGlvbmFsTWFuZGF0ZWRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmhpZGVEZWxldGVCdXR0b24oaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuc2hvd1NwaW5uZXIoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuc2V0U3RhdHVzVGV4dChpZCwgdGhpcy5fb3B0aW9ucy5kZWxldGVGaWxlLmRlbGV0aW5nU3RhdHVzVGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsZXRlSGFuZGxlci5zZW5kRGVsZXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3Nob3dEZWxldGVDb25maXJtOiBmdW5jdGlvbihpZCwgdXVpZCwgbWFuZGF0ZWRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSB0aGlzLmdldE5hbWUoaWQpLCBjb25maXJtTWVzc2FnZSA9IHRoaXMuX29wdGlvbnMuZGVsZXRlRmlsZS5jb25maXJtTWVzc2FnZS5yZXBsYWNlKC9cXHtmaWxlbmFtZVxcfS9nLCBmaWxlTmFtZSksIHV1aWQgPSB0aGlzLmdldFV1aWQoaWQpLCBkZWxldGVSZXF1ZXN0QXJncyA9IGFyZ3VtZW50cywgc2VsZiA9IHRoaXMsIHJldFZhbDtcbiAgICAgICAgICAgICAgICByZXRWYWwgPSB0aGlzLl9vcHRpb25zLnNob3dDb25maXJtKGNvbmZpcm1NZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAocXEuaXNHZW5lcmljUHJvbWlzZShyZXRWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFZhbC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2VuZERlbGV0ZVJlcXVlc3QuYXBwbHkoc2VsZiwgZGVsZXRlUmVxdWVzdEFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJldFZhbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2VuZERlbGV0ZVJlcXVlc3QuYXBwbHkoc2VsZiwgZGVsZXRlUmVxdWVzdEFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfYWRkVG9MaXN0OiBmdW5jdGlvbihpZCwgbmFtZSwgY2FubmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXBlbmREYXRhLCBwcmVwZW5kSW5kZXggPSAwLCBkb250RGlzcGxheSA9IHRoaXMuX2hhbmRsZXIuaXNQcm94aWVkKGlkKSAmJiB0aGlzLl9vcHRpb25zLnNjYWxpbmcuaGlkZVNjYWxlZCwgcmVjb3JkO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmRpc3BsYXkucHJlcGVuZEZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b3RhbEZpbGVzSW5CYXRjaCA+IDEgJiYgdGhpcy5fZmlsZXNJbkJhdGNoQWRkZWRUb1VpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlcGVuZEluZGV4ID0gdGhpcy5fZmlsZXNJbkJhdGNoQWRkZWRUb1VpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmVwZW5kRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBwcmVwZW5kSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjYW5uZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZGlzYWJsZUNhbmNlbEZvckZvcm1VcGxvYWRzICYmICFxcS5zdXBwb3J0ZWRGZWF0dXJlcy5hamF4VXBsb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmRpc2FibGVDYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuZ2V0VXBsb2Fkcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZWRQcm94eUdyb3VwID0gdGhpcy5faGFuZGxlZFByb3h5R3JvdXAgfHwgcmVjb3JkLnByb3h5R3JvdXBJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQucHJveHlHcm91cElkICE9PSB0aGlzLl9oYW5kbGVkUHJveHlHcm91cCB8fCAhcmVjb3JkLnByb3h5R3JvdXBJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuY2FuY2VsQWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlZFByb3h5R3JvdXAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYW5uZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5hZGRGaWxlVG9DYWNoZShpZCwgdGhpcy5fb3B0aW9ucy5mb3JtYXRGaWxlTmFtZShuYW1lKSwgcHJlcGVuZERhdGEsIGRvbnREaXNwbGF5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy51cGRhdGVUaHVtYm5haWwoaWQsIHRoaXMuX3RodW1ibmFpbFVybHNbaWRdLCB0cnVlLCB0aGlzLl9vcHRpb25zLnRodW1ibmFpbHMuY3VzdG9tUmVzaXplcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5hZGRGaWxlKGlkLCB0aGlzLl9vcHRpb25zLmZvcm1hdEZpbGVOYW1lKG5hbWUpLCBwcmVwZW5kRGF0YSwgZG9udERpc3BsYXkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmdlbmVyYXRlUHJldmlldyhpZCwgdGhpcy5nZXRGaWxlKGlkKSwgdGhpcy5fb3B0aW9ucy50aHVtYm5haWxzLmN1c3RvbVJlc2l6ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9maWxlc0luQmF0Y2hBZGRlZFRvVWkgKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAoY2FubmVkIHx8IHRoaXMuX29wdGlvbnMuZGlzcGxheS5maWxlU2l6ZU9uU3VibWl0ICYmIHFxLnN1cHBvcnRlZEZlYXR1cmVzLmFqYXhVcGxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUZpbGVTaXplKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2NsZWFyTGlzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5jbGVhckZpbGVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclN0b3JlZEZpbGVzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2Rpc3BsYXlGaWxlU2l6ZTogZnVuY3Rpb24oaWQsIGxvYWRlZFNpemUsIHRvdGFsU2l6ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKGlkKSwgc2l6ZUZvckRpc3BsYXkgPSB0aGlzLl9mb3JtYXRTaXplKHNpemUpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRlZFNpemUgIT09IHVuZGVmaW5lZCAmJiB0b3RhbFNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUZvckRpc3BsYXkgPSB0aGlzLl9mb3JtYXRQcm9ncmVzcyhsb2FkZWRTaXplLCB0b3RhbFNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcudXBkYXRlU2l6ZShpZCwgc2l6ZUZvckRpc3BsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfZm9ybWF0UHJvZ3Jlc3M6IGZ1bmN0aW9uKHVwbG9hZGVkU2l6ZSwgdG90YWxTaXplKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9vcHRpb25zLnRleHQuZm9ybWF0UHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcihuYW1lLCByZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKG5hbWUsIHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcihcIntwZXJjZW50fVwiLCBNYXRoLnJvdW5kKHVwbG9hZGVkU2l6ZSAvIHRvdGFsU2l6ZSAqIDEwMCkpO1xuICAgICAgICAgICAgICAgIHIoXCJ7dG90YWxfc2l6ZX1cIiwgdGhpcy5fZm9ybWF0U2l6ZSh0b3RhbFNpemUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY29udHJvbEZhaWx1cmVUZXh0RGlzcGxheTogZnVuY3Rpb24oaWQsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGUsIHJlc3BvbnNlUHJvcGVydHksIGZhaWx1cmVSZWFzb247XG4gICAgICAgICAgICAgICAgbW9kZSA9IHRoaXMuX29wdGlvbnMuZmFpbGVkVXBsb2FkVGV4dERpc3BsYXkubW9kZTtcbiAgICAgICAgICAgICAgICByZXNwb25zZVByb3BlcnR5ID0gdGhpcy5fb3B0aW9ucy5mYWlsZWRVcGxvYWRUZXh0RGlzcGxheS5yZXNwb25zZVByb3BlcnR5O1xuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSBcImN1c3RvbVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmVSZWFzb24gPSByZXNwb25zZVtyZXNwb25zZVByb3BlcnR5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmYWlsdXJlUmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlUmVhc29uID0gdGhpcy5fb3B0aW9ucy50ZXh0LmZhaWxVcGxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5zZXRTdGF0dXNUZXh0KGlkLCBmYWlsdXJlUmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZmFpbGVkVXBsb2FkVGV4dERpc3BsYXkuZW5hYmxlVG9vbHRpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXAoaWQsIGZhaWx1cmVSZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnNldFN0YXR1c1RleHQoaWQsIHRoaXMuX29wdGlvbnMudGV4dC5mYWlsVXBsb2FkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiZmFpbGVkVXBsb2FkVGV4dERpc3BsYXkubW9kZSB2YWx1ZSBvZiAnXCIgKyBtb2RlICsgXCInIGlzIG5vdCB2YWxpZFwiLCBcIndhcm5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9zaG93VG9vbHRpcDogZnVuY3Rpb24oaWQsIHRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLmdldEZpbGVDb250YWluZXIoaWQpLnRpdGxlID0gdGV4dDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2hvd0NhbmNlbExpbms6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmRpc2FibGVDYW5jZWxGb3JGb3JtVXBsb2FkcyB8fCBxcS5zdXBwb3J0ZWRGZWF0dXJlcy5hamF4VXBsb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuc2hvd0NhbmNlbChpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9pdGVtRXJyb3I6IGZ1bmN0aW9uKGNvZGUsIG5hbWUsIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX2l0ZW1FcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuc2hvd01lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2JhdGNoRXJyb3I6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQucHJvdG90eXBlLl9iYXRjaEVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5zaG93TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2V0dXBQYXN0ZVByb21wdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLm9uUGFzdGVSZWNlaXZlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHNlbGYuX29wdGlvbnMucGFzdGUubmFtZVByb21wdE1lc3NhZ2UsIGRlZmF1bHRWYWwgPSBzZWxmLl9vcHRpb25zLnBhc3RlLmRlZmF1bHROYW1lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fb3B0aW9ucy5zaG93UHJvbXB0KG1lc3NhZ2UsIGRlZmF1bHRWYWwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX2ZpbGVPckJsb2JSZWplY3RlZDogZnVuY3Rpb24oaWQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3RhbEZpbGVzSW5CYXRjaCAtPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX2ZpbGVPckJsb2JSZWplY3RlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9wcmVwYXJlSXRlbXNGb3JVcGxvYWQ6IGZ1bmN0aW9uKGl0ZW1zLCBwYXJhbXMsIGVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxGaWxlc0luQmF0Y2ggPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsZXNJbkJhdGNoQWRkZWRUb1VpID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQucHJvdG90eXBlLl9wcmVwYXJlSXRlbXNGb3JVcGxvYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWF5YmVVcGRhdGVUaHVtYm5haWw6IGZ1bmN0aW9uKGZpbGVJZCkge1xuICAgICAgICAgICAgICAgIHZhciB0aHVtYm5haWxVcmwgPSB0aGlzLl90aHVtYm5haWxVcmxzW2ZpbGVJZF0sIGZpbGVTdGF0dXMgPSB0aGlzLmdldFVwbG9hZHMoe1xuICAgICAgICAgICAgICAgICAgICBpZDogZmlsZUlkXG4gICAgICAgICAgICAgICAgfSkuc3RhdHVzO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlU3RhdHVzICE9PSBxcS5zdGF0dXMuREVMRVRFRCAmJiAodGh1bWJuYWlsVXJsIHx8IHRoaXMuX29wdGlvbnMudGh1bWJuYWlscy5wbGFjZWhvbGRlcnMud2FpdFVudGlsUmVzcG9uc2UgfHwgIXFxLnN1cHBvcnRlZEZlYXR1cmVzLmltYWdlUHJldmlld3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcudXBkYXRlVGh1bWJuYWlsKGZpbGVJZCwgdGh1bWJuYWlsVXJsLCB0aGlzLl9vcHRpb25zLnRodW1ibmFpbHMuY3VzdG9tUmVzaXplcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9hZGRDYW5uZWRGaWxlOiBmdW5jdGlvbihzZXNzaW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuX3BhcmVudC5wcm90b3R5cGUuX2FkZENhbm5lZEZpbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb0xpc3QoaWQsIHRoaXMuZ2V0TmFtZShpZCksIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuaGlkZVNwaW5uZXIoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcuaGlkZUNhbmNlbChpZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya0ZpbGVBc1N1Y2Nlc3NmdWwoaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2V0U2l6ZTogZnVuY3Rpb24oaWQsIG5ld1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQucHJvdG90eXBlLl9zZXRTaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy51cGRhdGVTaXplKGlkLCB0aGlzLl9mb3JtYXRTaXplKG5ld1NpemUpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfc2Vzc2lvblJlcXVlc3RDb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5hZGRDYWNoZVRvRG9tKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnByb3RvdHlwZS5fc2Vzc2lvblJlcXVlc3RDb21wbGV0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgcXEuRmluZVVwbG9hZGVyID0gZnVuY3Rpb24obywgbmFtZXNwYWNlKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG5hbWVzcGFjZSA/IHFxW25hbWVzcGFjZV0uRmluZVVwbG9hZGVyQmFzaWMgOiBxcS5GaW5lVXBsb2FkZXJCYXNpYztcbiAgICAgICAgdGhpcy5fcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLl9vcHRpb25zLCB7XG4gICAgICAgICAgICBlbGVtZW50OiBudWxsLFxuICAgICAgICAgICAgYnV0dG9uOiBudWxsLFxuICAgICAgICAgICAgbGlzdEVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICBkcmFnQW5kRHJvcDoge1xuICAgICAgICAgICAgICAgIGV4dHJhRHJvcHpvbmVzOiBbXSxcbiAgICAgICAgICAgICAgICByZXBvcnREaXJlY3RvcnlQYXRoczogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0UHJvZ3Jlc3M6IFwie3BlcmNlbnR9JSBvZiB7dG90YWxfc2l6ZX1cIixcbiAgICAgICAgICAgICAgICBmYWlsVXBsb2FkOiBcIlVwbG9hZCBmYWlsZWRcIixcbiAgICAgICAgICAgICAgICB3YWl0aW5nRm9yUmVzcG9uc2U6IFwiUHJvY2Vzc2luZy4uLlwiLFxuICAgICAgICAgICAgICAgIHBhdXNlZDogXCJQYXVzZWRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcInFxLXRlbXBsYXRlXCIsXG4gICAgICAgICAgICBjbGFzc2VzOiB7XG4gICAgICAgICAgICAgICAgcmV0cnlpbmc6IFwicXEtdXBsb2FkLXJldHJ5aW5nXCIsXG4gICAgICAgICAgICAgICAgcmV0cnlhYmxlOiBcInFxLXVwbG9hZC1yZXRyeWFibGVcIixcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBcInFxLXVwbG9hZC1zdWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgZmFpbDogXCJxcS11cGxvYWQtZmFpbFwiLFxuICAgICAgICAgICAgICAgIGVkaXRhYmxlOiBcInFxLWVkaXRhYmxlXCIsXG4gICAgICAgICAgICAgICAgaGlkZTogXCJxcS1oaWRlXCIsXG4gICAgICAgICAgICAgICAgZHJvcEFjdGl2ZTogXCJxcS11cGxvYWQtZHJvcC1hcmVhLWFjdGl2ZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmFpbGVkVXBsb2FkVGV4dERpc3BsYXk6IHtcbiAgICAgICAgICAgICAgICBtb2RlOiBcImRlZmF1bHRcIixcbiAgICAgICAgICAgICAgICByZXNwb25zZVByb3BlcnR5OiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZW5hYmxlVG9vbHRpcDogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICAgICAgdG9vTWFueUZpbGVzRXJyb3I6IFwiWW91IG1heSBvbmx5IGRyb3Agb25lIGZpbGVcIixcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZEJyb3dzZXI6IFwiVW5yZWNvdmVyYWJsZSBlcnJvciAtIHRoaXMgYnJvd3NlciBkb2VzIG5vdCBwZXJtaXQgZmlsZSB1cGxvYWRpbmcgb2YgYW55IGtpbmQuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXRyeToge1xuICAgICAgICAgICAgICAgIHNob3dBdXRvUmV0cnlOb3RlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF1dG9SZXRyeU5vdGU6IFwiUmV0cnlpbmcge3JldHJ5TnVtfS97bWF4QXV0b30uLi5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlbGV0ZUZpbGU6IHtcbiAgICAgICAgICAgICAgICBmb3JjZUNvbmZpcm06IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpcm1NZXNzYWdlOiBcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUge2ZpbGVuYW1lfT9cIixcbiAgICAgICAgICAgICAgICBkZWxldGluZ1N0YXR1c1RleHQ6IFwiRGVsZXRpbmcuLi5cIixcbiAgICAgICAgICAgICAgICBkZWxldGluZ0ZhaWxlZFRleHQ6IFwiRGVsZXRlIGZhaWxlZFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgICAgIGZpbGVTaXplT25TdWJtaXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHByZXBlbmRGaWxlczogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXN0ZToge1xuICAgICAgICAgICAgICAgIHByb21wdEZvck5hbWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5hbWVQcm9tcHRNZXNzYWdlOiBcIlBsZWFzZSBuYW1lIHRoaXMgaW1hZ2VcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRodW1ibmFpbHM6IHtcbiAgICAgICAgICAgICAgICBjdXN0b21SZXNpemVyOiBudWxsLFxuICAgICAgICAgICAgICAgIG1heENvdW50OiAwLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyczoge1xuICAgICAgICAgICAgICAgICAgICB3YWl0VW50aWxSZXNwb25zZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5vdEF2YWlsYWJsZVBhdGg6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHdhaXRpbmdQYXRoOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aW1lQmV0d2VlblRodW1iczogNzUwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NhbGluZzoge1xuICAgICAgICAgICAgICAgIGhpZGVTY2FsZWQ6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd01lc3NhZ2U6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fdGVtcGxhdGluZy5oYXNEaWFsb2coXCJhbGVydFwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fdGVtcGxhdGluZy5zaG93RGlhbG9nKFwiYWxlcnRcIiwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hbGVydChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dDb25maXJtOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3RlbXBsYXRpbmcuaGFzRGlhbG9nKFwiY29uZmlybVwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fdGVtcGxhdGluZy5zaG93RGlhbG9nKFwiY29uZmlybVwiLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmNvbmZpcm0obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dQcm9tcHQ6IGZ1bmN0aW9uKG1lc3NhZ2UsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl90ZW1wbGF0aW5nLmhhc0RpYWxvZyhcInByb21wdFwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fdGVtcGxhdGluZy5zaG93RGlhbG9nKFwicHJvbXB0XCIsIG1lc3NhZ2UsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wcm9tcHQobWVzc2FnZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBxcS5leHRlbmQodGhpcy5fb3B0aW9ucywgbywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRpbmcgPSBuZXcgcXEuVGVtcGxhdGluZyh7XG4gICAgICAgICAgICBsb2c6IHFxLmJpbmQodGhpcy5sb2csIHRoaXMpLFxuICAgICAgICAgICAgdGVtcGxhdGVJZE9yRWw6IHRoaXMuX29wdGlvbnMudGVtcGxhdGUsXG4gICAgICAgICAgICBjb250YWluZXJFbDogdGhpcy5fb3B0aW9ucy5lbGVtZW50LFxuICAgICAgICAgICAgZmlsZUNvbnRhaW5lckVsOiB0aGlzLl9vcHRpb25zLmxpc3RFbGVtZW50LFxuICAgICAgICAgICAgYnV0dG9uOiB0aGlzLl9vcHRpb25zLmJ1dHRvbixcbiAgICAgICAgICAgIGltYWdlR2VuZXJhdG9yOiB0aGlzLl9pbWFnZUdlbmVyYXRvcixcbiAgICAgICAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgICAgICAgICBoaWRlOiB0aGlzLl9vcHRpb25zLmNsYXNzZXMuaGlkZSxcbiAgICAgICAgICAgICAgICBlZGl0YWJsZTogdGhpcy5fb3B0aW9ucy5jbGFzc2VzLmVkaXRhYmxlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGltaXRzOiB7XG4gICAgICAgICAgICAgICAgbWF4VGh1bWJzOiB0aGlzLl9vcHRpb25zLnRodW1ibmFpbHMubWF4Q291bnQsXG4gICAgICAgICAgICAgICAgdGltZUJldHdlZW5UaHVtYnM6IHRoaXMuX29wdGlvbnMudGh1bWJuYWlscy50aW1lQmV0d2VlblRodW1ic1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyczoge1xuICAgICAgICAgICAgICAgIHdhaXRVbnRpbFVwZGF0ZTogdGhpcy5fb3B0aW9ucy50aHVtYm5haWxzLnBsYWNlaG9sZGVycy53YWl0VW50aWxSZXNwb25zZSxcbiAgICAgICAgICAgICAgICB0aHVtYm5haWxOb3RBdmFpbGFibGU6IHRoaXMuX29wdGlvbnMudGh1bWJuYWlscy5wbGFjZWhvbGRlcnMubm90QXZhaWxhYmxlUGF0aCxcbiAgICAgICAgICAgICAgICB3YWl0aW5nRm9yVGh1bWJuYWlsOiB0aGlzLl9vcHRpb25zLnRodW1ibmFpbHMucGxhY2Vob2xkZXJzLndhaXRpbmdQYXRoXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGV4dDogdGhpcy5fb3B0aW9ucy50ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy53b3JrYXJvdW5kcy5pb3M4U2FmYXJpVXBsb2FkcyAmJiBxcS5pb3M4MDAoKSAmJiBxcS5pb3NTYWZhcmkoKSkge1xuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGluZy5yZW5kZXJGYWlsdXJlKHRoaXMuX29wdGlvbnMubWVzc2FnZXMudW5zdXBwb3J0ZWRCcm93c2VySW9zOFNhZmFyaSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXFxLnN1cHBvcnRlZEZlYXR1cmVzLnVwbG9hZGluZyB8fCB0aGlzLl9vcHRpb25zLmNvcnMuZXhwZWN0ZWQgJiYgIXFxLnN1cHBvcnRlZEZlYXR1cmVzLnVwbG9hZENvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRpbmcucmVuZGVyRmFpbHVyZSh0aGlzLl9vcHRpb25zLm1lc3NhZ2VzLnVuc3VwcG9ydGVkQnJvd3Nlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwQ2FsbGJhY2tzKCk7XG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0aW5nLnJlbmRlcigpO1xuICAgICAgICAgICAgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX29wdGlvbnMuY2xhc3NlcztcbiAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5idXR0b24gJiYgdGhpcy5fdGVtcGxhdGluZy5nZXRCdXR0b24oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRCdXR0b25JZCA9IHRoaXMuX2NyZWF0ZVVwbG9hZEJ1dHRvbih7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuX3RlbXBsYXRpbmcuZ2V0QnV0dG9uKCksXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0aGlzLl9vcHRpb25zLnRleHQuZmlsZUlucHV0VGl0bGVcbiAgICAgICAgICAgICAgICB9KS5nZXRCdXR0b25JZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0dXBDbGlja0FuZEVkaXRFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICBpZiAocXEuRHJhZ0FuZERyb3AgJiYgcXEuc3VwcG9ydGVkRmVhdHVyZXMuZmlsZURyb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kbmQgPSB0aGlzLl9zZXR1cERyYWdBbmREcm9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5wYXN0ZS50YXJnZXRFbGVtZW50ICYmIHRoaXMuX29wdGlvbnMucGFzdGUucHJvbXB0Rm9yTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChxcS5QYXN0ZVN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dXBQYXN0ZVByb21wdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiUGFzdGUgc3VwcG9ydCBtb2R1bGUgbm90IGZvdW5kLlwiLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RvdGFsRmlsZXNJbkJhdGNoID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGVzSW5CYXRjaEFkZGVkVG9VaSA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHFxLmV4dGVuZChxcS5GaW5lVXBsb2FkZXIucHJvdG90eXBlLCBxcS5iYXNlUHVibGljQXBpKTtcbiAgICBxcS5leHRlbmQocXEuRmluZVVwbG9hZGVyLnByb3RvdHlwZSwgcXEuYmFzZVByaXZhdGVBcGkpO1xuICAgIHFxLmV4dGVuZChxcS5GaW5lVXBsb2FkZXIucHJvdG90eXBlLCBxcS51aVB1YmxpY0FwaSk7XG4gICAgcXEuZXh0ZW5kKHFxLkZpbmVVcGxvYWRlci5wcm90b3R5cGUsIHFxLnVpUHJpdmF0ZUFwaSk7XG4gICAgcXEuVGVtcGxhdGluZyA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBGSUxFX0lEX0FUVFIgPSBcInFxLWZpbGUtaWRcIiwgRklMRV9DTEFTU19QUkVGSVggPSBcInFxLWZpbGUtaWQtXCIsIFRIVU1CTkFJTF9NQVhfU0laRV9BVFRSID0gXCJxcS1tYXgtc2l6ZVwiLCBUSFVNQk5BSUxfU0VSVkVSX1NDQUxFX0FUVFIgPSBcInFxLXNlcnZlci1zY2FsZVwiLCBISURFX0RST1BaT05FX0FUVFIgPSBcInFxLWhpZGUtZHJvcHpvbmVcIiwgRFJPUFpQT05FX1RFWFRfQVRUUiA9IFwicXEtZHJvcC1hcmVhLXRleHRcIiwgSU5fUFJPR1JFU1NfQ0xBU1MgPSBcInFxLWluLXByb2dyZXNzXCIsIEhJRERFTl9GT1JFVkVSX0NMQVNTID0gXCJxcS1oaWRkZW4tZm9yZXZlclwiLCBmaWxlQmF0Y2ggPSB7XG4gICAgICAgICAgICBjb250ZW50OiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgICAgICBtYXA6IHt9XG4gICAgICAgIH0sIGlzQ2FuY2VsRGlzYWJsZWQgPSBmYWxzZSwgZ2VuZXJhdGVkVGh1bWJuYWlscyA9IDAsIHRodW1ibmFpbFF1ZXVlTW9uaXRvclJ1bm5pbmcgPSBmYWxzZSwgdGh1bWJHZW5lcmF0aW9uUXVldWUgPSBbXSwgdGh1bWJuYWlsTWF4U2l6ZSA9IC0xLCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbG9nOiBudWxsLFxuICAgICAgICAgICAgbGltaXRzOiB7XG4gICAgICAgICAgICAgICAgbWF4VGh1bWJzOiAwLFxuICAgICAgICAgICAgICAgIHRpbWVCZXR3ZWVuVGh1bWJzOiA3NTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZUlkT3JFbDogXCJxcS10ZW1wbGF0ZVwiLFxuICAgICAgICAgICAgY29udGFpbmVyRWw6IG51bGwsXG4gICAgICAgICAgICBmaWxlQ29udGFpbmVyRWw6IG51bGwsXG4gICAgICAgICAgICBidXR0b246IG51bGwsXG4gICAgICAgICAgICBpbWFnZUdlbmVyYXRvcjogbnVsbCxcbiAgICAgICAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgICAgICAgICBoaWRlOiBcInFxLWhpZGVcIixcbiAgICAgICAgICAgICAgICBlZGl0YWJsZTogXCJxcS1lZGl0YWJsZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGxhY2Vob2xkZXJzOiB7XG4gICAgICAgICAgICAgICAgd2FpdFVudGlsVXBkYXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aHVtYm5haWxOb3RBdmFpbGFibGU6IG51bGwsXG4gICAgICAgICAgICAgICAgd2FpdGluZ0ZvclRodW1ibmFpbDogbnVsbFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICBwYXVzZWQ6IFwiUGF1c2VkXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2VsZWN0b3JDbGFzc2VzID0ge1xuICAgICAgICAgICAgYnV0dG9uOiBcInFxLXVwbG9hZC1idXR0b24tc2VsZWN0b3JcIixcbiAgICAgICAgICAgIGFsZXJ0RGlhbG9nOiBcInFxLWFsZXJ0LWRpYWxvZy1zZWxlY3RvclwiLFxuICAgICAgICAgICAgZGlhbG9nQ2FuY2VsQnV0dG9uOiBcInFxLWNhbmNlbC1idXR0b24tc2VsZWN0b3JcIixcbiAgICAgICAgICAgIGNvbmZpcm1EaWFsb2c6IFwicXEtY29uZmlybS1kaWFsb2ctc2VsZWN0b3JcIixcbiAgICAgICAgICAgIGRpYWxvZ01lc3NhZ2U6IFwicXEtZGlhbG9nLW1lc3NhZ2Utc2VsZWN0b3JcIixcbiAgICAgICAgICAgIGRpYWxvZ09rQnV0dG9uOiBcInFxLW9rLWJ1dHRvbi1zZWxlY3RvclwiLFxuICAgICAgICAgICAgcHJvbXB0RGlhbG9nOiBcInFxLXByb21wdC1kaWFsb2ctc2VsZWN0b3JcIixcbiAgICAgICAgICAgIHVwbG9hZGVyOiBcInFxLXVwbG9hZGVyLXNlbGVjdG9yXCIsXG4gICAgICAgICAgICBkcm9wOiBcInFxLXVwbG9hZC1kcm9wLWFyZWEtc2VsZWN0b3JcIixcbiAgICAgICAgICAgIGxpc3Q6IFwicXEtdXBsb2FkLWxpc3Qtc2VsZWN0b3JcIixcbiAgICAgICAgICAgIHByb2dyZXNzQmFyQ29udGFpbmVyOiBcInFxLXByb2dyZXNzLWJhci1jb250YWluZXItc2VsZWN0b3JcIixcbiAgICAgICAgICAgIHByb2dyZXNzQmFyOiBcInFxLXByb2dyZXNzLWJhci1zZWxlY3RvclwiLFxuICAgICAgICAgICAgdG90YWxQcm9ncmVzc0JhckNvbnRhaW5lcjogXCJxcS10b3RhbC1wcm9ncmVzcy1iYXItY29udGFpbmVyLXNlbGVjdG9yXCIsXG4gICAgICAgICAgICB0b3RhbFByb2dyZXNzQmFyOiBcInFxLXRvdGFsLXByb2dyZXNzLWJhci1zZWxlY3RvclwiLFxuICAgICAgICAgICAgZmlsZTogXCJxcS11cGxvYWQtZmlsZS1zZWxlY3RvclwiLFxuICAgICAgICAgICAgc3Bpbm5lcjogXCJxcS11cGxvYWQtc3Bpbm5lci1zZWxlY3RvclwiLFxuICAgICAgICAgICAgc2l6ZTogXCJxcS11cGxvYWQtc2l6ZS1zZWxlY3RvclwiLFxuICAgICAgICAgICAgY2FuY2VsOiBcInFxLXVwbG9hZC1jYW5jZWwtc2VsZWN0b3JcIixcbiAgICAgICAgICAgIHBhdXNlOiBcInFxLXVwbG9hZC1wYXVzZS1zZWxlY3RvclwiLFxuICAgICAgICAgICAgY29udGludWVCdXR0b246IFwicXEtdXBsb2FkLWNvbnRpbnVlLXNlbGVjdG9yXCIsXG4gICAgICAgICAgICBkZWxldGVCdXR0b246IFwicXEtdXBsb2FkLWRlbGV0ZS1zZWxlY3RvclwiLFxuICAgICAgICAgICAgcmV0cnk6IFwicXEtdXBsb2FkLXJldHJ5LXNlbGVjdG9yXCIsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBcInFxLXVwbG9hZC1zdGF0dXMtdGV4dC1zZWxlY3RvclwiLFxuICAgICAgICAgICAgZWRpdEZpbGVuYW1lSW5wdXQ6IFwicXEtZWRpdC1maWxlbmFtZS1zZWxlY3RvclwiLFxuICAgICAgICAgICAgZWRpdE5hbWVJY29uOiBcInFxLWVkaXQtZmlsZW5hbWUtaWNvbi1zZWxlY3RvclwiLFxuICAgICAgICAgICAgZHJvcFRleHQ6IFwicXEtdXBsb2FkLWRyb3AtYXJlYS10ZXh0LXNlbGVjdG9yXCIsXG4gICAgICAgICAgICBkcm9wUHJvY2Vzc2luZzogXCJxcS1kcm9wLXByb2Nlc3Npbmctc2VsZWN0b3JcIixcbiAgICAgICAgICAgIGRyb3BQcm9jZXNzaW5nU3Bpbm5lcjogXCJxcS1kcm9wLXByb2Nlc3Npbmctc3Bpbm5lci1zZWxlY3RvclwiLFxuICAgICAgICAgICAgdGh1bWJuYWlsOiBcInFxLXRodW1ibmFpbC1zZWxlY3RvclwiXG4gICAgICAgIH0sIHByZXZpZXdHZW5lcmF0aW9uID0ge30sIGNhY2hlZFRodW1ibmFpbE5vdEF2YWlsYWJsZUltZyA9IG5ldyBxcS5Qcm9taXNlKCksIGNhY2hlZFdhaXRpbmdGb3JUaHVtYm5haWxJbWcgPSBuZXcgcXEuUHJvbWlzZSgpLCBsb2csIGlzRWRpdEVsZW1lbnRzRXhpc3QsIGlzUmV0cnlFbGVtZW50RXhpc3QsIHRlbXBsYXRlRG9tLCBjb250YWluZXIsIGZpbGVMaXN0LCBzaG93VGh1bWJuYWlscywgc2VydmVyU2NhbGUsIGNhY2hlVGh1bWJuYWlsUGxhY2Vob2xkZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbm90QXZhaWxhYmxlVXJsID0gb3B0aW9ucy5wbGFjZWhvbGRlcnMudGh1bWJuYWlsTm90QXZhaWxhYmxlLCB3YWl0aW5nVXJsID0gb3B0aW9ucy5wbGFjZWhvbGRlcnMud2FpdGluZ0ZvclRodW1ibmFpbCwgc3BlYyA9IHtcbiAgICAgICAgICAgICAgICBtYXhTaXplOiB0aHVtYm5haWxNYXhTaXplLFxuICAgICAgICAgICAgICAgIHNjYWxlOiBzZXJ2ZXJTY2FsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzaG93VGh1bWJuYWlscykge1xuICAgICAgICAgICAgICAgIGlmIChub3RBdmFpbGFibGVVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pbWFnZUdlbmVyYXRvci5nZW5lcmF0ZShub3RBdmFpbGFibGVVcmwsIG5ldyBJbWFnZSgpLCBzcGVjKS50aGVuKGZ1bmN0aW9uKHVwZGF0ZWRJbWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZFRodW1ibmFpbE5vdEF2YWlsYWJsZUltZy5zdWNjZXNzKHVwZGF0ZWRJbWcpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZFRodW1ibmFpbE5vdEF2YWlsYWJsZUltZy5mYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2coXCJQcm9ibGVtIGxvYWRpbmcgJ25vdCBhdmFpbGFibGUnIHBsYWNlaG9sZGVyIGltYWdlIGF0IFwiICsgbm90QXZhaWxhYmxlVXJsLCBcImVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWRUaHVtYm5haWxOb3RBdmFpbGFibGVJbWcuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod2FpdGluZ1VybCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmltYWdlR2VuZXJhdG9yLmdlbmVyYXRlKHdhaXRpbmdVcmwsIG5ldyBJbWFnZSgpLCBzcGVjKS50aGVuKGZ1bmN0aW9uKHVwZGF0ZWRJbWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZFdhaXRpbmdGb3JUaHVtYm5haWxJbWcuc3VjY2Vzcyh1cGRhdGVkSW1nKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRXYWl0aW5nRm9yVGh1bWJuYWlsSW1nLmZhaWx1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZyhcIlByb2JsZW0gbG9hZGluZyAnd2FpdGluZyBmb3IgdGh1bWJuYWlsJyBwbGFjZWhvbGRlciBpbWFnZSBhdCBcIiArIHdhaXRpbmdVcmwsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZFdhaXRpbmdGb3JUaHVtYm5haWxJbWcuZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZGlzcGxheVdhaXRpbmdJbWcgPSBmdW5jdGlvbih0aHVtYm5haWwpIHtcbiAgICAgICAgICAgIHZhciB3YWl0aW5nSW1nUGxhY2VtZW50ID0gbmV3IHFxLlByb21pc2UoKTtcbiAgICAgICAgICAgIGNhY2hlZFdhaXRpbmdGb3JUaHVtYm5haWxJbWcudGhlbihmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICAgICAgICBtYXliZVNjYWxlUGxhY2Vob2xkZXJWaWFDc3MoaW1nLCB0aHVtYm5haWwpO1xuICAgICAgICAgICAgICAgIGlmICghdGh1bWJuYWlsLnNyYykge1xuICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWwuc3JjID0gaW1nLnNyYztcbiAgICAgICAgICAgICAgICAgICAgdGh1bWJuYWlsLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJuYWlsLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93KHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0aW5nSW1nUGxhY2VtZW50LnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3YWl0aW5nSW1nUGxhY2VtZW50LnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBoaWRlKHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgd2FpdGluZ0ltZ1BsYWNlbWVudC5zdWNjZXNzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB3YWl0aW5nSW1nUGxhY2VtZW50O1xuICAgICAgICB9LCBnZW5lcmF0ZU5ld1ByZXZpZXcgPSBmdW5jdGlvbihpZCwgYmxvYiwgc3BlYykge1xuICAgICAgICAgICAgdmFyIHRodW1ibmFpbCA9IGdldFRodW1ibmFpbChpZCk7XG4gICAgICAgICAgICBsb2coXCJHZW5lcmF0aW5nIG5ldyB0aHVtYm5haWwgZm9yIFwiICsgaWQpO1xuICAgICAgICAgICAgYmxvYi5xcVRodW1ibmFpbElkID0gaWQ7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5pbWFnZUdlbmVyYXRvci5nZW5lcmF0ZShibG9iLCB0aHVtYm5haWwsIHNwZWMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkVGh1bWJuYWlscysrO1xuICAgICAgICAgICAgICAgIHNob3codGh1bWJuYWlsKTtcbiAgICAgICAgICAgICAgICBwcmV2aWV3R2VuZXJhdGlvbltpZF0uc3VjY2VzcygpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHJldmlld0dlbmVyYXRpb25baWRdLmZhaWx1cmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMucGxhY2Vob2xkZXJzLndhaXRVbnRpbFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZVNldERpc3BsYXlOb3RBdmFpbGFibGVJbWcoaWQsIHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGdlbmVyYXRlTmV4dFF1ZXVlZFByZXZpZXcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aHVtYkdlbmVyYXRpb25RdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHVtYm5haWxRdWV1ZU1vbml0b3JSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcXVldWVkVGh1bWJSZXF1ZXN0ID0gdGh1bWJHZW5lcmF0aW9uUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWVkVGh1bWJSZXF1ZXN0LnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWVkUHJldmlld1JlcXVlc3QocXVldWVkVGh1bWJSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzTmV3UXVldWVkUHJldmlld1JlcXVlc3QocXVldWVkVGh1bWJSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRodW1ibmFpbFF1ZXVlTW9uaXRvclJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZ2V0Q2FuY2VsID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUZW1wbGF0ZUVsKGdldEZpbGUoaWQpLCBzZWxlY3RvckNsYXNzZXMuY2FuY2VsKTtcbiAgICAgICAgfSwgZ2V0Q29udGludWUgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlRWwoZ2V0RmlsZShpZCksIHNlbGVjdG9yQ2xhc3Nlcy5jb250aW51ZUJ1dHRvbik7XG4gICAgICAgIH0sIGdldERpYWxvZyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUZW1wbGF0ZUVsKGNvbnRhaW5lciwgc2VsZWN0b3JDbGFzc2VzW3R5cGUgKyBcIkRpYWxvZ1wiXSk7XG4gICAgICAgIH0sIGdldERlbGV0ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VGVtcGxhdGVFbChnZXRGaWxlKGlkKSwgc2VsZWN0b3JDbGFzc2VzLmRlbGV0ZUJ1dHRvbik7XG4gICAgICAgIH0sIGdldERyb3BQcm9jZXNzaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VGVtcGxhdGVFbChjb250YWluZXIsIHNlbGVjdG9yQ2xhc3Nlcy5kcm9wUHJvY2Vzc2luZyk7XG4gICAgICAgIH0sIGdldEVkaXRJY29uID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUZW1wbGF0ZUVsKGdldEZpbGUoaWQpLCBzZWxlY3RvckNsYXNzZXMuZWRpdE5hbWVJY29uKTtcbiAgICAgICAgfSwgZ2V0RmlsZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZUJhdGNoLm1hcFtpZF0gfHwgcXEoZmlsZUxpc3QpLmdldEZpcnN0QnlDbGFzcyhGSUxFX0NMQVNTX1BSRUZJWCArIGlkKTtcbiAgICAgICAgfSwgZ2V0RmlsZW5hbWUgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlRWwoZ2V0RmlsZShpZCksIHNlbGVjdG9yQ2xhc3Nlcy5maWxlKTtcbiAgICAgICAgfSwgZ2V0UGF1c2UgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlRWwoZ2V0RmlsZShpZCksIHNlbGVjdG9yQ2xhc3Nlcy5wYXVzZSk7XG4gICAgICAgIH0sIGdldFByb2dyZXNzID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlRWwoY29udGFpbmVyLCBzZWxlY3RvckNsYXNzZXMudG90YWxQcm9ncmVzc0JhckNvbnRhaW5lcikgfHwgZ2V0VGVtcGxhdGVFbChjb250YWluZXIsIHNlbGVjdG9yQ2xhc3Nlcy50b3RhbFByb2dyZXNzQmFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRUZW1wbGF0ZUVsKGdldEZpbGUoaWQpLCBzZWxlY3RvckNsYXNzZXMucHJvZ3Jlc3NCYXJDb250YWluZXIpIHx8IGdldFRlbXBsYXRlRWwoZ2V0RmlsZShpZCksIHNlbGVjdG9yQ2xhc3Nlcy5wcm9ncmVzc0Jhcik7XG4gICAgICAgIH0sIGdldFJldHJ5ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUZW1wbGF0ZUVsKGdldEZpbGUoaWQpLCBzZWxlY3RvckNsYXNzZXMucmV0cnkpO1xuICAgICAgICB9LCBnZXRTaXplID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRUZW1wbGF0ZUVsKGdldEZpbGUoaWQpLCBzZWxlY3RvckNsYXNzZXMuc2l6ZSk7XG4gICAgICAgIH0sIGdldFNwaW5uZXIgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlRWwoZ2V0RmlsZShpZCksIHNlbGVjdG9yQ2xhc3Nlcy5zcGlubmVyKTtcbiAgICAgICAgfSwgZ2V0VGVtcGxhdGVFbCA9IGZ1bmN0aW9uKGNvbnRleHQsIGNzc0NsYXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dCAmJiBxcShjb250ZXh0KS5nZXRGaXJzdEJ5Q2xhc3MoY3NzQ2xhc3MpO1xuICAgICAgICB9LCBnZXRUaHVtYm5haWwgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNob3dUaHVtYm5haWxzICYmIGdldFRlbXBsYXRlRWwoZ2V0RmlsZShpZCksIHNlbGVjdG9yQ2xhc3Nlcy50aHVtYm5haWwpO1xuICAgICAgICB9LCBoaWRlID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGVsICYmIHFxKGVsKS5hZGRDbGFzcyhvcHRpb25zLmNsYXNzZXMuaGlkZSk7XG4gICAgICAgIH0sIG1heWJlU2NhbGVQbGFjZWhvbGRlclZpYUNzcyA9IGZ1bmN0aW9uKHBsYWNlaG9sZGVyLCB0aHVtYm5haWwpIHtcbiAgICAgICAgICAgIHZhciBtYXhXaWR0aCA9IHBsYWNlaG9sZGVyLnN0eWxlLm1heFdpZHRoLCBtYXhIZWlnaHQgPSBwbGFjZWhvbGRlci5zdHlsZS5tYXhIZWlnaHQ7XG4gICAgICAgICAgICBpZiAobWF4SGVpZ2h0ICYmIG1heFdpZHRoICYmICF0aHVtYm5haWwuc3R5bGUubWF4V2lkdGggJiYgIXRodW1ibmFpbC5zdHlsZS5tYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBxcSh0aHVtYm5haWwpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiBtYXhXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgbWF5YmVTZXREaXNwbGF5Tm90QXZhaWxhYmxlSW1nID0gZnVuY3Rpb24oaWQsIHRodW1ibmFpbCkge1xuICAgICAgICAgICAgdmFyIHByZXZpZXdpbmcgPSBwcmV2aWV3R2VuZXJhdGlvbltpZF0gfHwgbmV3IHFxLlByb21pc2UoKS5mYWlsdXJlKCksIG5vdEF2YWlsYWJsZUltZ1BsYWNlbWVudCA9IG5ldyBxcS5Qcm9taXNlKCk7XG4gICAgICAgICAgICBjYWNoZWRUaHVtYm5haWxOb3RBdmFpbGFibGVJbWcudGhlbihmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgICAgICAgICBwcmV2aWV3aW5nLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdEF2YWlsYWJsZUltZ1BsYWNlbWVudC5zdWNjZXNzKCk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heWJlU2NhbGVQbGFjZWhvbGRlclZpYUNzcyhpbWcsIHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbC5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90QXZhaWxhYmxlSW1nUGxhY2VtZW50LnN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGh1bWJuYWlsLnNyYyA9IGltZy5zcmM7XG4gICAgICAgICAgICAgICAgICAgIHNob3codGh1bWJuYWlsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5vdEF2YWlsYWJsZUltZ1BsYWNlbWVudDtcbiAgICAgICAgfSwgcGFyc2VBbmRHZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNjcmlwdEVsLCBzY3JpcHRIdG1sLCBmaWxlTGlzdE5vZGUsIHRlbXBUZW1wbGF0ZUVsLCBmaWxlTGlzdEVsLCBkZWZhdWx0QnV0dG9uLCBkcm9wQXJlYSwgdGh1bWJuYWlsLCBkcm9wUHJvY2Vzc2luZywgZHJvcFRleHRFbCwgdXBsb2FkZXJFbDtcbiAgICAgICAgICAgIGxvZyhcIlBhcnNpbmcgdGVtcGxhdGVcIik7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50ZW1wbGF0ZUlkT3JFbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IE1VU1Qgc3BlY2lmeSBlaXRoZXIgYSB0ZW1wbGF0ZSBlbGVtZW50IG9yIElEIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxcS5pc1N0cmluZyhvcHRpb25zLnRlbXBsYXRlSWRPckVsKSkge1xuICAgICAgICAgICAgICAgIHNjcmlwdEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy50ZW1wbGF0ZUlkT3JFbCk7XG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdEVsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihxcS5mb3JtYXQoXCJDYW5ub3QgZmluZCB0ZW1wbGF0ZSBzY3JpcHQgYXQgSUQgJ3t9JyFcIiwgb3B0aW9ucy50ZW1wbGF0ZUlkT3JFbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY3JpcHRIdG1sID0gc2NyaXB0RWwuaW5uZXJIVE1MO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50ZW1wbGF0ZUlkT3JFbC5pbm5lckhUTUwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgaGF2ZSBzcGVjaWZpZWQgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIHRlbXBsYXRlIG9wdGlvbiEgIFwiICsgXCJJdCBtdXN0IGJlIGFuIElEIG9yIGFuIEVsZW1lbnQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY3JpcHRIdG1sID0gb3B0aW9ucy50ZW1wbGF0ZUlkT3JFbC5pbm5lckhUTUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY3JpcHRIdG1sID0gcXEudHJpbVN0cihzY3JpcHRIdG1sKTtcbiAgICAgICAgICAgIHRlbXBUZW1wbGF0ZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRlbXBUZW1wbGF0ZUVsLmFwcGVuZENoaWxkKHFxLnRvRWxlbWVudChzY3JpcHRIdG1sKSk7XG4gICAgICAgICAgICB1cGxvYWRlckVsID0gcXEodGVtcFRlbXBsYXRlRWwpLmdldEZpcnN0QnlDbGFzcyhzZWxlY3RvckNsYXNzZXMudXBsb2FkZXIpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEJ1dHRvbiA9IHFxKHRlbXBUZW1wbGF0ZUVsKS5nZXRGaXJzdEJ5Q2xhc3Moc2VsZWN0b3JDbGFzc2VzLmJ1dHRvbik7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgcXEoZGVmYXVsdEJ1dHRvbikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFxcS5EcmFnQW5kRHJvcCB8fCAhcXEuc3VwcG9ydGVkRmVhdHVyZXMuZmlsZURyb3ApIHtcbiAgICAgICAgICAgICAgICBkcm9wUHJvY2Vzc2luZyA9IHFxKHRlbXBUZW1wbGF0ZUVsKS5nZXRGaXJzdEJ5Q2xhc3Moc2VsZWN0b3JDbGFzc2VzLmRyb3BQcm9jZXNzaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAoZHJvcFByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcXEoZHJvcFByb2Nlc3NpbmcpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyb3BBcmVhID0gcXEodGVtcFRlbXBsYXRlRWwpLmdldEZpcnN0QnlDbGFzcyhzZWxlY3RvckNsYXNzZXMuZHJvcCk7XG4gICAgICAgICAgICBpZiAoZHJvcEFyZWEgJiYgIXFxLkRyYWdBbmREcm9wKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiRG5EIG1vZHVsZSB1bmF2YWlsYWJsZS5cIiwgXCJpbmZvXCIpO1xuICAgICAgICAgICAgICAgIHFxKGRyb3BBcmVhKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcXEuc3VwcG9ydGVkRmVhdHVyZXMuZmlsZURyb3ApIHtcbiAgICAgICAgICAgICAgICB1cGxvYWRlckVsLnJlbW92ZUF0dHJpYnV0ZShEUk9QWlBPTkVfVEVYVF9BVFRSKTtcbiAgICAgICAgICAgICAgICBpZiAoZHJvcEFyZWEgJiYgcXEoZHJvcEFyZWEpLmhhc0F0dHJpYnV0ZShISURFX0RST1BaT05FX0FUVFIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxKGRyb3BBcmVhKS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogXCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChxcSh1cGxvYWRlckVsKS5oYXNBdHRyaWJ1dGUoRFJPUFpQT05FX1RFWFRfQVRUUikgJiYgZHJvcEFyZWEpIHtcbiAgICAgICAgICAgICAgICBkcm9wVGV4dEVsID0gcXEoZHJvcEFyZWEpLmdldEZpcnN0QnlDbGFzcyhzZWxlY3RvckNsYXNzZXMuZHJvcFRleHQpO1xuICAgICAgICAgICAgICAgIGRyb3BUZXh0RWwgJiYgcXEoZHJvcFRleHRFbCkucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHVtYm5haWwgPSBxcSh0ZW1wVGVtcGxhdGVFbCkuZ2V0Rmlyc3RCeUNsYXNzKHNlbGVjdG9yQ2xhc3Nlcy50aHVtYm5haWwpO1xuICAgICAgICAgICAgaWYgKCFzaG93VGh1bWJuYWlscykge1xuICAgICAgICAgICAgICAgIHRodW1ibmFpbCAmJiBxcSh0aHVtYm5haWwpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aHVtYm5haWwpIHtcbiAgICAgICAgICAgICAgICB0aHVtYm5haWxNYXhTaXplID0gcGFyc2VJbnQodGh1bWJuYWlsLmdldEF0dHJpYnV0ZShUSFVNQk5BSUxfTUFYX1NJWkVfQVRUUikpO1xuICAgICAgICAgICAgICAgIHRodW1ibmFpbE1heFNpemUgPSB0aHVtYm5haWxNYXhTaXplID4gMCA/IHRodW1ibmFpbE1heFNpemUgOiBudWxsO1xuICAgICAgICAgICAgICAgIHNlcnZlclNjYWxlID0gcXEodGh1bWJuYWlsKS5oYXNBdHRyaWJ1dGUoVEhVTUJOQUlMX1NFUlZFUl9TQ0FMRV9BVFRSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNob3dUaHVtYm5haWxzID0gc2hvd1RodW1ibmFpbHMgJiYgdGh1bWJuYWlsO1xuICAgICAgICAgICAgaXNFZGl0RWxlbWVudHNFeGlzdCA9IHFxKHRlbXBUZW1wbGF0ZUVsKS5nZXRCeUNsYXNzKHNlbGVjdG9yQ2xhc3Nlcy5lZGl0RmlsZW5hbWVJbnB1dCkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIGlzUmV0cnlFbGVtZW50RXhpc3QgPSBxcSh0ZW1wVGVtcGxhdGVFbCkuZ2V0QnlDbGFzcyhzZWxlY3RvckNsYXNzZXMucmV0cnkpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBmaWxlTGlzdE5vZGUgPSBxcSh0ZW1wVGVtcGxhdGVFbCkuZ2V0Rmlyc3RCeUNsYXNzKHNlbGVjdG9yQ2xhc3Nlcy5saXN0KTtcbiAgICAgICAgICAgIGlmIChmaWxlTGlzdE5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHRoZSBmaWxlIGxpc3QgY29udGFpbmVyIGluIHRoZSB0ZW1wbGF0ZSFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlTGlzdEVsID0gZmlsZUxpc3ROb2RlLmNoaWxkcmVuWzBdLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgIGZpbGVMaXN0Tm9kZS5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHRlbXBUZW1wbGF0ZUVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiRElBTE9HXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaWFsb2dcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2coXCJUZW1wbGF0ZSBwYXJzaW5nIGNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcFRlbXBsYXRlRWwsXG4gICAgICAgICAgICAgICAgZmlsZVRlbXBsYXRlOiBmaWxlTGlzdEVsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBwcmVwZW5kRmlsZSA9IGZ1bmN0aW9uKGVsLCBpbmRleCwgZmlsZUxpc3QpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRFbCA9IGZpbGVMaXN0LCBiZWZvcmVFbCA9IHBhcmVudEVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlRWwgPSBxcShwYXJlbnRFbCkuY2hpbGRyZW4oKVtpbmRleF0ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUoZWwsIGJlZm9yZUVsKTtcbiAgICAgICAgfSwgcHJvY2Vzc05ld1F1ZXVlZFByZXZpZXdSZXF1ZXN0ID0gZnVuY3Rpb24ocXVldWVkVGh1bWJSZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBxdWV1ZWRUaHVtYlJlcXVlc3QuaWQsIG9wdEZpbGVPckJsb2IgPSBxdWV1ZWRUaHVtYlJlcXVlc3Qub3B0RmlsZU9yQmxvYiwgcmVsYXRlZFRodW1ibmFpbElkID0gb3B0RmlsZU9yQmxvYiAmJiBvcHRGaWxlT3JCbG9iLnFxVGh1bWJuYWlsSWQsIHRodW1ibmFpbCA9IGdldFRodW1ibmFpbChpZCksIHNwZWMgPSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tUmVzaXplRnVuY3Rpb246IHF1ZXVlZFRodW1iUmVxdWVzdC5jdXN0b21SZXNpemVGdW5jdGlvbixcbiAgICAgICAgICAgICAgICBtYXhTaXplOiB0aHVtYm5haWxNYXhTaXplLFxuICAgICAgICAgICAgICAgIG9yaWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzY2FsZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChxcS5zdXBwb3J0ZWRGZWF0dXJlcy5pbWFnZVByZXZpZXdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRodW1ibmFpbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5saW1pdHMubWF4VGh1bWJzICYmIG9wdGlvbnMubGltaXRzLm1heFRodW1icyA8PSBnZW5lcmF0ZWRUaHVtYm5haWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVNldERpc3BsYXlOb3RBdmFpbGFibGVJbWcoaWQsIHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU5leHRRdWV1ZWRQcmV2aWV3KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5V2FpdGluZ0ltZyh0aHVtYm5haWwpLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlld0dlbmVyYXRpb25baWRdID0gbmV3IHFxLlByb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aWV3R2VuZXJhdGlvbltpZF0uZG9uZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChnZW5lcmF0ZU5leHRRdWV1ZWRQcmV2aWV3LCBvcHRpb25zLmxpbWl0cy50aW1lQmV0d2VlblRodW1icyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0ZWRUaHVtYm5haWxJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUNhY2hlZFByZXZpZXcoaWQsIHJlbGF0ZWRUaHVtYm5haWxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVOZXdQcmV2aWV3KGlkLCBvcHRGaWxlT3JCbG9iLCBzcGVjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTmV4dFF1ZXVlZFByZXZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRodW1ibmFpbCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlXYWl0aW5nSW1nKHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVOZXh0UXVldWVkUHJldmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBwcm9jZXNzVXBkYXRlUXVldWVkUHJldmlld1JlcXVlc3QgPSBmdW5jdGlvbihxdWV1ZWRUaHVtYlJlcXVlc3QpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHF1ZXVlZFRodW1iUmVxdWVzdC5pZCwgdGh1bWJuYWlsVXJsID0gcXVldWVkVGh1bWJSZXF1ZXN0LnRodW1ibmFpbFVybCwgc2hvd1dhaXRpbmdJbWcgPSBxdWV1ZWRUaHVtYlJlcXVlc3Quc2hvd1dhaXRpbmdJbWcsIHRodW1ibmFpbCA9IGdldFRodW1ibmFpbChpZCksIHNwZWMgPSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tUmVzaXplRnVuY3Rpb246IHF1ZXVlZFRodW1iUmVxdWVzdC5jdXN0b21SZXNpemVGdW5jdGlvbixcbiAgICAgICAgICAgICAgICBzY2FsZTogc2VydmVyU2NhbGUsXG4gICAgICAgICAgICAgICAgbWF4U2l6ZTogdGh1bWJuYWlsTWF4U2l6ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aHVtYm5haWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGh1bWJuYWlsVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxpbWl0cy5tYXhUaHVtYnMgJiYgb3B0aW9ucy5saW1pdHMubWF4VGh1bWJzIDw9IGdlbmVyYXRlZFRodW1ibmFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlU2V0RGlzcGxheU5vdEF2YWlsYWJsZUltZyhpZCwgdGh1bWJuYWlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTmV4dFF1ZXVlZFByZXZpZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG93V2FpdGluZ0ltZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlXYWl0aW5nSW1nKHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5pbWFnZUdlbmVyYXRvci5nZW5lcmF0ZSh0aHVtYm5haWxVcmwsIHRodW1ibmFpbCwgc3BlYykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93KHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkVGh1bWJuYWlscysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZ2VuZXJhdGVOZXh0UXVldWVkUHJldmlldywgb3B0aW9ucy5saW1pdHMudGltZUJldHdlZW5UaHVtYnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVTZXREaXNwbGF5Tm90QXZhaWxhYmxlSW1nKGlkLCB0aHVtYm5haWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZ2VuZXJhdGVOZXh0UXVldWVkUHJldmlldywgb3B0aW9ucy5saW1pdHMudGltZUJldHdlZW5UaHVtYnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXliZVNldERpc3BsYXlOb3RBdmFpbGFibGVJbWcoaWQsIHRodW1ibmFpbCk7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTmV4dFF1ZXVlZFByZXZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNldFByb2dyZXNzQmFyV2lkdGggPSBmdW5jdGlvbihpZCwgcGVyY2VudCkge1xuICAgICAgICAgICAgdmFyIGJhciA9IGdldFByb2dyZXNzKGlkKSwgcHJvZ3Jlc3NCYXJTZWxlY3RvciA9IGlkID09IG51bGwgPyBzZWxlY3RvckNsYXNzZXMudG90YWxQcm9ncmVzc0JhciA6IHNlbGVjdG9yQ2xhc3Nlcy5wcm9ncmVzc0JhcjtcbiAgICAgICAgICAgIGlmIChiYXIgJiYgIXFxKGJhcikuaGFzQ2xhc3MocHJvZ3Jlc3NCYXJTZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICBiYXIgPSBxcShiYXIpLmdldEZpcnN0QnlDbGFzcyhwcm9ncmVzc0JhclNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiYXIpIHtcbiAgICAgICAgICAgICAgICBxcShiYXIpLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwZXJjZW50ICsgXCIlXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBiYXIuc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW5vd1wiLCBwZXJjZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2hvdyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBlbCAmJiBxcShlbCkucmVtb3ZlQ2xhc3Mob3B0aW9ucy5jbGFzc2VzLmhpZGUpO1xuICAgICAgICB9LCB1c2VDYWNoZWRQcmV2aWV3ID0gZnVuY3Rpb24odGFyZ2V0VGh1bWJuYWlsSWQsIGNhY2hlZFRodW1ibmFpbElkKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0VGh1bWJuYWlsID0gZ2V0VGh1bWJuYWlsKHRhcmdldFRodW1ibmFpbElkKSwgY2FjaGVkVGh1bWJuYWlsID0gZ2V0VGh1bWJuYWlsKGNhY2hlZFRodW1ibmFpbElkKTtcbiAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJJRCB7fSBpcyB0aGUgc2FtZSBmaWxlIGFzIElEIHt9LiAgV2lsbCB1c2UgZ2VuZXJhdGVkIHRodW1ibmFpbCBmcm9tIElEIHt9IGluc3RlYWQuXCIsIHRhcmdldFRodW1ibmFpbElkLCBjYWNoZWRUaHVtYm5haWxJZCwgY2FjaGVkVGh1bWJuYWlsSWQpKTtcbiAgICAgICAgICAgIHByZXZpZXdHZW5lcmF0aW9uW2NhY2hlZFRodW1ibmFpbElkXS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZFRodW1ibmFpbHMrKztcbiAgICAgICAgICAgICAgICBwcmV2aWV3R2VuZXJhdGlvblt0YXJnZXRUaHVtYm5haWxJZF0uc3VjY2VzcygpO1xuICAgICAgICAgICAgICAgIGxvZyhxcS5mb3JtYXQoXCJOb3cgdXNpbmcgcHJldmlvdXNseSBnZW5lcmF0ZWQgdGh1bWJuYWlsIGNyZWF0ZWQgZm9yIElEIHt9IG9uIElEIHt9LlwiLCBjYWNoZWRUaHVtYm5haWxJZCwgdGFyZ2V0VGh1bWJuYWlsSWQpKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRUaHVtYm5haWwuc3JjID0gY2FjaGVkVGh1bWJuYWlsLnNyYztcbiAgICAgICAgICAgICAgICBzaG93KHRhcmdldFRodW1ibmFpbCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcmV2aWV3R2VuZXJhdGlvblt0YXJnZXRUaHVtYm5haWxJZF0uZmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5wbGFjZWhvbGRlcnMud2FpdFVudGlsVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heWJlU2V0RGlzcGxheU5vdEF2YWlsYWJsZUltZyh0YXJnZXRUaHVtYm5haWxJZCwgdGFyZ2V0VGh1bWJuYWlsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcXEuZXh0ZW5kKG9wdGlvbnMsIHNwZWMpO1xuICAgICAgICBsb2cgPSBvcHRpb25zLmxvZztcbiAgICAgICAgaWYgKCFxcS5zdXBwb3J0ZWRGZWF0dXJlcy5pbWFnZVByZXZpZXdzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmxpbWl0cy50aW1lQmV0d2VlblRodW1icyA9IDA7XG4gICAgICAgICAgICBvcHRpb25zLmxpbWl0cy5tYXhUaHVtYnMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyRWw7XG4gICAgICAgIHNob3dUaHVtYm5haWxzID0gb3B0aW9ucy5pbWFnZUdlbmVyYXRvciAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB0ZW1wbGF0ZURvbSA9IHBhcnNlQW5kR2V0VGVtcGxhdGUoKTtcbiAgICAgICAgY2FjaGVUaHVtYm5haWxQbGFjZWhvbGRlcnMoKTtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIHtcbiAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiUmVuZGVyaW5nIHRlbXBsYXRlIGluIERPTS5cIik7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkVGh1bWJuYWlscyA9IDA7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRlbXBsYXRlRG9tLnRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgaGlkZShnZXREcm9wUHJvY2Vzc2luZygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVUb3RhbFByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgZmlsZUxpc3QgPSBvcHRpb25zLmZpbGVDb250YWluZXJFbCB8fCBnZXRUZW1wbGF0ZUVsKGNvbnRhaW5lciwgc2VsZWN0b3JDbGFzc2VzLmxpc3QpO1xuICAgICAgICAgICAgICAgIGxvZyhcIlRlbXBsYXRlIHJlbmRlcmluZyBjb21wbGV0ZVwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW5kZXJGYWlsdXJlOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbnRSZW5kZXJFbCA9IHFxLnRvRWxlbWVudChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudFJlbmRlckVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhckZpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmaWxlTGlzdC5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc2FibGVDYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlzQ2FuY2VsRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEZpbGU6IGZ1bmN0aW9uKGlkLCBuYW1lLCBwcmVwZW5kSW5mbywgaGlkZUZvcmV2ZXIsIGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVFbCA9IHRlbXBsYXRlRG9tLmZpbGVUZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSksIGZpbGVOYW1lRWwgPSBnZXRUZW1wbGF0ZUVsKGZpbGVFbCwgc2VsZWN0b3JDbGFzc2VzLmZpbGUpLCB1cGxvYWRlckVsID0gZ2V0VGVtcGxhdGVFbChjb250YWluZXIsIHNlbGVjdG9yQ2xhc3Nlcy51cGxvYWRlciksIGZpbGVDb250YWluZXIgPSBiYXRjaCA/IGZpbGVCYXRjaC5jb250ZW50IDogZmlsZUxpc3QsIHRodW1iO1xuICAgICAgICAgICAgICAgIGlmIChiYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBmaWxlQmF0Y2gubWFwW2lkXSA9IGZpbGVFbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXEoZmlsZUVsKS5hZGRDbGFzcyhGSUxFX0NMQVNTX1BSRUZJWCArIGlkKTtcbiAgICAgICAgICAgICAgICB1cGxvYWRlckVsLnJlbW92ZUF0dHJpYnV0ZShEUk9QWlBPTkVfVEVYVF9BVFRSKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWVFbCkge1xuICAgICAgICAgICAgICAgICAgICBxcShmaWxlTmFtZUVsKS5zZXRUZXh0KG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZUVsLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWxlRWwuc2V0QXR0cmlidXRlKEZJTEVfSURfQVRUUiwgaWQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVwZW5kSW5mbykge1xuICAgICAgICAgICAgICAgICAgICBwcmVwZW5kRmlsZShmaWxlRWwsIHByZXBlbmRJbmZvLmluZGV4LCBmaWxlQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWxlQ29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGVFbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoaWRlRm9yZXZlcikge1xuICAgICAgICAgICAgICAgICAgICBmaWxlRWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICBxcShmaWxlRWwpLmFkZENsYXNzKEhJRERFTl9GT1JFVkVSX0NMQVNTKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoaWRlKGdldFByb2dyZXNzKGlkKSk7XG4gICAgICAgICAgICAgICAgICAgIGhpZGUoZ2V0U2l6ZShpZCkpO1xuICAgICAgICAgICAgICAgICAgICBoaWRlKGdldERlbGV0ZShpZCkpO1xuICAgICAgICAgICAgICAgICAgICBoaWRlKGdldFJldHJ5KGlkKSk7XG4gICAgICAgICAgICAgICAgICAgIGhpZGUoZ2V0UGF1c2UoaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZShnZXRDb250aW51ZShpZCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDYW5jZWxEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlQ2FuY2VsKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHVtYiA9IGdldFRodW1ibmFpbChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aHVtYiAmJiAhdGh1bWIuc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRXYWl0aW5nRm9yVGh1bWJuYWlsSW1nLnRoZW4oZnVuY3Rpb24od2FpdGluZ0ltZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iLnNyYyA9IHdhaXRpbmdJbWcuc3JjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nSW1nLnN0eWxlLm1heEhlaWdodCAmJiB3YWl0aW5nSW1nLnN0eWxlLm1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFxKHRodW1iKS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiB3YWl0aW5nSW1nLnN0eWxlLm1heEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiB3YWl0aW5nSW1nLnN0eWxlLm1heFdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93KHRodW1iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEZpbGVUb0NhY2hlOiBmdW5jdGlvbihpZCwgbmFtZSwgcHJlcGVuZEluZm8sIGhpZGVGb3JldmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGaWxlKGlkLCBuYW1lLCBwcmVwZW5kSW5mbywgaGlkZUZvcmV2ZXIsIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZENhY2hlVG9Eb206IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZpbGVMaXN0LmFwcGVuZENoaWxkKGZpbGVCYXRjaC5jb250ZW50KTtcbiAgICAgICAgICAgICAgICBmaWxlQmF0Y2guY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICBmaWxlQmF0Y2gubWFwID0ge307XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlRmlsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBxcShnZXRGaWxlKGlkKSkucmVtb3ZlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RmlsZUlkOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IGVsO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUuZ2V0QXR0cmlidXRlKEZJTEVfSURfQVRUUikgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChjdXJyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoRklMRV9JRF9BVFRSKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEZpbGVMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUxpc3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFya0ZpbGVuYW1lRWRpdGFibGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gZ2V0RmlsZW5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lICYmIHFxKGZpbGVuYW1lKS5hZGRDbGFzcyhvcHRpb25zLmNsYXNzZXMuZWRpdGFibGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZUZpbGVuYW1lOiBmdW5jdGlvbihpZCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZUVsID0gZ2V0RmlsZW5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlbmFtZUVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHFxKGZpbGVuYW1lRWwpLnNldFRleHQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lRWwuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGVGaWxlbmFtZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBoaWRlKGdldEZpbGVuYW1lKGlkKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd0ZpbGVuYW1lOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHNob3coZ2V0RmlsZW5hbWUoaWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0ZpbGVOYW1lOiBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxcShlbCkuaGFzQ2xhc3Moc2VsZWN0b3JDbGFzc2VzLmZpbGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEJ1dHRvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuYnV0dG9uIHx8IGdldFRlbXBsYXRlRWwoY29udGFpbmVyLCBzZWxlY3RvckNsYXNzZXMuYnV0dG9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaWRlRHJvcFByb2Nlc3Npbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGhpZGUoZ2V0RHJvcFByb2Nlc3NpbmcoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd0Ryb3BQcm9jZXNzaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzaG93KGdldERyb3BQcm9jZXNzaW5nKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldERyb3Bab25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VGVtcGxhdGVFbChjb250YWluZXIsIHNlbGVjdG9yQ2xhc3Nlcy5kcm9wKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0VkaXRGaWxlbmFtZVBvc3NpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNFZGl0RWxlbWVudHNFeGlzdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaWRlUmV0cnk6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaGlkZShnZXRSZXRyeShpZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzUmV0cnlQb3NzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUmV0cnlFbGVtZW50RXhpc3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd1JldHJ5OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHNob3coZ2V0UmV0cnkoaWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGaWxlQ29udGFpbmVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRGaWxlKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93RWRpdEljb246IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGljb24gPSBnZXRFZGl0SWNvbihpZCk7XG4gICAgICAgICAgICAgICAgaWNvbiAmJiBxcShpY29uKS5hZGRDbGFzcyhvcHRpb25zLmNsYXNzZXMuZWRpdGFibGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzSGlkZGVuRm9yZXZlcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEoZ2V0RmlsZShpZCkpLmhhc0NsYXNzKEhJRERFTl9GT1JFVkVSX0NMQVNTKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaWRlRWRpdEljb246IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGljb24gPSBnZXRFZGl0SWNvbihpZCk7XG4gICAgICAgICAgICAgICAgaWNvbiAmJiBxcShpY29uKS5yZW1vdmVDbGFzcyhvcHRpb25zLmNsYXNzZXMuZWRpdGFibGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRWRpdEljb246IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxKGVsKS5oYXNDbGFzcyhzZWxlY3RvckNsYXNzZXMuZWRpdE5hbWVJY29uLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRFZGl0SW5wdXQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlRWwoZ2V0RmlsZShpZCksIHNlbGVjdG9yQ2xhc3Nlcy5lZGl0RmlsZW5hbWVJbnB1dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNFZGl0SW5wdXQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxKGVsKS5oYXNDbGFzcyhzZWxlY3RvckNsYXNzZXMuZWRpdEZpbGVuYW1lSW5wdXQsIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVByb2dyZXNzOiBmdW5jdGlvbihpZCwgbG9hZGVkLCB0b3RhbCkge1xuICAgICAgICAgICAgICAgIHZhciBiYXIgPSBnZXRQcm9ncmVzcyhpZCksIHBlcmNlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGJhciAmJiB0b3RhbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudCA9IE1hdGgucm91bmQobG9hZGVkIC8gdG90YWwgKiAxMDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVyY2VudCA9PT0gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlKGJhcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93KGJhcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0UHJvZ3Jlc3NCYXJXaWR0aChpZCwgcGVyY2VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVRvdGFsUHJvZ3Jlc3M6IGZ1bmN0aW9uKGxvYWRlZCwgdG90YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKG51bGwsIGxvYWRlZCwgdG90YWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGVQcm9ncmVzczogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmFyID0gZ2V0UHJvZ3Jlc3MoaWQpO1xuICAgICAgICAgICAgICAgIGJhciAmJiBoaWRlKGJhcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZVRvdGFsUHJvZ3Jlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVByb2dyZXNzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXRQcm9ncmVzczogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBzZXRQcm9ncmVzc0JhcldpZHRoKGlkLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVUb3RhbFByb2dyZXNzKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldFRvdGFsUHJvZ3Jlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRQcm9ncmVzcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dDYW5jZWw6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0NhbmNlbERpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW5jZWwgPSBnZXRDYW5jZWwoaWQpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWwgJiYgcXEoY2FuY2VsKS5yZW1vdmVDbGFzcyhvcHRpb25zLmNsYXNzZXMuaGlkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGVDYW5jZWw6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaGlkZShnZXRDYW5jZWwoaWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0NhbmNlbDogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEoZWwpLmhhc0NsYXNzKHNlbGVjdG9yQ2xhc3Nlcy5jYW5jZWwsIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsbG93UGF1c2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgc2hvdyhnZXRQYXVzZShpZCkpO1xuICAgICAgICAgICAgICAgIGhpZGUoZ2V0Q29udGludWUoaWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGxvYWRQYXVzZWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXNUZXh0KGlkLCBvcHRpb25zLnRleHQucGF1c2VkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbG93Q29udGludWVCdXR0b24oaWQpO1xuICAgICAgICAgICAgICAgIGhpZGUoZ2V0U3Bpbm5lcihpZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGVQYXVzZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBoaWRlKGdldFBhdXNlKGlkKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNQYXVzZTogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEoZWwpLmhhc0NsYXNzKHNlbGVjdG9yQ2xhc3Nlcy5wYXVzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNDb250aW51ZUJ1dHRvbjogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEoZWwpLmhhc0NsYXNzKHNlbGVjdG9yQ2xhc3Nlcy5jb250aW51ZUJ1dHRvbiwgdHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWxsb3dDb250aW51ZUJ1dHRvbjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBzaG93KGdldENvbnRpbnVlKGlkKSk7XG4gICAgICAgICAgICAgICAgaGlkZShnZXRQYXVzZShpZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwbG9hZENvbnRpbnVlZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1c1RleHQoaWQsIFwiXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dQYXVzZShpZCk7XG4gICAgICAgICAgICAgICAgc2hvdyhnZXRTcGlubmVyKGlkKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd0RlbGV0ZUJ1dHRvbjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBzaG93KGdldERlbGV0ZShpZCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGVEZWxldGVCdXR0b246IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgaGlkZShnZXREZWxldGUoaWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0RlbGV0ZUJ1dHRvbjogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXEoZWwpLmhhc0NsYXNzKHNlbGVjdG9yQ2xhc3Nlcy5kZWxldGVCdXR0b24sIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzUmV0cnk6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxKGVsKS5oYXNDbGFzcyhzZWxlY3RvckNsYXNzZXMucmV0cnksIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVNpemU6IGZ1bmN0aW9uKGlkLCB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSBnZXRTaXplKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBzaG93KHNpemUpO1xuICAgICAgICAgICAgICAgICAgICBxcShzaXplKS5zZXRUZXh0KHRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRTdGF0dXNUZXh0OiBmdW5jdGlvbihpZCwgdGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0RWwgPSBnZXRUZW1wbGF0ZUVsKGdldEZpbGUoaWQpLCBzZWxlY3RvckNsYXNzZXMuc3RhdHVzVGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRFbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxcSh0ZXh0RWwpLmNsZWFyVGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXEodGV4dEVsKS5zZXRUZXh0KHRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGVTcGlubmVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHFxKGdldEZpbGUoaWQpKS5yZW1vdmVDbGFzcyhJTl9QUk9HUkVTU19DTEFTUyk7XG4gICAgICAgICAgICAgICAgaGlkZShnZXRTcGlubmVyKGlkKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd1NwaW5uZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcXEoZ2V0RmlsZShpZCkpLmFkZENsYXNzKElOX1BST0dSRVNTX0NMQVNTKTtcbiAgICAgICAgICAgICAgICBzaG93KGdldFNwaW5uZXIoaWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZVByZXZpZXc6IGZ1bmN0aW9uKGlkLCBvcHRGaWxlT3JCbG9iLCBjdXN0b21SZXNpemVGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkZvcmV2ZXIoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRodW1iR2VuZXJhdGlvblF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tUmVzaXplRnVuY3Rpb246IGN1c3RvbVJlc2l6ZUZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0RmlsZU9yQmxvYjogb3B0RmlsZU9yQmxvYlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgIXRodW1ibmFpbFF1ZXVlTW9uaXRvclJ1bm5pbmcgJiYgZ2VuZXJhdGVOZXh0UXVldWVkUHJldmlldygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVUaHVtYm5haWw6IGZ1bmN0aW9uKGlkLCB0aHVtYm5haWxVcmwsIHNob3dXYWl0aW5nSW1nLCBjdXN0b21SZXNpemVGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkZvcmV2ZXIoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRodW1iR2VuZXJhdGlvblF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tUmVzaXplRnVuY3Rpb246IGN1c3RvbVJlc2l6ZUZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJuYWlsVXJsOiB0aHVtYm5haWxVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93V2FpdGluZ0ltZzogc2hvd1dhaXRpbmdJbWdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICF0aHVtYm5haWxRdWV1ZU1vbml0b3JSdW5uaW5nICYmIGdlbmVyYXRlTmV4dFF1ZXVlZFByZXZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzRGlhbG9nOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHFxLnN1cHBvcnRlZEZlYXR1cmVzLmRpYWxvZ0VsZW1lbnQgJiYgISFnZXREaWFsb2codHlwZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd0RpYWxvZzogZnVuY3Rpb24odHlwZSwgbWVzc2FnZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpYWxvZyA9IGdldERpYWxvZyh0eXBlKSwgbWVzc2FnZUVsID0gZ2V0VGVtcGxhdGVFbChkaWFsb2csIHNlbGVjdG9yQ2xhc3Nlcy5kaWFsb2dNZXNzYWdlKSwgaW5wdXRFbCA9IGRpYWxvZy5nZXRFbGVtZW50c0J5VGFnTmFtZShcIklOUFVUXCIpWzBdLCBjYW5jZWxCdG4gPSBnZXRUZW1wbGF0ZUVsKGRpYWxvZywgc2VsZWN0b3JDbGFzc2VzLmRpYWxvZ0NhbmNlbEJ1dHRvbiksIG9rQnRuID0gZ2V0VGVtcGxhdGVFbChkaWFsb2csIHNlbGVjdG9yQ2xhc3Nlcy5kaWFsb2dPa0J1dHRvbiksIHByb21pc2UgPSBuZXcgcXEuUHJvbWlzZSgpLCBjbG9zZUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQnRuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjYW5jZWxDbGlja0hhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICBva0J0biAmJiBva0J0bi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb2tDbGlja0hhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmZhaWx1cmUoKTtcbiAgICAgICAgICAgICAgICB9LCBjYW5jZWxDbGlja0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQnRuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjYW5jZWxDbGlja0hhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9LCBva0NsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkaWFsb2cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIGNsb3NlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIG9rQnRuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBva0NsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN1Y2Nlc3MoaW5wdXRFbCAmJiBpbnB1dEVsLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRpYWxvZy5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgY2xvc2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNhbmNlbENsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgb2tCdG4gJiYgb2tCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9rQ2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRFbCkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dEVsLnZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXNzYWdlRWwudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIGRpYWxvZy5zaG93TW9kYWwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBxcS5VaUV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uKHMsIHByb3RlY3RlZEFwaSkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGRpc3Bvc2VyID0gbmV3IHFxLkRpc3Bvc2VTdXBwb3J0KCksIHNwZWMgPSB7XG4gICAgICAgICAgICBldmVudFR5cGU6IFwiY2xpY2tcIixcbiAgICAgICAgICAgIGF0dGFjaFRvOiBudWxsLFxuICAgICAgICAgICAgb25IYW5kbGVkOiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50KSB7fVxuICAgICAgICB9O1xuICAgICAgICBxcS5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgYWRkSGFuZGxlcjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoZWxlbWVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gYWRkSGFuZGxlcihlbGVtZW50KSB7XG4gICAgICAgICAgICBkaXNwb3Nlci5hdHRhY2goZWxlbWVudCwgc3BlYy5ldmVudFR5cGUsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuICAgICAgICAgICAgICAgIHNwZWMub25IYW5kbGVkKHRhcmdldCwgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcXEuZXh0ZW5kKHByb3RlY3RlZEFwaSwge1xuICAgICAgICAgICAgZ2V0RmlsZUlkRnJvbUl0ZW06IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5xcUZpbGVJZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXREaXNwb3NlU3VwcG9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpc3Bvc2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcXEuZXh0ZW5kKHNwZWMsIHMpO1xuICAgICAgICBpZiAoc3BlYy5hdHRhY2hUbykge1xuICAgICAgICAgICAgYWRkSGFuZGxlcihzcGVjLmF0dGFjaFRvKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcXEuRmlsZUJ1dHRvbnNDbGlja0hhbmRsZXIgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgaW5oZXJpdGVkSW50ZXJuYWxBcGkgPSB7fSwgc3BlYyA9IHtcbiAgICAgICAgICAgIHRlbXBsYXRpbmc6IG51bGwsXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIGx2bCkge30sXG4gICAgICAgICAgICBvbkRlbGV0ZUZpbGU6IGZ1bmN0aW9uKGZpbGVJZCkge30sXG4gICAgICAgICAgICBvbkNhbmNlbDogZnVuY3Rpb24oZmlsZUlkKSB7fSxcbiAgICAgICAgICAgIG9uUmV0cnk6IGZ1bmN0aW9uKGZpbGVJZCkge30sXG4gICAgICAgICAgICBvblBhdXNlOiBmdW5jdGlvbihmaWxlSWQpIHt9LFxuICAgICAgICAgICAgb25Db250aW51ZTogZnVuY3Rpb24oZmlsZUlkKSB7fSxcbiAgICAgICAgICAgIG9uR2V0TmFtZTogZnVuY3Rpb24oZmlsZUlkKSB7fVxuICAgICAgICB9LCBidXR0b25IYW5kbGVycyA9IHtcbiAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBzcGVjLm9uQ2FuY2VsKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXRyeTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBzcGVjLm9uUmV0cnkoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlbGV0ZUJ1dHRvbjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBzcGVjLm9uRGVsZXRlRmlsZShpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF1c2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgc3BlYy5vblBhdXNlKGlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250aW51ZUJ1dHRvbjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBzcGVjLm9uQ29udGludWUoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBleGFtaW5lRXZlbnQodGFyZ2V0LCBldmVudCkge1xuICAgICAgICAgICAgcXEuZWFjaChidXR0b25IYW5kbGVycywgZnVuY3Rpb24oYnV0dG9uVHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdExldHRlckNhcEJ1dHRvblR5cGUgPSBidXR0b25UeXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgYnV0dG9uVHlwZS5zbGljZSgxKSwgZmlsZUlkO1xuICAgICAgICAgICAgICAgIGlmIChzcGVjLnRlbXBsYXRpbmdbXCJpc1wiICsgZmlyc3RMZXR0ZXJDYXBCdXR0b25UeXBlXSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVJZCA9IHNwZWMudGVtcGxhdGluZy5nZXRGaWxlSWQodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcXEucHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBzcGVjLmxvZyhxcS5mb3JtYXQoXCJEZXRlY3RlZCB2YWxpZCBmaWxlIGJ1dHRvbiBjbGljayBldmVudCBvbiBmaWxlICd7fScsIElEOiB7fS5cIiwgc3BlYy5vbkdldE5hbWUoZmlsZUlkKSwgZmlsZUlkKSk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoZmlsZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHFxLmV4dGVuZChzcGVjLCBzKTtcbiAgICAgICAgc3BlYy5ldmVudFR5cGUgPSBcImNsaWNrXCI7XG4gICAgICAgIHNwZWMub25IYW5kbGVkID0gZXhhbWluZUV2ZW50O1xuICAgICAgICBzcGVjLmF0dGFjaFRvID0gc3BlYy50ZW1wbGF0aW5nLmdldEZpbGVMaXN0KCk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCBuZXcgcXEuVWlFdmVudEhhbmRsZXIoc3BlYywgaW5oZXJpdGVkSW50ZXJuYWxBcGkpKTtcbiAgICB9O1xuICAgIHFxLkZpbGVuYW1lQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24ocykge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGluaGVyaXRlZEludGVybmFsQXBpID0ge30sIHNwZWMgPSB7XG4gICAgICAgICAgICB0ZW1wbGF0aW5nOiBudWxsLFxuICAgICAgICAgICAgbG9nOiBmdW5jdGlvbihtZXNzYWdlLCBsdmwpIHt9LFxuICAgICAgICAgICAgY2xhc3Nlczoge1xuICAgICAgICAgICAgICAgIGZpbGU6IFwicXEtdXBsb2FkLWZpbGVcIixcbiAgICAgICAgICAgICAgICBlZGl0TmFtZUljb246IFwicXEtZWRpdC1maWxlbmFtZS1pY29uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkdldFVwbG9hZFN0YXR1czogZnVuY3Rpb24oZmlsZUlkKSB7fSxcbiAgICAgICAgICAgIG9uR2V0TmFtZTogZnVuY3Rpb24oZmlsZUlkKSB7fVxuICAgICAgICB9O1xuICAgICAgICBxcS5leHRlbmQoc3BlYywgcyk7XG4gICAgICAgIGZ1bmN0aW9uIGV4YW1pbmVFdmVudCh0YXJnZXQsIGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoc3BlYy50ZW1wbGF0aW5nLmlzRmlsZU5hbWUodGFyZ2V0KSB8fCBzcGVjLnRlbXBsYXRpbmcuaXNFZGl0SWNvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVJZCA9IHNwZWMudGVtcGxhdGluZy5nZXRGaWxlSWQodGFyZ2V0KSwgc3RhdHVzID0gc3BlYy5vbkdldFVwbG9hZFN0YXR1cyhmaWxlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IHFxLnN0YXR1cy5TVUJNSVRURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlYy5sb2cocXEuZm9ybWF0KFwiRGV0ZWN0ZWQgdmFsaWQgZmlsZW5hbWUgY2xpY2sgZXZlbnQgb24gZmlsZSAne30nLCBJRDoge30uXCIsIHNwZWMub25HZXROYW1lKGZpbGVJZCksIGZpbGVJZCkpO1xuICAgICAgICAgICAgICAgICAgICBxcS5wcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGluaGVyaXRlZEludGVybmFsQXBpLmhhbmRsZUZpbGVuYW1lRWRpdChmaWxlSWQsIHRhcmdldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNwZWMuZXZlbnRUeXBlID0gXCJjbGlja1wiO1xuICAgICAgICBzcGVjLm9uSGFuZGxlZCA9IGV4YW1pbmVFdmVudDtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIG5ldyBxcS5GaWxlbmFtZUVkaXRIYW5kbGVyKHNwZWMsIGluaGVyaXRlZEludGVybmFsQXBpKSk7XG4gICAgfTtcbiAgICBxcS5GaWxlbmFtZUlucHV0Rm9jdXNJbkhhbmRsZXIgPSBmdW5jdGlvbihzLCBpbmhlcml0ZWRJbnRlcm5hbEFwaSkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIHNwZWMgPSB7XG4gICAgICAgICAgICB0ZW1wbGF0aW5nOiBudWxsLFxuICAgICAgICAgICAgb25HZXRVcGxvYWRTdGF0dXM6IGZ1bmN0aW9uKGZpbGVJZCkge30sXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uKG1lc3NhZ2UsIGx2bCkge31cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFpbmhlcml0ZWRJbnRlcm5hbEFwaSkge1xuICAgICAgICAgICAgaW5oZXJpdGVkSW50ZXJuYWxBcGkgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVJbnB1dEZvY3VzKHRhcmdldCwgZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChzcGVjLnRlbXBsYXRpbmcuaXNFZGl0SW5wdXQodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlSWQgPSBzcGVjLnRlbXBsYXRpbmcuZ2V0RmlsZUlkKHRhcmdldCksIHN0YXR1cyA9IHNwZWMub25HZXRVcGxvYWRTdGF0dXMoZmlsZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSBxcS5zdGF0dXMuU1VCTUlUVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWMubG9nKHFxLmZvcm1hdChcIkRldGVjdGVkIHZhbGlkIGZpbGVuYW1lIGlucHV0IGZvY3VzIGV2ZW50IG9uIGZpbGUgJ3t9JywgSUQ6IHt9LlwiLCBzcGVjLm9uR2V0TmFtZShmaWxlSWQpLCBmaWxlSWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGVkSW50ZXJuYWxBcGkuaGFuZGxlRmlsZW5hbWVFZGl0KGZpbGVJZCwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3BlYy5ldmVudFR5cGUgPSBcImZvY3VzaW5cIjtcbiAgICAgICAgc3BlYy5vbkhhbmRsZWQgPSBoYW5kbGVJbnB1dEZvY3VzO1xuICAgICAgICBxcS5leHRlbmQoc3BlYywgcyk7XG4gICAgICAgIHFxLmV4dGVuZCh0aGlzLCBuZXcgcXEuRmlsZW5hbWVFZGl0SGFuZGxlcihzcGVjLCBpbmhlcml0ZWRJbnRlcm5hbEFwaSkpO1xuICAgIH07XG4gICAgcXEuRmlsZW5hbWVJbnB1dEZvY3VzSGFuZGxlciA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHNwZWMuZXZlbnRUeXBlID0gXCJmb2N1c1wiO1xuICAgICAgICBzcGVjLmF0dGFjaFRvID0gbnVsbDtcbiAgICAgICAgcXEuZXh0ZW5kKHRoaXMsIG5ldyBxcS5GaWxlbmFtZUlucHV0Rm9jdXNJbkhhbmRsZXIoc3BlYywge30pKTtcbiAgICB9O1xuICAgIHFxLkZpbGVuYW1lRWRpdEhhbmRsZXIgPSBmdW5jdGlvbihzLCBpbmhlcml0ZWRJbnRlcm5hbEFwaSkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIHNwZWMgPSB7XG4gICAgICAgICAgICB0ZW1wbGF0aW5nOiBudWxsLFxuICAgICAgICAgICAgbG9nOiBmdW5jdGlvbihtZXNzYWdlLCBsdmwpIHt9LFxuICAgICAgICAgICAgb25HZXRVcGxvYWRTdGF0dXM6IGZ1bmN0aW9uKGZpbGVJZCkge30sXG4gICAgICAgICAgICBvbkdldE5hbWU6IGZ1bmN0aW9uKGZpbGVJZCkge30sXG4gICAgICAgICAgICBvblNldE5hbWU6IGZ1bmN0aW9uKGZpbGVJZCwgbmV3TmFtZSkge30sXG4gICAgICAgICAgICBvbkVkaXRpbmdTdGF0dXNDaGFuZ2U6IGZ1bmN0aW9uKGZpbGVJZCwgaXNFZGl0aW5nKSB7fVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBnZXRGaWxlbmFtZVNhbnNFeHRlbnNpb24oZmlsZUlkKSB7XG4gICAgICAgICAgICB2YXIgZmlsZW5hbWVTYW5zRXh0ID0gc3BlYy5vbkdldE5hbWUoZmlsZUlkKSwgZXh0SWR4ID0gZmlsZW5hbWVTYW5zRXh0Lmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICAgICAgICAgIGlmIChleHRJZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWVTYW5zRXh0ID0gZmlsZW5hbWVTYW5zRXh0LnN1YnN0cigwLCBleHRJZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVuYW1lU2Fuc0V4dDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRPcmlnaW5hbEV4dGVuc2lvbihmaWxlSWQpIHtcbiAgICAgICAgICAgIHZhciBvcmlnTmFtZSA9IHNwZWMub25HZXROYW1lKGZpbGVJZCk7XG4gICAgICAgICAgICByZXR1cm4gcXEuZ2V0RXh0ZW5zaW9uKG9yaWdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVOYW1lVXBkYXRlKG5ld0ZpbGVuYW1lSW5wdXRFbCwgZmlsZUlkKSB7XG4gICAgICAgICAgICB2YXIgbmV3TmFtZSA9IG5ld0ZpbGVuYW1lSW5wdXRFbC52YWx1ZSwgb3JpZ0V4dGVuc2lvbjtcbiAgICAgICAgICAgIGlmIChuZXdOYW1lICE9PSB1bmRlZmluZWQgJiYgcXEudHJpbVN0cihuZXdOYW1lKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgb3JpZ0V4dGVuc2lvbiA9IGdldE9yaWdpbmFsRXh0ZW5zaW9uKGZpbGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdFeHRlbnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdOYW1lID0gbmV3TmFtZSArIFwiLlwiICsgb3JpZ0V4dGVuc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3BlYy5vblNldE5hbWUoZmlsZUlkLCBuZXdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwZWMub25FZGl0aW5nU3RhdHVzQ2hhbmdlKGZpbGVJZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVySW5wdXRCbHVySGFuZGxlcihpbnB1dEVsLCBmaWxlSWQpIHtcbiAgICAgICAgICAgIGluaGVyaXRlZEludGVybmFsQXBpLmdldERpc3Bvc2VTdXBwb3J0KCkuYXR0YWNoKGlucHV0RWwsIFwiYmx1clwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOYW1lVXBkYXRlKGlucHV0RWwsIGZpbGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWdpc3RlcklucHV0RW50ZXJLZXlIYW5kbGVyKGlucHV0RWwsIGZpbGVJZCkge1xuICAgICAgICAgICAgaW5oZXJpdGVkSW50ZXJuYWxBcGkuZ2V0RGlzcG9zZVN1cHBvcnQoKS5hdHRhY2goaW5wdXRFbCwgXCJrZXl1cFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gZXZlbnQua2V5Q29kZSB8fCBldmVudC53aGljaDtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlTmFtZVVwZGF0ZShpbnB1dEVsLCBmaWxlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHFxLmV4dGVuZChzcGVjLCBzKTtcbiAgICAgICAgc3BlYy5hdHRhY2hUbyA9IHNwZWMudGVtcGxhdGluZy5nZXRGaWxlTGlzdCgpO1xuICAgICAgICBxcS5leHRlbmQodGhpcywgbmV3IHFxLlVpRXZlbnRIYW5kbGVyKHNwZWMsIGluaGVyaXRlZEludGVybmFsQXBpKSk7XG4gICAgICAgIHFxLmV4dGVuZChpbmhlcml0ZWRJbnRlcm5hbEFwaSwge1xuICAgICAgICAgICAgaGFuZGxlRmlsZW5hbWVFZGl0OiBmdW5jdGlvbihpZCwgdGFyZ2V0LCBmb2N1c0lucHV0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0ZpbGVuYW1lSW5wdXRFbCA9IHNwZWMudGVtcGxhdGluZy5nZXRFZGl0SW5wdXQoaWQpO1xuICAgICAgICAgICAgICAgIHNwZWMub25FZGl0aW5nU3RhdHVzQ2hhbmdlKGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBuZXdGaWxlbmFtZUlucHV0RWwudmFsdWUgPSBnZXRGaWxlbmFtZVNhbnNFeHRlbnNpb24oaWQpO1xuICAgICAgICAgICAgICAgIGlmIChmb2N1c0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpbGVuYW1lSW5wdXRFbC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWdpc3RlcklucHV0Qmx1ckhhbmRsZXIobmV3RmlsZW5hbWVJbnB1dEVsLCBpZCk7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJJbnB1dEVudGVyS2V5SGFuZGxlcihuZXdGaWxlbmFtZUlucHV0RWwsIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn0pKHdpbmRvdyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5lLXVwbG9hZGVyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fine-uploader/fine-uploader/fine-uploader.js\n");

/***/ })

}]);